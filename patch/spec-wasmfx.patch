diff --git a/.github/workflows/ci-interpreter.yml b/.github/workflows/ci-interpreter.yml
deleted file mode 100644
index 8f7b02c0..00000000
--- a/.github/workflows/ci-interpreter.yml
+++ /dev/null
@@ -1,36 +0,0 @@
-name: CI for interpreter & tests
-
-on:
-  push:
-    branches: [ main ]
-    paths: [ interpreter/**, test/** ]
-
-  pull_request:
-    branches: [ main ]
-    paths: [ interpreter/**, test/** ]
-
-  # Allows you to run this workflow manually from the Actions tab
-  workflow_dispatch:
-
-jobs:
-  interpreter:
-    runs-on: ubuntu-latest
-    steps:
-      - name: Checkout repo
-        uses: actions/checkout@v2
-      - name: Setup OCaml
-        uses: ocaml/setup-ocaml@v2
-        with:
-          ocaml-compiler: 4.14.x
-      - name: Setup OCaml tools
-        run: opam install --yes ocamlbuild.0.14.0 ocamlfind.1.9.5 js_of_ocaml.4.0.0 js_of_ocaml-ppx.4.0.0
-      - name: Setup Node.js
-        uses: actions/setup-node@v2
-        with:
-          node-version: 19.x
-      - name: Build interpreter
-        run: cd interpreter && opam exec make
-      - name: Run tests
-        # TODO: disable node.js run until it fully implements proposal
-        # run: cd interpreter && opam exec make JS=node ci
-        run: cd interpreter && opam exec make ci
diff --git a/.github/workflows/ci-spec.yml b/.github/workflows/ci-spec.yml
deleted file mode 100644
index 7610b33b..00000000
--- a/.github/workflows/ci-spec.yml
+++ /dev/null
@@ -1,101 +0,0 @@
-name: CI for specs
-
-on:
-  push:
-    branches: [ main ]
-    paths: [ document/** ]
-
-  pull_request:
-    branches: [ main ]
-    paths: [ document/** ]
-
-  # Allows you to run this workflow manually from the Actions tab
-  workflow_dispatch:
-
-jobs:
-  build-core-spec:
-    runs-on: ubuntu-latest
-    steps:
-      - name: Checkout repo
-        uses: actions/checkout@v2
-        with:
-          submodules: "recursive"
-      - name: Setup Node.js
-        uses: actions/setup-node@v3
-        with:
-          node-version: 16
-      - name: Setup Bikeshed
-        run: pip install bikeshed && bikeshed update
-      - name: Setup TexLive
-        run: sudo apt-get update -y && sudo apt-get install -y latexmk texlive-latex-recommended texlive-latex-extra texlive-fonts-recommended
-      - name: Setup Sphinx
-        run: pip install six && pip install sphinx==5.1.0
-      - name: Build main spec
-        run: cd document/core && make main
-      - name: Run Bikeshed
-        run: cd document/core && make bikeshed
-      - name: Upload artifact
-        uses: actions/upload-artifact@v2
-        with:
-          name: core-rendered
-          path: document/core/_build/html
-
-  build-js-api-spec:
-    runs-on: ubuntu-latest
-    steps:
-      - name: Checkout repo
-        uses: actions/checkout@v2
-      - name: Setup Bikeshed
-        run: pip install bikeshed && bikeshed update
-      - name: Run Bikeshed
-        run: bikeshed spec "document/js-api/index.bs" "document/js-api/index.html"
-      - name: Upload artifact
-        uses: actions/upload-artifact@v2
-        with:
-          name: js-api-rendered
-          path: document/js-api/index.html
-
-  build-web-api-spec:
-    runs-on: ubuntu-latest
-    steps:
-      - name: Checkout repo
-        uses: actions/checkout@v2
-      - name: Setup Bikeshed
-        run: pip install bikeshed && bikeshed update
-      - name: Run Bikeshed
-        run: bikeshed spec "document/web-api/index.bs" "document/web-api/index.html"
-      - name: Upload artifact
-        uses: actions/upload-artifact@v2
-        with:
-          name: web-api-rendered
-          path: document/web-api/index.html
-
-  publish-spec:
-    runs-on: ubuntu-latest
-    needs: [build-core-spec, build-js-api-spec, build-web-api-spec]
-    steps:
-      - name: Checkout repo
-        uses: actions/checkout@v2
-      - name: Create output directory
-        run: mkdir _output && cp document/index.html _output/index.html
-      - name: Download core spec artifact
-        uses: actions/download-artifact@v2
-        with:
-          name: core-rendered
-          path: _output/core
-      - name: Download JS API spec artifact
-        uses: actions/download-artifact@v2
-        with:
-          name: js-api-rendered
-          path: _output/js-api
-      - name: Download Web API spec artifact
-        uses: actions/download-artifact@v2
-        with:
-          name: web-api-rendered
-          path: _output/web-api
-      - name: Publish to GitHub Pages
-        if: github.ref == 'refs/heads/main'
-        uses: peaceiris/actions-gh-pages@v3
-        with:
-          publish_dir: ./_output
-          github_token: ${{ secrets.GITHUB_TOKEN }}
diff --git a/.github/workflows/main.yml b/.github/workflows/main.yml
new file mode 100644
index 00000000..e20e3db4
--- /dev/null
+++ b/.github/workflows/main.yml
@@ -0,0 +1,105 @@
+name: CI
+
+on:
+  push:
+    branches: [ main ]
+  pull_request:
+    branches: [ main ]
+
+  # Allows you to run this workflow manually from the Actions tab
+  workflow_dispatch:
+
+jobs:
+  ref-interpreter:
+    runs-on: ubuntu-latest
+    steps:
+      - uses: actions/checkout@v3
+      - name: Setup OCaml
+        uses: ocaml/setup-ocaml@v2
+        with:
+          ocaml-compiler: 4.13.x
+      - run: opam install --yes ocamlbuild.0.14.0
+      - name: Setup Node.js
+        uses: actions/setup-node@v1
+        with:
+          node-version: 19.x
+      # TODO: disable node.js run until it fully implements proposal
+      # - run: cd interpreter && opam exec make JS=node all
+      - run: cd interpreter && opam exec make all
+
+  ref-interpreter-js-library:
+    runs-on: ubuntu-latest
+    steps:
+      - uses: actions/checkout@v2
+      - name: Setup OCaml
+        uses: ocaml/setup-ocaml@v2
+        with:
+          ocaml-compiler: 4.13.x
+      - run: opam install --yes ocamlbuild.0.14.0 ocamlfind.1.9.5 js_of_ocaml.4.0.0 js_of_ocaml-ppx.4.0.0
+      - run: cd interpreter && opam exec make wast.js
+
+  build-js-api-spec:
+    runs-on: ubuntu-latest
+    steps:
+      - uses: actions/checkout@v2
+      - run: pip install bikeshed && bikeshed update
+      - run: bikeshed spec "document/js-api/index.bs" "document/js-api/index.html"
+      - uses: actions/upload-artifact@v2
+        with:
+          name: js-api-rendered
+          path: document/js-api/index.html
+
+  build-web-api-spec:
+    runs-on: ubuntu-latest
+    steps:
+      - uses: actions/checkout@v2
+      - run: pip install bikeshed && bikeshed update
+      - run: bikeshed spec "document/web-api/index.bs" "document/web-api/index.html"
+      - uses: actions/upload-artifact@v2
+        with:
+          name: web-api-rendered
+          path: document/web-api/index.html
+
+  build-core-spec:
+    runs-on: ubuntu-latest
+    steps:
+      - uses: actions/checkout@v2
+        with:
+          submodules: "recursive"
+      - uses: actions/setup-node@v3
+        with:
+          node-version: 16
+      - run: pip install bikeshed && bikeshed update
+      - run: pip install six
+      - run: sudo apt-get update -y && sudo apt-get install -y latexmk texlive-latex-recommended texlive-latex-extra texlive-fonts-recommended
+      - run: pip install sphinx==5.1.0
+      - run: cd document/core && make all
+      - uses: actions/upload-artifact@v2
+        with:
+          name: core-api-rendered
+          path: document/core/_build/html
+
+  publish-spec:
+    runs-on: ubuntu-latest
+    needs: [build-core-spec, build-js-api-spec, build-web-api-spec]
+    steps:
+      - uses: actions/checkout@v2
+      - run: mkdir _output && cp document/index.html _output/index.html
+      - uses: actions/download-artifact@v2
+        with:
+          name: js-api-rendered
+          path: _output/js-api
+      - uses: actions/download-artifact@v2
+        with:
+          name: web-api-rendered
+          path: _output/web-api
+      - uses: actions/download-artifact@v2
+        with:
+          name: core-api-rendered
+          path: _output/core
+      - name: Publish HTML to GitHub Pages
+        if: github.ref == 'refs/heads/main'
+        uses: peaceiris/actions-gh-pages@v3
+        with:
+          publish_dir: ./_output
+          github_token: ${{ secrets.GITHUB_TOKEN }}
diff --git a/.github/workflows/mirror-to-master.yml b/.github/workflows/mirror.yml
similarity index 81%
rename from .github/workflows/mirror-to-master.yml
rename to .github/workflows/mirror.yml
index 7849af75..5c470757 100644
--- a/.github/workflows/mirror-to-master.yml
+++ b/.github/workflows/mirror.yml
@@ -1,5 +1,3 @@
-name: Mirror main branch to master branch
-
 on:
   push:
     branches:
@@ -10,7 +8,8 @@ jobs:
     runs-on: ubuntu-latest
     name: Mirror main branch to master branch
     steps:
-    - name: Mirror branch
+    - name: Mirror action step
+      id: mirror
       uses: google/mirror-branch-action@v1.0
       with:
         github-token: ${{ secrets.GITHUB_TOKEN }}
diff --git a/README.md b/README.md
index b204e475..d9d4412d 100644
--- a/README.md
+++ b/README.md
@@ -1,18 +1,20 @@
-[![CI for specs](https://github.com/WebAssembly/function-references/actions/workflows/ci-spec.yml/badge.svg)](https://github.com/WebAssembly/function-references/actions/workflows/ci-spec.yml)
-[![CI for interpreter & tests](https://github.com/WebAssembly/function-references/actions/workflows/ci-interpreter.yml/badge.svg)](https://github.com/WebAssembly/function-references/actions/workflows/ci-interpreter.yml)
+# Typed Continuations Proposal for WebAssembly
 
-# Function Reference Types Proposal for WebAssembly
+This repository is a clone of
+[github.com/WebAssembly/spec/](https://github.com/WebAssembly/spec/).
+It is meant for discussion, prototype specification and implementation
+of a proposal to add support for different patterns of non-local
+control flow to WebAssembly.
 
-This repository is a clone of [github.com/WebAssembly/spec/](https://github.com/WebAssembly/spec/).
-It is meant for discussion, prototype specification and implementation of a proposal to add support for basic function reference types to WebAssembly.
+The proposal is fully implemented as part of the reference interpreter.
 
-* See the [overview](proposals/function-references/Overview.md) for a summary of the proposal.
+* See the [explainer](proposals/continuations/Explainer.md) for a high-level summary of the proposal.
 
-* See the [modified spec](https://webassembly.github.io/function-references/core) for details.
+* See the [overview](proposals/continuations/Overview.md) for a more formal description of the proposal.
 
-The repository is now based on the [bulk operations proposal](proposals/bulk-memory-operations/Overview.md) and includes all respective changes.
+* See the [examples](proposals/continuations/examples) for Wasm code for implementing various different features including lightweight threads, actors, and async/await.
 
-Original README from upstream repository follows...
+Original `README` from upstream repository follows.
 
 # spec
 
diff --git a/document/core/.gitignore b/document/core/.gitignore
index b932ec28..d21e55e3 100644
--- a/document/core/.gitignore
+++ b/document/core/.gitignore
@@ -1,3 +1,4 @@
 _build
 _static
 document/*.pyc
+appendix/index-instructions.rst
diff --git a/document/core/Makefile b/document/core/Makefile
index 8a3650ec..d8b357c7 100644
--- a/document/core/Makefile
+++ b/document/core/Makefile
@@ -89,14 +89,12 @@ bikeshed-keep:
 	  echo Downloaded Bikeshed.
 
 
-GENERATED = appendix/index-instructions.rst
-.INTERMEDIATE: $(GENERATED)
-
-%.rst: %.py
-	(cd `dirname $@`; ./`basename $^`)
+.PHONY: index
+index:
+	(cd appendix; ./index-instructions.py)
 
 .PHONY: pdf
-pdf:	$(GENERATED) latexpdf
+pdf:	index latexpdf
 	mkdir -p $(BUILDDIR)/html/$(DOWNLOADDIR)
 	ln -f $(BUILDDIR)/latex/$(NAME).pdf $(BUILDDIR)/html/$(DOWNLOADDIR)/$(NAME).pdf
 
@@ -105,10 +103,10 @@ pdf:	$(GENERATED) latexpdf
 clean:
 	rm -rf $(BUILDDIR)
 	rm -rf $(STATICDIR)
-	rm -f $(GENERATED)
+	rm -f appendix/index-instructions.rst
 
 .PHONY: html
-html: $(GENERATED)
+html: index
 	$(SPHINXBUILD) -b html $(ALLSPHINXOPTS) $(BUILDDIR)/html
 	for file in `ls $(BUILDDIR)/html/*.html`; \
 	do \
@@ -124,34 +122,28 @@ html: $(GENERATED)
 	@echo "Build finished. The HTML pages are in `pwd`/$(BUILDDIR)/html/."
 
 .PHONY: dirhtml
-dirhtml: $(GENERATED)
+dirhtml:
 	$(SPHINXBUILD) -b dirhtml $(ALLSPHINXOPTS) $(BUILDDIR)/dirhtml
 	@echo
 	@echo "Build finished. The HTML pages are in $(BUILDDIR)/dirhtml."
 
 .PHONY: singlehtml
-singlehtml: $(GENERATED)
+singlehtml:
 	$(SPHINXBUILD) -b singlehtml $(ALLSPHINXOPTS) $(BUILDDIR)/singlehtml
 	@echo
 	@echo "Build finished. The HTML page is in $(BUILDDIR)/singlehtml."
 
 .PHONY: bikeshed
-bikeshed: $(GENERATED)
+bikeshed:
 	$(SPHINXBUILD) -b singlehtml -c util/bikeshed \
 		$(ALLSPHINXOPTS) $(BUILDDIR)/bikeshed_singlehtml
-	python3 util/bikeshed_fixup.py $(BUILDDIR)/bikeshed_singlehtml/index.html \
+	python util/bikeshed_fixup.py $(BUILDDIR)/bikeshed_singlehtml/index.html \
 		>$(BUILDDIR)/bikeshed_singlehtml/index_fixed.html
-	@echo ==== Showing contents of _build/bikeshed_singlehtml/index_fixed.html ====
-	@head -n10 _build/bikeshed_singlehtml/index_fixed.html
-	@echo ... skipping $$(expr `cat _build/bikeshed_singlehtml/index_fixed.html | wc -l` - 20) lines ...
-	@tail -n10 _build/bikeshed_singlehtml/index_fixed.html
-	@echo
-	@echo =========================================================================
 	mkdir -p $(BUILDDIR)/bikeshed_mathjax/
 	bikeshed spec index.bs $(BUILDDIR)/bikeshed_mathjax/index.html
 	mkdir -p $(BUILDDIR)/html/bikeshed/
 	(cd util/katex/ && yarn && yarn build && npm install --only=prod)
-	python3 util/mathjax2katex.py $(BUILDDIR)/bikeshed_mathjax/index.html \
+	python util/mathjax2katex.py $(BUILDDIR)/bikeshed_mathjax/index.html \
 		>$(BUILDDIR)/html/bikeshed/index.html
 	mkdir -p $(BUILDDIR)/html/bikeshed/katex/dist/
 	cp -r util/katex/dist/* $(BUILDDIR)/html/bikeshed/katex/dist/
@@ -268,7 +260,7 @@ latex:
 	      "(use \`make latexpdf' here to do that automatically)."
 
 .PHONY: latexpdf
-latexpdf: $(GENERATED)
+latexpdf:
 	$(SPHINXBUILD) -b latex $(ALLSPHINXOPTS) $(BUILDDIR)/latex
 	@echo "Running LaTeX files through pdflatex..."
 	$(MAKE) -C $(BUILDDIR)/latex LATEXMKOPTS=" </dev/null" all-pdf >$(BUILDDIR)/latex/LOG 2>&1 || cat $(BUILDDIR)/latex/LOG
diff --git a/document/core/appendix/embedding.rst b/document/core/appendix/embedding.rst
index c94f8753..dda85673 100644
--- a/document/core/appendix/embedding.rst
+++ b/document/core/appendix/embedding.rst
@@ -167,7 +167,7 @@ Modules
 :math:`\F{module\_imports}(\module) : (\name, \name, \externtype)^\ast`
 .......................................................................
 
-1. Pre-condition: :math:`\module` is :ref:`valid <valid-module>` with the external import types :math:`\externtype^\ast` and external export types :math:`{\externtype'}^\ast`.
+1. Pre-condition: :math:`\module` is :ref:`valid <valid-module>` with the :ref:`dynamic <syntax-type-dyn>` external import types :math:`\externtype^\ast` and external export types :math:`{\externtype'}^\ast`.
 
 2. Let :math:`\import^\ast` be the :ref:`imports <syntax-import>` :math:`\module.\MIMPORTS`.
 
@@ -179,7 +179,7 @@ Modules
 
 5. Return the concatenation of all :math:`\X{result}_i`, in index order.
 
-6. Post-condition: each :math:`\externtype_i` is :ref:`valid <valid-externtype>` under the empty :ref:`context <context>`.
+6. Post-condition: each :ref:`dynamic <syntax-type-dyn>` :math:`\externtype_i` is :ref:`valid <valid-externtype>`.
 
 .. math::
    ~ \\
@@ -195,7 +195,7 @@ Modules
 :math:`\F{module\_exports}(\module) : (\name, \externtype)^\ast`
 ................................................................
 
-1. Pre-condition: :math:`\module` is :ref:`valid <valid-module>` with the external import types :math:`\externtype^\ast` and external export types :math:`{\externtype'}^\ast`.
+1. Pre-condition: :math:`\module` is :ref:`valid <valid-module>` with the :ref:`dynamic <syntax-type-dyn>` external import types :math:`\externtype^\ast` and external export types :math:`{\externtype'}^\ast`.
 
 2. Let :math:`\export^\ast` be the :ref:`exports <syntax-export>` :math:`\module.\MEXPORTS`.
 
@@ -207,7 +207,7 @@ Modules
 
 5. Return the concatenation of all :math:`\X{result}_i`, in index order.
 
-6. Post-condition: each :math:`\externtype'_i` is :ref:`valid <valid-externtype>` under the empty :ref:`context <context>`.
+6. Post-condition: each :ref:`dynamic <syntax-type-dyn>` :math:`\externtype'_i` is :ref:`valid <valid-externtype>`.
 
 .. math::
    ~ \\
@@ -246,6 +246,29 @@ Module Instances
    \end{array}
 
 
+.. index:: type, type instance, function type
+.. _embed-type:
+
+Types
+~~~~~
+
+.. _embed-type-alloc:
+
+:math:`\F{type\_alloc}(\store, \functype) : (\store, \typeaddr)`
+...........................................................................
+
+1. Pre-condition: the :ref:`dynamic <syntax-type-dyn>` :math:`\functype` is :ref:`valid <valid-functype>`.
+
+2. Let :math:`\typeaddr` be the result of :ref:`allocating a type <alloc-type>` in :math:`\store` for :ref:`function type <syntax-functype>` :math:`\functype`.
+
+3. Return the new store paired with :math:`\typeaddr`.
+
+.. math::
+   \begin{array}{lclll}
+   \F{type\_alloc}(S, \X{ft}) &=& (S', \X{a}) && (\iff \alloctype(S, \X{ft}) = S', \X{a}) \\
+   \end{array}
+
+
 .. index:: function, host function, function address, function instance, function type, store
 .. _embed-func:
 
@@ -254,12 +277,12 @@ Functions
 
 .. _embed-func-alloc:
 
-:math:`\F{func\_alloc}(\store, \functype, \hostfunc) : (\store, \funcaddr)`
+:math:`\F{func\_alloc}(\store, \typeaddr, \hostfunc) : (\store, \funcaddr)`
 ...........................................................................
 
-1. Pre-condition: the :math:`\functype` is :ref:`valid <valid-functype>` under the empty :ref:`context <context>`.
+1. Pre-condition: the :ref:`dynamic <syntax-type-dyn>` :math:`\functype` is :ref:`valid <valid-functype>`.
 
-2. Let :math:`\funcaddr` be the result of :ref:`allocating a host function <alloc-func>` in :math:`\store` with :ref:`function type <syntax-functype>` :math:`\functype` and host function code :math:`\hostfunc`.
+2. Let :math:`\funcaddr` be the result of :ref:`allocating a host function <alloc-func>` in :math:`\store` with :ref:`type address <syntax-typeaddr>` :math:`\typeaddr` and host function code :math:`\hostfunc`.
 
 3. Return the new store paired with :math:`\funcaddr`.
 
@@ -279,15 +302,15 @@ Functions
 :math:`\F{func\_type}(\store, \funcaddr) : \functype`
 .....................................................
 
-1. Let :math:`\functype` be the :ref:`function type <syntax-functype>` :math:`S.\SFUNCS[a].\FITYPE`.
+1. Let :math:`\typeaddr` be the :ref:`type address <syntax-typeaddr>` :math:`S.\SFUNCS[a].\FITYPE`.
 
-2. Return :math:`\functype`.
+2. Return :math:`S.\STYPES[\typeaddr]`.
 
-3. Post-condition: the returned :ref:`function type <syntax-functype>` is :ref:`valid <valid-functype>`.
+3. Post-condition: the returned :ref:`dynamic <syntax-type-dyn>` :ref:`function type <syntax-functype>` is :ref:`valid <valid-functype>`.
 
 .. math::
    \begin{array}{lclll}
-   \F{func\_type}(S, a) &=& S.\SFUNCS[a].\FITYPE \\
+   \F{func\_type}(S, a) &=& S.\STYPES[S.\SFUNCS[a].\FITYPE] \\
    \end{array}
 
 
@@ -327,7 +350,7 @@ Tables
 :math:`\F{table\_alloc}(\store, \tabletype) : (\store, \tableaddr, \reff)`
 ..........................................................................
 
-1. Pre-condition: the :math:`\tabletype` is :ref:`valid <valid-tabletype>` under the empty :ref:`context <context>`.
+1. Pre-condition: the :ref:`dynamic <syntax-type-dyn>` :math:`\tabletype` is :ref:`valid <valid-tabletype>`.
 
 2. Let :math:`\tableaddr` be the result of :ref:`allocating a table <alloc-table>` in :math:`\store` with :ref:`table type <syntax-tabletype>` :math:`\tabletype` and initialization value :math:`\reff`.
 
@@ -346,7 +369,7 @@ Tables
 
 1. Return :math:`S.\STABLES[a].\TITYPE`.
 
-2. Post-condition: the returned :ref:`table type <syntax-tabletype>` is :ref:`valid <valid-tabletype>` under the empty :ref:`context <context>`.
+2. Post-condition: the returned :ref:`dynamic <syntax-type-dyn>` :ref:`table type <syntax-tabletype>` is :ref:`valid <valid-tabletype>`.
 
 .. math::
    \begin{array}{lclll}
@@ -439,7 +462,7 @@ Memories
 :math:`\F{mem\_alloc}(\store, \memtype) : (\store, \memaddr)`
 ................................................................
 
-1. Pre-condition: the :math:`\memtype` is :ref:`valid <valid-memtype>` under the empty :ref:`context <context>`.
+1. Pre-condition: the :ref:`dynamic <syntax-type-dyn>` :math:`\memtype` is :ref:`valid <valid-memtype>`.
 
 2. Let :math:`\memaddr` be the result of :ref:`allocating a memory <alloc-mem>` in :math:`\store` with :ref:`memory type <syntax-memtype>` :math:`\memtype`.
 
@@ -458,7 +481,7 @@ Memories
 
 1. Return :math:`S.\SMEMS[a].\MITYPE`.
 
-2. Post-condition: the returned :ref:`memory type <syntax-memtype>` is :ref:`valid <valid-memtype>` under the empty :ref:`context <context>`.
+2. Post-condition: the returned :ref:`dynamic <syntax-type-dyn>` :ref:`memory type <syntax-memtype>` is :ref:`valid <valid-memtype>`.
 
 .. math::
    \begin{array}{lclll}
@@ -552,7 +575,7 @@ Globals
 :math:`\F{global\_alloc}(\store, \globaltype, \val) : (\store, \globaladdr)`
 ............................................................................
 
-1. Pre-condition: the :math:`\globaltype` is :ref:`valid <valid-globaltype>` under the empty :ref:`context <context>`.
+1. Pre-condition: the :ref:`dynamic <syntax-type-dyn>` :math:`\globaltype` is :ref:`valid <valid-globaltype>`.
 
 2. Let :math:`\globaladdr` be the result of :ref:`allocating a global <alloc-global>` in :math:`\store` with :ref:`global type <syntax-globaltype>` :math:`\globaltype` and initialization value :math:`\val`.
 
@@ -571,7 +594,7 @@ Globals
 
 1. Return :math:`S.\SGLOBALS[a].\GITYPE`.
 
-2. Post-condition: the returned :ref:`global type <syntax-globaltype>` is :ref:`valid <valid-globaltype>` under the empty :ref:`context <context>`.
+2. Post-condition: the returned :ref:`dynamic <syntax-type-dyn>` :ref:`global type <syntax-globaltype>` is :ref:`valid <valid-globaltype>`.
 
 .. math::
    \begin{array}{lclll}
diff --git a/document/core/appendix/index-rules.rst b/document/core/appendix/index-rules.rst
index 64f91a51..ba337a76 100644
--- a/document/core/appendix/index-rules.rst
+++ b/document/core/appendix/index-rules.rst
@@ -29,7 +29,7 @@ Construct                                        Judgement
 :ref:`Instruction <valid-instr>`                 :math:`S;C \vdashinstr \instr : \functype`
 :ref:`Instruction sequence <valid-instr-seq>`    :math:`S;C \vdashinstrseq \instr^\ast : \functype`
 :ref:`Expression <valid-expr>`                   :math:`C \vdashexpr \expr : \resulttype`
-:ref:`Function <valid-func>`                     :math:`C \vdashfunc \func : \functype`
+:ref:`Function <valid-func>`                     :math:`C \vdashfunc \func : \typeid`
 :ref:`Local <valid-local>`                       :math:`C \vdashlocal \local : \localtype`
 :ref:`Table <valid-table>`                       :math:`C \vdashtable \table : \tabletype`
 :ref:`Memory <valid-mem>`                        :math:`C \vdashmem \mem : \memtype`
@@ -58,6 +58,7 @@ Construct                                        Judgement
 :ref:`Value <valid-val>`                         :math:`S \vdashval \val : \valtype`
 :ref:`Result <valid-result>`                     :math:`S \vdashresult \result : \resulttype`
 :ref:`External value <valid-externval>`          :math:`S \vdashexternval \externval : \externtype`
+:ref:`Type instance <valid-typeinst>`            :math:`S \vdashtypeinst \typeinst \ok`
 :ref:`Function instance <valid-funcinst>`        :math:`S \vdashfuncinst \funcinst : \functype`
 :ref:`Table instance <valid-tableinst>`          :math:`S \vdashtableinst \tableinst : \tabletype`
 :ref:`Memory instance <valid-meminst>`           :math:`S \vdashmeminst \meminst : \memtype`
@@ -121,6 +122,7 @@ Store Extension
 ===============================================  ===============================================================================
 Construct                                        Judgement
 ===============================================  ===============================================================================
+:ref:`Type instance <extend-typeinst>`           :math:`\vdashtypeinstextends \typeinst_1 \extendsto \typeinst_2`
 :ref:`Function instance <extend-funcinst>`       :math:`\vdashfuncinstextends \funcinst_1 \extendsto \funcinst_2`
 :ref:`Table instance <extend-tableinst>`         :math:`\vdashtableinstextends \tableinst_1 \extendsto \tableinst_2`
 :ref:`Memory instance <extend-meminst>`          :math:`\vdashmeminstextends \meminst_1 \extendsto \meminst_2`
diff --git a/document/core/appendix/properties.rst b/document/core/appendix/properties.rst
index 45e3084b..cd52c399 100644
--- a/document/core/appendix/properties.rst
+++ b/document/core/appendix/properties.rst
@@ -26,14 +26,14 @@ In order to state and prove soundness precisely, the typing rules must be extend
 Results
 ~~~~~~~
 
-:ref:`Results <syntax-result>` can be classified by :ref:`result types <syntax-resulttype>` as follows.
+:ref:`Results <syntax-result>` can be classified by :ref:`dynamic <syntax-type-dyn>` :ref:`result types <syntax-resulttype>` as follows.
 
 :ref:`Results <syntax-result>` :math:`\val^\ast`
 ................................................
 
 * For each :ref:`value <syntax-val>` :math:`\val_i` in :math:`\val^\ast`:
 
-  * The value :math:`\val_i` is :ref:`valid <valid-val>` with some :ref:`value type <syntax-valtype>` :math:`t_i`.
+  * The value :math:`\val_i` is :ref:`valid <valid-val>` with some :ref:`dynamic <syntax-type-dyn>` :ref:`value type <syntax-valtype>` :math:`t_i`.
 
 * Let :math:`t^\ast` be the concatenation of all :math:`t_i`.
 
@@ -50,11 +50,11 @@ Results
 :ref:`Results <syntax-result>` :math:`\TRAP`
 ............................................
 
-* The result is valid with :ref:`result type <syntax-resulttype>` :math:`[t^\ast]`, for any :ref:`valid <valid-resulttype>` :ref:`closed <type-closed>` :ref:`result types <syntax-resulttype>`.
+* The result is valid with :ref:`result type <syntax-resulttype>` :math:`[t^\ast]`, for any :ref:`valid <valid-resulttype>` :ref:`dynamic <syntax-type-dyn>` :ref:`result types <syntax-resulttype>`.
 
 .. math::
    \frac{
-     \vdashresulttype [t^\ast] \ok
+     S \vdashresulttype [t^\ast] \ok
    }{
      S \vdashresult \TRAP : [t^\ast]
    }
@@ -80,7 +80,9 @@ Module instances are classified by *module contexts*, which are regular :ref:`co
 :ref:`Store <syntax-store>` :math:`S`
 .....................................
 
-* Each :ref:`function instance <syntax-funcinst>` :math:`\funcinst_i` in :math:`S.\SFUNCS` must be :ref:`valid <valid-funcinst>` with some :ref:`function type <syntax-functype>` :math:`\functype_i`.
+* Each :ref:`type instance <syntax-typeinst>` :math:`\typeinst_i` in :math:`S.\STYPES` must be :ref:`valid <valid-functype>` in a store :math:`S'_i` only containing the sequence :math:`\typeinst_0 \dots \typeinst_{i-1}` of preceding type instances.
+
+* Each :ref:`function instance <syntax-funcinst>` :math:`\funcinst_i` in :math:`S.\SFUNCS` must be :ref:`valid <valid-funcinst>` with some :ref:`type address <syntax-typeaddr>` :math:`\typeaddr_i`.
 
 * Each :ref:`table instance <syntax-tableinst>` :math:`\tableinst_i` in :math:`S.\STABLES` must be :ref:`valid <valid-tableinst>` with some :ref:`table type <syntax-tabletype>` :math:`\tabletype_i`.
 
@@ -98,7 +100,11 @@ Module instances are classified by *module contexts*, which are regular :ref:`co
    ~\\[-1ex]
    \frac{
      \begin{array}{@{}c@{}}
-     (S \vdashfuncinst \funcinst : \functype)^\ast
+     a^n = 0 \dots (n-1)
+     \qquad
+     (\{\STYPES~\typeinst^n[0 \slice a]\} \vdashtypeinst \typeinst \ok)^n
+     \\
+     (S \vdashfuncinst \funcinst : \typeaddr)^\ast
      \qquad
      (S \vdashtableinst \tableinst : \tabletype)^\ast
      \\
@@ -112,6 +118,7 @@ Module instances are classified by *module contexts*, which are regular :ref:`co
      \\
      S = \{
        \begin{array}[t]{@{}l@{}}
+       \STYPES~\typeinst^n,
        \SFUNCS~\funcinst^\ast,
        \SGLOBALS~\globalinst^\ast, \\
        \STABLES~\tableinst^\ast,
@@ -128,49 +135,63 @@ Module instances are classified by *module contexts*, which are regular :ref:`co
    The validity condition on type instances ensures the absence of cyclic types.
 
 
+.. index:: function type, type instance
+.. _valid-typeinst:
+
+:ref:`Type Instances <syntax-typeinst>` :math:`\functype`
+.........................................................
+
+* The :ref:`dynamic <syntax-type-dyn>` :ref:`function type <syntax-functype>` :math:`\functype` must be :ref:`valid <valid-functype>`.
+
+* Then it is valid as a type instance.
+
+.. math::
+   \frac{
+     S \vdashfunctype \functype \ok
+   }{
+     S \vdashtypeinst \functype \ok
+   }
+
+
 .. index:: function type, function instance
 .. _valid-funcinst:
 
-:ref:`Function Instances <syntax-funcinst>` :math:`\{\FITYPE~\functype, \FIMODULE~\moduleinst, \FICODE~\func\}`
+:ref:`Function Instances <syntax-funcinst>` :math:`\{\FITYPE~\typeaddr, \FIMODULE~\moduleinst, \FICODE~\func\}`
 .......................................................................................................................
 
-* The :ref:`function type <syntax-functype>` :math:`\functype` must be :ref:`valid <valid-functype>` under an empty :ref:`context <context>`.
-
 * The :ref:`module instance <syntax-moduleinst>` :math:`\moduleinst` must be :ref:`valid <valid-moduleinst>` with some :ref:`context <context>` :math:`C`.
 
 * Under :ref:`context <context>` :math:`C`:
 
-  * The :ref:`function <syntax-func>` :math:`\func` must be :ref:`valid <valid-func>` with some :ref:`function type <syntax-functype>` :math:`\functype'`.
+  * The :ref:`function <syntax-func>` :math:`\func` must be :ref:`valid <valid-func>` with :ref:`static <syntax-type-stat>` :ref:`type identifier <syntax-typeid>` :math:`\typeidx`.
 
-  * The :ref:`function type <syntax-functype>` :math:`\functype'` must :ref:`match <match-functype>` :math:`\functype`.
+  * The :ref:`static <syntax-type-stat>` :ref:`heap type <syntax-heaptype>` :math:`\typeidx` must :ref:`match <match-heaptype>` the :ref:`dynamic <syntax-type-dyn>` :ref:`heap type <syntax-heaptype>` :math:`\typeaddr`.
 
-* Then the function instance is valid with :ref:`function type <syntax-functype>` :math:`\functype`.
+* Then the function instance is valid with :ref:`type address <syntax-typeaddr>` :math:`\typeaddr`.
 
 .. math::
    \frac{
      \begin{array}{@{}c@{}}
-     \vdashfunctype \functype \ok
-     \qquad
      S \vdashmoduleinst \moduleinst : C
      \\
-     C \vdashfunc \func : \functype'
+     C \vdashfunc \func : \typeidx
      \qquad
-     C \vdashfunctypematch \functype' \matchesfunctype \functype
+     C; S \vdashheaptypematch \typeidx \matchesheaptype \typeaddr
      \end{array}
    }{
-     S \vdashfuncinst \{\FITYPE~\functype, \FIMODULE~\moduleinst, \FICODE~\func\} : \functype
+     S \vdashfuncinst \{\FITYPE~\typeaddr, \FIMODULE~\moduleinst, \FICODE~\func\} : \typeaddr
    }
 
 
 .. index:: function type, function instance, host function
 .. _valid-hostfuncinst:
 
-:ref:`Host Function Instances <syntax-funcinst>` :math:`\{\FITYPE~\functype, \FIHOSTCODE~\X{hf}\}`
+:ref:`Host Function Instances <syntax-funcinst>` :math:`\{\FITYPE~\typeaddr, \FIHOSTCODE~\X{hf}\}`
 ..................................................................................................
 
-* The :ref:`function type <syntax-functype>` :math:`\functype` must be :ref:`valid <valid-functype>` under an empty :ref:`context <context>`.
+* The :ref:`type instance <syntax-typeinst>` :math:`S.\STYPES[\typeaddr]` must exist.
 
-* Let :math:`[t_1^\ast] \toF [t_2^\ast]` be the :ref:`function type <syntax-functype>` :math:`\functype`.
+* Let the :ref:`dynamic <syntax-type-dyn>` :ref:`function type <syntax-functype>` :math:`[t_1^\ast] \toF [t_2^\ast]` be the :ref:`type instance <syntax-typeinst>` :math:`S.\STYPES[\typeaddr]`.
 
 * For every :ref:`valid <valid-store>` :ref:`store <syntax-store>` :math:`S_1` :ref:`extending <extend-store>` :math:`S` and every sequence :math:`\val^\ast` of :ref:`values <syntax-val>` whose :ref:`types <valid-val>` coincide with :math:`t_1^\ast`:
 
@@ -182,12 +203,12 @@ Module instances are classified by *module contexts*, which are regular :ref:`co
 
     * Or :math:`R` consists of a :ref:`valid <valid-store>` :ref:`store <syntax-store>` :math:`S_2` :ref:`extending <extend-store>` :math:`S_1` and a :ref:`result <syntax-result>` :math:`\result` whose :ref:`type <valid-result>` coincides with :math:`[t_2^\ast]`.
 
-* Then the function instance is valid with :ref:`function type <syntax-functype>` :math:`\functype`.
+* Then the function instance is valid with :ref:`type address <syntax-typeaddr>` :math:`\typeaddr`.
 
 .. math::
    \frac{
      \begin{array}[b]{@{}l@{}}
-     \vdashfunctype [t_1^\ast] \toF [t_2^\ast] \ok \\
+     S.\STYPES[\typeaddr] = [t_1^\ast] \toF [t_2^\ast] \\
      \end{array}
      \quad
      \begin{array}[b]{@{}l@{}}
@@ -206,7 +227,7 @@ Module instances are classified by *module contexts*, which are regular :ref:`co
        R = (S_2; \result)
      \end{array}
    }{
-     S \vdashfuncinst \{\FITYPE~[t_1^\ast] \to [t_2^\ast], \FIHOSTCODE~\X{hf}\} : [t_1^\ast] \to [t_2^\ast]
+     S \vdashfuncinst \{\FITYPE~\typeaddr, \FIHOSTCODE~\X{hf}\} : \typeaddr
    }
 
 .. note::
@@ -223,7 +244,7 @@ Module instances are classified by *module contexts*, which are regular :ref:`co
 :ref:`Table Instances <syntax-tableinst>` :math:`\{ \TITYPE~(\limits~t), \TIELEM~\reff^\ast \}`
 ...............................................................................................
 
-* The :ref:`table type <syntax-tabletype>` :math:`\limits~t` must be :ref:`valid <valid-tabletype>` under the empty :ref:`context <context>`.
+* The :ref:`dynamic <syntax-type-dyn>` :ref:`table type <syntax-tabletype>` :math:`\limits~t` must be :ref:`valid <valid-tabletype>`.
 
 * The length of :math:`\reff^\ast` must equal :math:`\limits.\LMIN`.
 
@@ -237,13 +258,13 @@ Module instances are classified by *module contexts*, which are regular :ref:`co
 
 .. math::
    \frac{
-     \vdashtabletype \limits~t \ok
+     S \vdashtabletype \limits~t \ok
      \qquad
      n = \limits.\LMIN
      \qquad
      (S \vdash \reff : t')^n
      \qquad
-     (\vdashreftypematch t' \matchesvaltype t)^n
+     (S \vdashreftypematch t' \matchesvaltype t)^n
    }{
      S \vdashtableinst \{ \TITYPE~(\limits~t), \TIELEM~\reff^n \} : \limits~t
    }
@@ -255,7 +276,7 @@ Module instances are classified by *module contexts*, which are regular :ref:`co
 :ref:`Memory Instances <syntax-meminst>` :math:`\{ \MITYPE~\limits, \MIDATA~b^\ast \}`
 ......................................................................................
 
-* The :ref:`memory type <syntax-memtype>` :math:`\limits` must be :ref:`valid <valid-memtype>` under the empty :ref:`context <context>`.
+* The :ref:`dynamic <syntax-type-dyn>` :ref:`memory type <syntax-memtype>` :math:`\limits` must be :ref:`valid <valid-memtype>`.
 
 * The length of :math:`b^\ast` must equal :math:`\limits.\LMIN` multiplied by the :ref:`page size <page-size>` :math:`64\,\F{Ki}`.
 
@@ -263,7 +284,7 @@ Module instances are classified by *module contexts*, which are regular :ref:`co
 
 .. math::
    \frac{
-     \vdashmemtype \limits \ok
+     S \vdashmemtype \limits \ok
      \qquad
      n = \limits.\LMIN \cdot 64\,\F{Ki}
    }{
@@ -277,7 +298,7 @@ Module instances are classified by *module contexts*, which are regular :ref:`co
 :ref:`Global Instances <syntax-globalinst>` :math:`\{ \GITYPE~(\mut~t), \GIVALUE~\val \}`
 .........................................................................................
 
-* The :ref:`global type <syntax-globaltype>` :math:`\mut~t` must be :ref:`valid <valid-globaltype>` under the empty :ref:`context <context>`.
+* The :ref:`dynamic <syntax-type-dyn>` :ref:`global type <syntax-globaltype>` :math:`\mut~t` must be :ref:`valid <valid-globaltype>`.
 
 * The :ref:`value <syntax-val>` :math:`\val` must be :ref:`valid <valid-val>` with some :ref:`value type <syntax-valtype>` :math:`t'`.
 
@@ -287,11 +308,11 @@ Module instances are classified by *module contexts*, which are regular :ref:`co
 
 .. math::
    \frac{
-     \vdashglobaltype \mut~t \ok
+     S \vdashglobaltype \mut~t \ok
      \qquad
      S \vdashval \val : t'
      \qquad
-     \vdashvaltypematch t' \matchesvaltype t
+     S \vdashvaltypematch t' \matchesvaltype t
    }{
      S \vdashglobalinst \{ \GITYPE~(\mut~t), \GIVALUE~\val \} : \mut~t
    }
@@ -303,7 +324,7 @@ Module instances are classified by *module contexts*, which are regular :ref:`co
 :ref:`Element Instances <syntax-eleminst>` :math:`\{ \EIELEM~\X{fa}^\ast \}`
 ............................................................................
 
-* The :ref:`reference type <syntax-reftype>` :math:`t` must be :ref:`valid <valid-reftype>` under the empty :ref:`context <context>`.
+* The :ref:`dynamic <syntax-type-dyn>` :ref:`reference type <syntax-reftype>` :math:`t` must be :ref:`valid <valid-reftype>`.
 
 * For each :ref:`reference <syntax-ref>` :math:`\reff_i` in the elements :math:`\reff^n`:
 
@@ -315,11 +336,11 @@ Module instances are classified by *module contexts*, which are regular :ref:`co
 
 .. math::
    \frac{
-     \vdashreftype t \ok
+     S \vdashreftype t \ok
      \qquad
      (S \vdash \reff : t')^\ast
      \qquad
-     (\vdashreftypematch t' \matchesvaltype t)^\ast
+     (S \vdashreftypematch t' \matchesvaltype t)^\ast
    }{
      S \vdasheleminst \{ \EITYPE~t, \EIELEM~\reff^\ast \} : t
    }
@@ -364,9 +385,9 @@ Module instances are classified by *module contexts*, which are regular :ref:`co
 :ref:`Module Instances <syntax-moduleinst>` :math:`\moduleinst`
 ...............................................................
 
-* Each :ref:`defined type <syntax-deftype>` :math:`\deftype_i` in :math:`\moduleinst.\MITYPES` must be :ref:`valid <valid-deftype>`.
+* For each :ref:`type address <syntax-typeaddr>` :math:`\typeaddr_i` in :math:`\moduleinst.\MITYPES`, the :ref:`type instance <syntax-typeinst>` :math:`\typeinst_i` at :math:`S.\STYPES[\typeaddr_i]` must be :ref:`valid <valid-typeinst>`.
 
-* For each :ref:`function address <syntax-funcaddr>` :math:`\funcaddr_i` in :math:`\moduleinst.\MIFUNCS`, the :ref:`external value <syntax-externval>` :math:`\EVFUNC~\funcaddr_i` must be :ref:`valid <valid-externval-func>` with some :ref:`external type <syntax-externtype>` :math:`\ETFUNC~\functype_i`.
+* For each :ref:`function address <syntax-funcaddr>` :math:`\funcaddr_i` in :math:`\moduleinst.\MIFUNCS`, the :ref:`external value <syntax-externval>` :math:`\EVFUNC~\funcaddr_i` must be :ref:`valid <valid-externval-func>` with some :ref:`external type <syntax-externtype>` :math:`\ETFUNC~\typeaddr'_i`.
 
 * For each :ref:`table address <syntax-tableaddr>` :math:`\tableaddr_i` in :math:`\moduleinst.\MITABLES`, the :ref:`external value <syntax-externval>` :math:`\EVTABLE~\tableaddr_i` must be :ref:`valid <valid-externval-table>` with some :ref:`external type <syntax-externtype>` :math:`\ETTABLE~\tabletype_i`.
 
@@ -382,9 +403,9 @@ Module instances are classified by *module contexts*, which are regular :ref:`co
 
 * For each :ref:`export instance <syntax-exportinst>` :math:`\exportinst_i` in :math:`\moduleinst.\MIEXPORTS`, the :ref:`name <syntax-name>` :math:`\exportinst_i.\EINAME` must be different from any other name occurring in :math:`\moduleinst.\MIEXPORTS`.
 
-* Let :math:`\deftype^\ast` be the concatenation of all :math:`\deftype_i` in order.
+* Let :math:`\typeinst^\ast` be the concatenation of all :math:`\typeinst_i` in order.
 
-* Let :math:`\functype^\ast` be the concatenation of all :math:`\functype_i` in order.
+* Let :math:`\typeaddr'^\ast` be the concatenation of all :math:`\typeaddr'_i` in order.
 
 * Let :math:`\tabletype^\ast` be the concatenation of all :math:`\tabletype_i` in order.
 
@@ -397,15 +418,15 @@ Module instances are classified by *module contexts*, which are regular :ref:`co
 * Let :math:`n` be the length of :math:`\moduleinst.\MIDATAS`.
 
 * Then the module instance is valid with :ref:`context <context>`
-  :math:`\{\CTYPES~\deftype^\ast,` :math:`\CFUNCS~\functype^\ast,` :math:`\CTABLES~\tabletype^\ast,` :math:`\CMEMS~\memtype^\ast,` :math:`\CGLOBALS~\globaltype^\ast,` :math:`\CELEMS~\reftype^\ast,` :math:`\CDATAS~{\ok}^n\}`.
+  :math:`\{\CTYPES~\typeinst^\ast,` :math:`\CFUNCS~{\typeaddr'}^\ast,` :math:`\CTABLES~\tabletype^\ast,` :math:`\CMEMS~\memtype^\ast,` :math:`\CGLOBALS~\globaltype^\ast,` :math:`\CELEMS~\reftype^\ast,` :math:`\CDATAS~{\ok}^n\}`.
 
 .. math::
    ~\\[-1ex]
    \frac{
      \begin{array}{@{}c@{}}
-     (\vdashdeftype \deftype \ok)^\ast
+     (S \vdashtypeinst S.\STYPES[\typeaddr] \ok)^\ast
      \\
-     (S \vdashexternval \EVFUNC~\funcaddr : \ETFUNC~\functype)^\ast
+     (S \vdashexternval \EVFUNC~\funcaddr : \ETFUNC~\typeaddr')^\ast
      \qquad
      (S \vdashexternval \EVTABLE~\tableaddr : \ETTABLE~\tabletype)^\ast
      \\
@@ -424,7 +445,7 @@ Module instances are classified by *module contexts*, which are regular :ref:`co
    }{
      S \vdashmoduleinst \{
        \begin{array}[t]{@{}l@{~}l@{}}
-       \MITYPES & \deftype^\ast, \\
+       \MITYPES & \typeaddr^\ast, \\
        \MIFUNCS & \funcaddr^\ast, \\
        \MITABLES & \tableaddr^\ast, \\
        \MIMEMS & \memaddr^\ast, \\
@@ -433,8 +454,8 @@ Module instances are classified by *module contexts*, which are regular :ref:`co
        \MIDATAS & \dataaddr^n, \\
        \MIEXPORTS & \exportinst^\ast ~\} : \{
          \begin{array}[t]{@{}l@{~}l@{}}
-         \CTYPES & \deftype^\ast, \\
-         \CFUNCS & \functype^\ast, \\
+         \CTYPES & S.\STYPES[\typeaddr]^\ast, \\
+         \CFUNCS & {\typeaddr'}^\ast, \\
          \CTABLES & \tabletype^\ast, \\
          \CMEMS & \memtype^\ast, \\
          \CGLOBALS & \globaltype^\ast, \\
@@ -444,6 +465,9 @@ Module instances are classified by *module contexts*, which are regular :ref:`co
        \end{array}
    }
 
+.. note::
+   The context derived for a module instance consists of :ref:`dynamic types <syntax-type-dyn>`.
+
 
 .. scratch
   .. index:: context, store, frame
@@ -562,7 +586,7 @@ Finally, :ref:`frames <syntax-frame>` are classified with *frame contexts*, whic
 :ref:`Frames <syntax-frame>` :math:`\{\ALOCALS~\val^\ast, \AMODULE~\moduleinst\}`
 .................................................................................
 
-* The :ref:`module instance <syntax-moduleinst>` :math:`\moduleinst` must be :ref:`valid <valid-moduleinst>` with some :ref:`module context <module-context>` :math:`C`.
+* The :ref:`module instance <syntax-moduleinst>` :math:`\moduleinst` must be :ref:`valid <valid-moduleinst>` with some :ref:`dynamic <syntax-type-dyn>` :ref:`module context <module-context>` :math:`C`.
 
 * Each :ref:`value <syntax-val>` :math:`\val_i` in :math:`\val^\ast` must be :ref:`valid <valid-val>` with some :ref:`value type <syntax-valtype>` :math:`t_i`.
 
@@ -599,11 +623,11 @@ To that end, all previous typing judgements :math:`C \vdash \X{prop}` are genera
 :math:`\TRAP`
 .............
 
-* The instruction is valid with any :ref:`valid <valid-instrtype>` :ref:`instruction type <syntax-instrtype>` of the form :math:`[t_1^\ast] \to [t_2^\ast]`.
+* The instruction is valid with any :ref:`valid <valid-instrtype>` :ref:`dynamic <syntax-type-dyn>` :ref:`instruction type <syntax-instrtype>` of the form :math:`[t_1^\ast] \to [t_2^\ast]`.
 
 .. math::
    \frac{
-     C \vdashinstrtype [t_1^\ast] \to [t_2^\ast] \ok
+     S; C \vdashinstrtype [t_1^\ast] \to [t_2^\ast] \ok
    }{
      S; C \vdashadmininstr \TRAP : [t_1^\ast] \to [t_2^\ast]
    }
@@ -628,32 +652,41 @@ To that end, all previous typing judgements :math:`C \vdash \X{prop}` are genera
 :math:`\REFFUNCADDR~\funcaddr`
 ..............................
 
-* The :ref:`external function value <syntax-externval>` :math:`\EVFUNC~\funcaddr` must be :ref:`valid <valid-externval>` with :ref:`external function type <syntax-externtype>` :math:`\ETFUNC~\functype`.
+* The :ref:`external function value <syntax-externval>` :math:`\EVFUNC~\funcaddr` must be :ref:`valid <valid-externval>` with :ref:`dynamic <syntax-type-dyn>` :ref:`external function type <syntax-externtype>` :math:`\ETFUNC~a'`.
 
-* Then the instruction is valid with type :math:`[] \to [(\REF~\functype)]`.
+* Then the instruction is valid with type :math:`[] \to [(\REF~a')]`.
 
 .. math::
    \frac{
-     S \vdashexternval \EVFUNC~a : \ETFUNC~\functype
+     S \vdashexternval \EVFUNC~a : \ETFUNC~a'
    }{
-     S; C \vdashadmininstr \REFFUNCADDR~a : [] \to [(\REF~\functype)]
+     S; C \vdashadmininstr \REFFUNCADDR~a : [] \to [(\REF~a')]
    }
 
+.. note::
+   This typing rule yields a :ref:`dynamic <syntax-type-dyn>` type.
+   The function may originate from outside the current module,
+   so that a definition for its type may not exist in context :math:`C`.
+
 
 .. index:: function address, extern value, extern type, function type
 
 :math:`\INVOKE~\funcaddr`
 .........................
 
-* The :ref:`external function value <syntax-externval>` :math:`\EVFUNC~\funcaddr` must be :ref:`valid <valid-externval-func>` with :ref:`external function type <syntax-externtype>` :math:`\ETFUNC \functype'`.
+* The :ref:`external function value <syntax-externval>` :math:`\EVFUNC~\funcaddr` must be :ref:`valid <valid-externval-func>` with :ref:`external function type <syntax-externtype>` :math:`\ETFUNC a'`.
+
+* Assert: The :ref:`type address <syntax-typeaddr>` :math:`S.\STYPES[a']` is defined in the store.
 
-* Let :math:`[t_1^\ast] \toF [t_2^\ast])` be the :ref:`function type <syntax-functype>` :math:`\functype`.
+* Let :math:`[t_1^\ast] \toF [t_2^\ast])` be the :ref:`function type <syntax-functype>` :math:`S.\STYPES[a']`.
 
 * Then the instruction is valid with type :math:`[t_1^\ast] \to [t_2^\ast]`.
 
 .. math::
    \frac{
-     S \vdashexternval \EVFUNC~\funcaddr : \ETFUNC~[t_1^\ast] \toF [t_2^\ast]
+     S \vdashexternval \EVFUNC~\funcaddr : \ETFUNC~a'
+     \qquad
+     S.\STYPES[a'] = [t_1^\ast] \toF [t_2^\ast]
    }{
      S; C \vdashadmininstr \INVOKE~\funcaddr : [t_1^\ast] \to [t_2^\ast]
    }
@@ -688,20 +721,25 @@ To that end, all previous typing judgements :math:`C \vdash \X{prop}` are genera
 :math:`\FRAME_n\{F\}~\instr^\ast~\END`
 ...........................................
 
-* Under the :ref:`valid <valid-resulttype>` return type :math:`[t^n]`,
+* Under the :ref:`valid <valid-resulttype>` :ref:`dynamic <syntax-type-dyn>` return type :math:`[t^n]`,
   the :ref:`thread <syntax-frame>` :math:`F; \instr^\ast` must be :ref:`valid <valid-frame>` with :ref:`result type <syntax-resulttype>` :math:`[t^n]`.
 
 * Then the compound instruction is valid with type :math:`[] \to [t^n]`.
 
 .. math::
    \frac{
-     C \vdashresulttype [t^n] \ok
+     S \vdashresulttype [t^n] \ok
      \qquad
      S; [t^n] \vdashinstrseq F; \instr^\ast : [t^n]
    }{
      S; C \vdashadmininstr \FRAME_n\{F\}~\instr^\ast~\END : [] \to [t^n]
    }
 
+.. note::
+   This typing rule yields a :ref:`dynamic <syntax-type-dyn>` type.
+   The frame's function may originate from outside the current module,
+   so that the :math:`t^n` may reference type definitions that do not exist in context :math:`C`.
+
 
 .. index:: ! store extension, store
 .. _extend:
@@ -728,6 +766,8 @@ a store state :math:`S'` extends state :math:`S`, written :math:`S \extendsto S'
 :ref:`Store <syntax-store>` :math:`S`
 .....................................
 
+* The length of :math:`S.\STYPES` must not shrink.
+
 * The length of :math:`S.\SFUNCS` must not shrink.
 
 * The length of :math:`S.\STABLES` must not shrink.
@@ -740,6 +780,8 @@ a store state :math:`S'` extends state :math:`S`, written :math:`S \extendsto S'
 
 * The length of :math:`S.\SDATAS` must not shrink.
 
+* For each :ref:`type instance <syntax-typeinst>` :math:`\typeinst_i` in the original :math:`S.\STYPES`, the new type instance must be an :ref:`extension <extend-typeinst>` of the old.
+
 * For each :ref:`function instance <syntax-funcinst>` :math:`\funcinst_i` in the original :math:`S.\SFUNCS`, the new function instance must be an :ref:`extension <extend-funcinst>` of the old.
 
 * For each :ref:`table instance <syntax-tableinst>` :math:`\tableinst_i` in the original :math:`S.\STABLES`, the new table instance must be an :ref:`extension <extend-tableinst>` of the old.
@@ -755,6 +797,9 @@ a store state :math:`S'` extends state :math:`S`, written :math:`S \extendsto S'
 .. math::
    \frac{
      \begin{array}{@{}ccc@{}}
+     S_1.\STYPES = \typeinst_1^\ast &
+     S_2.\STYPES = {\typeinst'_1}^\ast~\typeinst_2^\ast &
+     (\vdashtypeinstextends \typeinst_1 \extendsto \typeinst'_1)^\ast \\
      S_1.\SFUNCS = \funcinst_1^\ast &
      S_2.\SFUNCS = {\funcinst'_1}^\ast~\funcinst_2^\ast &
      (\vdashfuncinstextends \funcinst_1 \extendsto \funcinst'_1)^\ast \\
@@ -779,6 +824,21 @@ a store state :math:`S'` extends state :math:`S`, written :math:`S \extendsto S'
    }
 
 
+.. index:: type instance
+.. _extend-typeinst:
+
+:ref:`Type Instance <syntax-typeinst>` :math:`\typeinst`
+........................................................
+
+* A type instance must remain unchanged.
+
+.. math::
+   \frac{
+   }{
+     \vdashtypeinstextends \typeinst \extendsto \typeinst
+   }
+
+
 .. index:: function instance
 .. _extend-funcinst:
 
diff --git a/document/core/conf.py b/document/core/conf.py
index 2ae32adc..19f4368f 100644
--- a/document/core/conf.py
+++ b/document/core/conf.py
@@ -66,10 +66,10 @@ editor = u'Andreas Rossberg (editor)'
 logo = 'static/webassembly.png'
 
 # The name of the GitHub repository this resides in
-repo = 'function-references'
+repo = 'continuations'
 
 # The name of the proposal it represents, if any
-proposal = 'tail calls + function references'
+proposal = 'function-references + tail-calls + continuations'
 
 # The draft version string (clear out for release cuts)
 draft = ' (Draft ' + date.today().strftime("%Y-%m-%d") + ')'
diff --git a/document/core/exec/instructions.rst b/document/core/exec/instructions.rst
index 558e6e9f..f5154fd5 100644
--- a/document/core/exec/instructions.rst
+++ b/document/core/exec/instructions.rst
@@ -409,7 +409,7 @@ Most vector instructions are defined in terms of generic numeric operators appli
 
 5. Let :math:`j^\ast` be the sequence :math:`\lanes_{i8x16}(c_1)`.
 
-6. Let :math:`c^\ast` be the concatenation of the two sequences :math:`j^\ast~0^{240}`.
+6. Let :math:`c^\ast` be the concatenation of the two sequences :math:`j^\ast~0^{240}`
 
 7. Let :math:`c'` be the result of :math:`\lanes^{-1}_{i8x16}(c^\ast[ i^\ast[0] ] \dots c^\ast[ i^\ast[15] ])`.
 
@@ -542,7 +542,7 @@ Most vector instructions are defined in terms of generic numeric operators appli
 
 7. Let :math:`i^\ast` be the sequence :math:`\lanes_{\shape}(c_2)`.
 
-8. Let :math:`c` be the result of computing :math:`\lanes^{-1}_{\shape}(i^\ast \with [x] = c_1)`.
+8. Let :math:`c` be the result of computing :math:`\lanes^{-1}_{\shape}(i^\ast \with [x] = c_1)`
 
 9. Push :math:`\V128.\VCONST~c` on the stack.
 
@@ -682,7 +682,7 @@ Most vector instructions are defined in terms of generic numeric operators appli
 
 2. Pop the value :math:`\V128.\VCONST~c_1` from the stack.
 
-3. Let :math:`i_1^\ast` be the sequence :math:`\lanes_{\shape}(c_1)`.
+3. Let :math:`i_1^\ast` be the sequence :math:`\lanes_{\shape}(c_1)`
 
 4. Let :math:`i` be the result of computing :math:`\bool(\bigwedge(i_1 \neq 0)^\ast)`.
 
@@ -775,7 +775,7 @@ Most vector instructions are defined in terms of generic numeric operators appli
 
 3. Let :math:`i^\ast` be the sequence :math:`\lanes_{t_1\K{x}M}(c_1)`.
 
-4. Let :math:`c` be the result of computing :math:`\lanes^{-1}_{t_2\K{x}N}(\vcvtop^{\sx}_{|t_1|,|t_2|}(i^\ast))`.
+4. Let :math:`c` be the result of computing :math:`\lanes^{-1}_{t_2\K{x}N}(\vcvtop^{\sx}_{|t_1|,|t_2|}(i^\ast))`
 
 5. Push the value :math:`\V128.\VCONST~c` onto the stack.
 
@@ -870,7 +870,7 @@ where:
 
 3. Pop the value :math:`\V128.\VCONST~c_1` from the stack.
 
-4. Let :math:`(i_1~i_2)^\ast` be the result of computing :math:`\imul_{32}(\extends_{16,32}(\lanes_{\I16X8}(c_1)), \extends_{16,32}(\lanes_{\I16X8}(c_2)))`.
+4. Let :math:`(i_1~i_2)^\ast` be the result of computing :math:`\imul_{32}(\extends_{16,32}(\lanes_{\I16X8}(c_1)), \extends_{16,32}(\lanes_{\I16X8}(c_2)))`
 
 5. Let :math:`j^\ast` be the result of computing :math:`\iadd_{32}(i_1, i_2)^\ast`.
 
@@ -915,7 +915,7 @@ where:
 
    b. Let :math:`j^\ast` be the sequence :math:`\lanes_{t_1\K{x}M}(c_2)[N \slice N]`.
 
-6. Let :math:`c` be the result of computing :math:`\lanes^{-1}_{t_2\K{x}N}(\imul_{t_2\K{x}N}(\extend^{\sx}_{|t_1|,|t_2|}(i^\ast), \extend^{\sx}_{|t_1|,|t_2|}(j^\ast)))`.
+6. Let :math:`c` be the result of computing :math:`\lanes^{-1}_{t_2\K{x}N}(\imul_{t_2\K{x}N}(\extend^{\sx}_{|t_1|,|t_2|}(i^\ast), \extend^{\sx}_{|t_1|,|t_2|}(j^\ast)))`
 
 7. Push the value :math:`\V128.\VCONST~c` onto the stack.
 
@@ -952,7 +952,7 @@ where:
 
 4. Let :math:`j^\ast` be the result of computing :math:`\iadd_{N}(i_1, i_2)^\ast`.
 
-5. Let :math:`c` be the result of computing :math:`\lanes^{-1}_{t_2\K{x}N}(j^\ast)`.
+5. Let `c` be the result of computing :math:`\lanes^{-1}_{t_2\K{x}N}(j^\ast)`.
 
 6. Push the value :math:`\V128.\VCONST~c` to the stack.
 
@@ -2561,19 +2561,17 @@ Control Instructions
 :math:`\BLOCK~\blocktype~\instr^\ast~\END`
 ..........................................
 
-1. Let :math:`F` be the :ref:`current <exec-notation-textual>` :ref:`frame <syntax-frame>`.
-
-2. Assert: due to :ref:`validation <valid-blocktype>`, :math:`\expand_{S;F}(\blocktype)` is defined.
+1. Assert: due to :ref:`validation <valid-blocktype>`, :math:`\expand_{S;F}(\blocktype)` is defined.
 
-3. Let :math:`[t_1^m] \to [t_2^n]` be the :ref:`instruction type <syntax-instrtype>` :math:`\expand_{S;F}(\blocktype)`.
+2. Let :math:`[t_1^m] \to [t_2^n]` be the :ref:`instruction type <syntax-instrtype>` :math:`\expand_{S;F}(\blocktype)`.
 
-4. Let :math:`L` be the label whose arity is :math:`n` and whose continuation is the end of the block.
+3. Let :math:`L` be the label whose arity is :math:`n` and whose continuation is the end of the block.
 
-5. Assert: due to :ref:`validation <valid-block>`, there are at least :math:`m` values on the top of the stack.
+4. Assert: due to :ref:`validation <valid-block>`, there are at least :math:`m` values on the top of the stack.
 
-6. Pop the values :math:`\val^m` from the stack.
+5. Pop the values :math:`\val^m` from the stack.
 
-7. :ref:`Enter <exec-instr-seq-enter>` the block :math:`\val^m~\instr^\ast` with label :math:`L`.
+6. :ref:`Enter <exec-instr-seq-enter>` the block :math:`\val^m~\instr^\ast` with label :math:`L`.
 
 .. math::
    ~\\[-1ex]
@@ -2589,19 +2587,17 @@ Control Instructions
 :math:`\LOOP~\blocktype~\instr^\ast~\END`
 .........................................
 
-1. Let :math:`F` be the :ref:`current <exec-notation-textual>` :ref:`frame <syntax-frame>`.
-
-2. Assert: due to :ref:`validation <valid-blocktype>`, :math:`\expand_{S;F}(\blocktype)` is defined.
+1. Assert: due to :ref:`validation <valid-blocktype>`, :math:`\expand_{S;F}(\blocktype)` is defined.
 
-3. Let :math:`[t_1^m] \to [t_2^n]` be the :ref:`instruction type <syntax-instrtype>` :math:`\expand_{S;F}(\blocktype)`.
+2. Let :math:`[t_1^m] \to [t_2^n]` be the :ref:`instruction type <syntax-instrtype>` :math:`\expand_{S;F}(\blocktype)`.
 
-4. Let :math:`L` be the label whose arity is :math:`m` and whose continuation is the start of the loop.
+3. Let :math:`L` be the label whose arity is :math:`m` and whose continuation is the start of the loop.
 
-5. Assert: due to :ref:`validation <valid-loop>`, there are at least :math:`m` values on the top of the stack.
+4. Assert: due to :ref:`validation <valid-loop>`, there are at least :math:`m` values on the top of the stack.
 
-6. Pop the values :math:`\val^m` from the stack.
+5. Pop the values :math:`\val^m` from the stack.
 
-7. :ref:`Enter <exec-instr-seq-enter>` the block :math:`\val^m~\instr^\ast` with label :math:`L`.
+6. :ref:`Enter <exec-instr-seq-enter>` the block :math:`\val^m~\instr^\ast` with label :math:`L`.
 
 .. math::
    ~\\[-1ex]
@@ -2632,11 +2628,11 @@ Control Instructions
 .. math::
    ~\\[-1ex]
    \begin{array}{lcl}
-   (\I32.\CONST~c)~\IF~\X{bt}~\instr_1^\ast~\ELSE~\instr_2^\ast~\END &\stepto&
-     \BLOCK~\X{bt}~\instr_1^\ast~\END
+   F; (\I32.\CONST~c)~\IF~\X{bt}~\instr_1^\ast~\ELSE~\instr_2^\ast~\END &\stepto&
+     F; \BLOCK~\X{bt}~\instr_1^\ast~\END
      \\&&\quad (\iff c \neq 0) \\
-   (\I32.\CONST~c)~\IF~\X{bt}~\instr_1^\ast~\ELSE~\instr_2^\ast~\END &\stepto&
-     \BLOCK~\X{bt}~\instr_2^\ast~\END
+   F; (\I32.\CONST~c)~\IF~\X{bt}~\instr_1^\ast~\ELSE~\instr_2^\ast~\END &\stepto&
+     F; \BLOCK~\X{bt}~\instr_2^\ast~\END
      \\&&\quad (\iff c = 0) \\
    \end{array}
 
@@ -2884,37 +2880,41 @@ Control Instructions
 
 6. Assert: due to :ref:`validation <valid-call_indirect>`, :math:`F.\AMODULE.\MITYPES[y]` exists.
 
-7. Let :math:`\X{ft}_{\F{expect}}` be the :ref:`function type <syntax-functype>` :math:`F.\AMODULE.\MITYPES[y]`.
+7. Let :math:`\X{ta}_{\F{expect}}` be the :ref:`type address <syntax-typeaddr>` :math:`F.\AMODULE.\MITYPES[y]`.
 
-8. Assert: due to :ref:`validation <valid-call_indirect>`, a value with :ref:`value type <syntax-valtype>` |I32| is on the top of the stack.
+8. Let :math:`\X{ft}_{\F{expect}}` be the :ref:`function type <syntax-functype>` :math:`S.\STYPES[\X{ta}_{\F{expect}}]`.
 
-9. Pop the value :math:`\I32.\CONST~i` from the stack.
+9. Assert: due to :ref:`validation <valid-call_indirect>`, a value with :ref:`value type <syntax-valtype>` |I32| is on the top of the stack.
 
-10. If :math:`i` is not smaller than the length of :math:`\X{tab}.\TIELEM`, then:
+10. Pop the value :math:`\I32.\CONST~i` from the stack.
+
+11. If :math:`i` is not smaller than the length of :math:`\X{tab}.\TIELEM`, then:
 
     a. Trap.
 
-11. Let :math:`r` be the :ref:`reference <syntax-ref>` :math:`\X{tab}.\TIELEM[i]`.
+12. Let :math:`r` be the :ref:`reference <syntax-ref>` :math:`\X{tab}.\TIELEM[i]`.
 
-12. If :math:`r` is :math:`\REFNULL~\X{ht}`, then:
+13. If :math:`r` is :math:`\REFNULL~\X{ht}`, then:
 
     a. Trap.
 
-13. Assert: due to :ref:`validation of table mutation <valid-table.set>`, :math:`r` is a :ref:`function reference <syntax-ref.func>`.
+14. Assert: due to :ref:`validation of table mutation <valid-table.set>`, :math:`r` is a :ref:`function reference <syntax-ref.func>`.
 
-14. Let :math:`\REFFUNCADDR~a` be the :ref:`function reference <syntax-ref.func>` :math:`r`.
+15. Let :math:`\REFFUNCADDR~a` be the :ref:`function reference <syntax-ref.func>` :math:`r`.
 
-15. Assert: due to :ref:`validation of table mutation <valid-table.set>`, :math:`S.\SFUNCS[a]` exists.
+16. Assert: due to :ref:`validation of table mutation <valid-table.set>`, :math:`S.\SFUNCS[a]` exists.
 
-16. Let :math:`\X{f}` be the :ref:`function instance <syntax-funcinst>` :math:`S.\SFUNCS[a]`.
+17. Let :math:`\X{f}` be the :ref:`function instance <syntax-funcinst>` :math:`S.\SFUNCS[a]`.
 
-17. Let :math:`\X{ft}_{\F{actual}}` be the :ref:`function type <syntax-functype>` :math:`\X{f}.\FITYPE`.
+18. Let :math:`\X{ta}_{\F{actual}}` be the :ref:`type address <syntax-typeaddr>` :math:`\X{f}.\FITYPE`.
 
-18. If :math:`\X{ft}_{\F{actual}}` and :math:`\X{ft}_{\F{expect}}` differ, then:
+19. Let :math:`\X{ft}_{\F{actual}}` be the :ref:`function type <syntax-functype>` :math:`S.\STYPES[\X{ta}_{\F{actual}}]`.
+
+20. If :math:`\X{ft}_{\F{actual}}` and :math:`\X{ft}_{\F{expect}}` differ, then:
 
     a. Trap.
 
-19. :ref:`Invoke <exec-invoke>` the function instance at address :math:`a`.
+21. :ref:`Invoke <exec-invoke>` the function instance at address :math:`a`.
 
 .. math::
    ~\\[-1ex]
@@ -2926,7 +2926,7 @@ Control Instructions
      \begin{array}[t]{@{}r@{~}l@{}}
      (\iff & S.\STABLES[F.\AMODULE.\MITABLES[x]].\TIELEM[i] = \REFFUNCADDR~a \\
      \wedge & S.\SFUNCS[a] = f \\
-     \wedge & S \vdashfunctypematch F.\AMODULE.\MITYPES[y] \matchesfunctype f.\FITYPE)
+     \wedge & S \vdashfunctypematch S.\STYPES[F.\AMODULE.\MITYPES[y]] \matchesfunctype S.\STYPES[f.\FITYPE])
      \end{array}
    \\[1ex]
    \begin{array}{lcl@{\qquad}l}
@@ -3114,23 +3114,25 @@ Invocation of :ref:`function address <syntax-funcaddr>` :math:`a`
 
 2. Let :math:`f` be the :ref:`function instance <syntax-funcinst>`, :math:`S.\SFUNCS[a]`.
 
-3. Let :math:`[t_1^n] \toF [t_2^m]` be the :ref:`function type <syntax-functype>` :math:`\X{f}.\FITYPE`.
+3. Let :math:`\X{ta}` be the :ref:`type address <syntax-typeaddr>` :math:`\X{f}.\FITYPE`.
+
+4. Let :math:`[t_1^n] \toF [t_2^m]` be the :ref:`function type <syntax-functype>` :math:`S.\STYPES[\X{ta}]`.
 
-4. Let :math:`\local^\ast` be the list of :ref:`locals <syntax-local>` :math:`f.\FICODE.\FLOCALS`.
+5. Let :math:`\local^\ast` be the list of :ref:`locals <syntax-local>` :math:`f.\FICODE.\FLOCALS`.
 
-5. Let :math:`\instr^\ast~\END` be the :ref:`expression <syntax-expr>` :math:`f.\FICODE.\FBODY`.
+6. Let :math:`\instr^\ast~\END` be the :ref:`expression <syntax-expr>` :math:`f.\FICODE.\FBODY`.
 
-6. Assert: due to :ref:`validation <valid-call>`, :math:`n` values are on the top of the stack.
+7. Assert: due to :ref:`validation <valid-call>`, :math:`n` values are on the top of the stack.
 
-7. Pop the values :math:`\val^n` from the stack.
+8. Pop the values :math:`\val^n` from the stack.
 
-8. Let :math:`F` be the :ref:`frame <syntax-frame>` :math:`\{ \AMODULE~f.\FIMODULE, \ALOCALS~\val^n~(\default_t)^\ast \}`.
+9. Let :math:`F` be the :ref:`frame <syntax-frame>` :math:`\{ \AMODULE~f.\FIMODULE, \ALOCALS~\val^n~(\default_t)^\ast \}`.
 
-9. Push the activation of :math:`F` with arity :math:`m` to the stack.
+10. Push the activation of :math:`F` with arity :math:`m` to the stack.
 
-10. Let :math:`L` be the :ref:`label <syntax-label>` whose arity is :math:`m` and whose continuation is the end of the function.
+11. Let :math:`L` be the :ref:`label <syntax-label>` whose arity is :math:`m` and whose continuation is the end of the function.
 
-11. :ref:`Enter <exec-instr-seq-enter>` the instruction sequence :math:`\instr^\ast` with label :math:`L`.
+12. :ref:`Enter <exec-instr-seq-enter>` the instruction sequence :math:`\instr^\ast` with label :math:`L`.
 
 .. math::
    ~\\[-1ex]
@@ -3141,7 +3143,7 @@ Invocation of :ref:`function address <syntax-funcaddr>` :math:`a`
    \\ \qquad
      \begin{array}[t]{@{}r@{~}l@{}}
      (\iff & S.\SFUNCS[a] = f \\
-     \wedge & S.f.\FITYPE = [t_1^n] \toF [t_2^m] \\
+     \wedge & S.\STYPES[f.\FITYPE] = [t_1^n] \toF [t_2^m] \\
      \wedge & f.\FICODE = \{ \FTYPE~x, \FLOCALS~\{\LTYPE~t\}^k, \FBODY~\instr^\ast~\END \} \\
      \wedge & F = \{ \AMODULE~f.\FIMODULE, ~\ALOCALS~\val^n~(\default_t)^k \})
      \end{array} \\
@@ -3240,7 +3242,8 @@ Furthermore, the resulting store must be :ref:`valid <valid-store>`, i.e., all d
    \end{array}
    \\ \qquad
      \begin{array}[t]{@{}r@{~}l@{}}
-     (\iff & S.\SFUNCS[a] = \{ \FITYPE~[t_1^n] \toF [t_2^m], \FIHOSTCODE~\X{hf} \} \\
+     (\iff & S.\SFUNCS[a] = \{ \FITYPE~\X{ta}, \FIHOSTCODE~\X{hf} \} \\
+     \wedge & S.\STYPES[\X{ta}] = [t_1^n] \toF [t_2^m] \\
      \wedge & (S'; \result) \in \X{hf}(S; \val^n)) \\
      \end{array} \\
    \begin{array}{lcl@{\qquad}l}
diff --git a/document/core/exec/modules.rst b/document/core/exec/modules.rst
index 1e7844e5..42cc0dd8 100644
--- a/document/core/exec/modules.rst
+++ b/document/core/exec/modules.rst
@@ -10,10 +10,34 @@ For modules, the execution semantics primarily defines :ref:`instantiation <exec
 Allocation
 ~~~~~~~~~~
 
-New instances of :ref:`functions <syntax-funcinst>`, :ref:`tables <syntax-tableinst>`, :ref:`memories <syntax-meminst>`, and :ref:`globals <syntax-globalinst>` are *allocated* in a :ref:`store <syntax-store>` :math:`S`, as defined by the following auxiliary functions.
+New instances of :ref:`types <syntax-typeinst>`, :ref:`functions <syntax-funcinst>`, :ref:`tables <syntax-tableinst>`, :ref:`memories <syntax-meminst>`, and :ref:`globals <syntax-globalinst>` are *allocated* in a :ref:`store <syntax-store>` :math:`S`, as defined by the following auxiliary functions.
 
 
-.. index:: function, function instance, function address, module instance, function type
+.. index:: type, type instance, type address, function type
+.. _alloc-type:
+
+:ref:`Types <syntax-typeinst>`
+..............................
+
+1. Let :math:`\functype` be the :ref:`dynamic type <syntax-type-dyn>`.
+
+2. Let :math:`a` be the first free :ref:`type address <syntax-typeaddr>` in :math:`S`.
+
+3. Append :math:`\typeinst` to the |STYPES| of :math:`S`.
+
+4. Return :math:`a`.
+
+.. math::
+   ~\\[-1ex]
+   \begin{array}{rlll}
+   \alloctype(S, \functype) &=& S', \typeaddr \\[1ex]
+   \mbox{where:} \hfill \\
+   \typeaddr &=& |S.\STYPES| \\
+   S' &=& S \compose \{\STYPES~\typeinst\} \\
+   \end{array}
+
+
+.. index:: function, function instance, function address, module instance, function type, type instance
 .. _alloc-func:
 
 :ref:`Functions <syntax-funcinst>`
@@ -21,11 +45,11 @@ New instances of :ref:`functions <syntax-funcinst>`, :ref:`tables <syntax-tablei
 
 1. Let :math:`\func` be the :ref:`function <syntax-func>` to allocate and :math:`\moduleinst` its :ref:`module instance <syntax-moduleinst>`.
 
-2. Let :math:`\functype` be the :ref:`function type <syntax-functype>` :math:`\moduleinst.\MITYPES[\func.\FTYPE]`.
+2. Let :math:`\typeaddr` be the :ref:`type address <syntax-typeaddr>` :math:`\moduleinst.\MITYPES[\func.\FTYPE]`.
 
 3. Let :math:`a` be the first free :ref:`function address <syntax-funcaddr>` in :math:`S`.
 
-4. Let :math:`\funcinst` be the :ref:`function instance <syntax-funcinst>` :math:`\{ \FITYPE~\functype, \FIMODULE~\moduleinst, \FICODE~\func \}`.
+4. Let :math:`\funcinst` be the :ref:`function instance <syntax-funcinst>` :math:`\{ \FITYPE~\typeaddr', \FIMODULE~\moduleinst, \FICODE~\func \}`.
 
 6. Append :math:`\funcinst` to the |SFUNCS| of :math:`S`.
 
@@ -36,9 +60,9 @@ New instances of :ref:`functions <syntax-funcinst>`, :ref:`tables <syntax-tablei
    \begin{array}{rlll}
    \allocfunc(S, \func, \moduleinst) &=& S', \funcaddr \\[1ex]
    \mbox{where:} \hfill \\
-   \functype &=& \moduleinst.\MITYPES[\func.\FTYPE] \\
+   \typeaddr &=& \moduleinst.\MITYPES[\func.\FTYPE] \\
    \funcaddr &=& |S.\SFUNCS| \\
-   \funcinst &=& \{ \FITYPE~\functype, \FIMODULE~\moduleinst, \FICODE~\func \} \\
+   \funcinst &=& \{ \FITYPE~\typeaddr, \FIMODULE~\moduleinst, \FICODE~\func \} \\
    S' &=& S \compose \{\SFUNCS~\funcinst\} \\
    \end{array}
 
@@ -49,11 +73,11 @@ New instances of :ref:`functions <syntax-funcinst>`, :ref:`tables <syntax-tablei
 :ref:`Host Functions <syntax-hostfunc>`
 .......................................
 
-1. Let :math:`\hostfunc` be the :ref:`host function <syntax-hostfunc>` to allocate and :math:`\functype` its :ref:`function type <syntax-functype>`.
+1. Let :math:`\hostfunc` be the :ref:`host function <syntax-hostfunc>` to allocate and :math:`\typeaddr` its :ref:`dynamic <syntax-type-dyn>` :ref:`function type <syntax-functype>`.
 
 2. Let :math:`a` be the first free :ref:`function address <syntax-funcaddr>` in :math:`S`.
 
-3. Let :math:`\funcinst` be the :ref:`function instance <syntax-funcinst>` :math:`\{ \FITYPE~\functype, \FIHOSTCODE~\hostfunc \}`.
+3. Let :math:`\funcinst` be the :ref:`function instance <syntax-funcinst>` :math:`\{ \FITYPE~\typeaddr, \FIHOSTCODE~\hostfunc \}`.
 
 4. Append :math:`\funcinst` to the |SFUNCS| of :math:`S`.
 
@@ -62,10 +86,10 @@ New instances of :ref:`functions <syntax-funcinst>`, :ref:`tables <syntax-tablei
 .. math::
    ~\\[-1ex]
    \begin{array}{rlll}
-   \allochostfunc(S, \functype, \hostfunc) &=& S', \funcaddr \\[1ex]
+   \allochostfunc(S, \typeaddr, \hostfunc) &=& S', \funcaddr \\[1ex]
    \mbox{where:} \hfill \\
    \funcaddr &=& |S.\SFUNCS| \\
-   \funcinst &=& \{ \FITYPE~\functype, \FIHOSTCODE~\hostfunc \} \\
+   \funcinst &=& \{ \FITYPE~\typeaddr, \FIHOSTCODE~\hostfunc \} \\
    S' &=& S \compose \{\SFUNCS~\funcinst\} \\
    \end{array}
 
@@ -80,17 +104,19 @@ New instances of :ref:`functions <syntax-funcinst>`, :ref:`tables <syntax-tablei
 :ref:`Tables <syntax-tableinst>`
 ................................
 
-1. Let :math:`\tabletype` be the :ref:`table type <syntax-tabletype>` of the table to allocate and :math:`\reff` the initialization value.
+1. Let :math:`\tabletype` be the :ref:`dynamic <syntax-type-dyn>` :ref:`table type <syntax-tabletype>` of the table to allocate and :math:`\reff` the initialization value.
 
 2. Let :math:`(\{\LMIN~n, \LMAX~m^?\}~\reftype)` be the structure of :ref:`table type <syntax-tabletype>` :math:`\tabletype`.
 
-3. Let :math:`a` be the first free :ref:`table address <syntax-tableaddr>` in :math:`S`.
+3. Let :math:`\tabletype'` be the :ref:`table type <syntax-tabletype>` obtained from :math:`\tabletype` by substituting each :ref:`type index <syntax-typeidx>` :math:`x` occurring in it with the :ref:`type address <syntax-typeaddr>` :math:`\moduleinst.\MITYPES[x]`.
 
-4. Let :math:`\tableinst` be the :ref:`table instance <syntax-tableinst>` :math:`\{ \TITYPE~\tabletype', \TIELEM~\reff^n \}` with :math:`n` elements set to :math:`\reff`.
+4. Let :math:`a` be the first free :ref:`table address <syntax-tableaddr>` in :math:`S`.
 
-5. Append :math:`\tableinst` to the |STABLES| of :math:`S`.
+5. Let :math:`\tableinst` be the :ref:`table instance <syntax-tableinst>` :math:`\{ \TITYPE~\tabletype', \TIELEM~\reff^n \}` with :math:`n` elements set to :math:`\reff`.
 
-6. Return :math:`a`.
+6. Append :math:`\tableinst` to the |STABLES| of :math:`S`.
+
+7. Return :math:`a`.
 
 .. math::
    \begin{array}{rlll}
@@ -109,7 +135,7 @@ New instances of :ref:`functions <syntax-funcinst>`, :ref:`tables <syntax-tablei
 :ref:`Memories <syntax-meminst>`
 ................................
 
-1. Let :math:`\memtype` be the :ref:`memory type <syntax-memtype>` of the memory to allocate.
+1. Let :math:`\memtype` be the :ref:`dynamic <syntax-type-dyn>` :ref:`memory type <syntax-memtype>` of the memory to allocate.
 
 2. Let :math:`\{\LMIN~n, \LMAX~m^?\}` be the structure of :ref:`memory type <syntax-memtype>` :math:`\memtype`.
 
@@ -138,7 +164,7 @@ New instances of :ref:`functions <syntax-funcinst>`, :ref:`tables <syntax-tablei
 :ref:`Globals <syntax-globalinst>`
 ..................................
 
-1. Let :math:`\globaltype` be the :ref:`global type <syntax-globaltype>` of the global to allocate and :math:`\val` its initialization :ref:`value <syntax-val>`.
+1. Let :math:`\globaltype` be the :ref:`dynamic <syntax-type-dyn>` :ref:`global type <syntax-globaltype>` of the global to allocate and :math:`\val` its initialization :ref:`value <syntax-val>`.
 
 2. Let :math:`a` be the first free :ref:`global address <syntax-globaladdr>` in :math:`S`.
 
@@ -164,7 +190,7 @@ New instances of :ref:`functions <syntax-funcinst>`, :ref:`tables <syntax-tablei
 :ref:`Element segments <syntax-eleminst>`
 .........................................
 
-1. Let :math:`\reftype` be the elements' type and :math:`\reff^\ast` the vector of :ref:`references <syntax-ref>` to allocate.
+1. Let :math:`\reftype` be the elements' :ref:`dynamic <syntax-type-dyn>` type and :math:`\reff^\ast` the vector of :ref:`references <syntax-ref>` to allocate.
 
 2. Let :math:`a` be the first free :ref:`element address <syntax-elemaddr>` in :math:`S`.
 
@@ -190,11 +216,11 @@ New instances of :ref:`functions <syntax-funcinst>`, :ref:`tables <syntax-tablei
 :ref:`Data segments <syntax-datainst>`
 ......................................
 
-1. Let :math:`b^\ast` be the vector of :ref:`bytes <syntax-byte>` to allocate.
+1. Let :math:`\bytes` be the vector of :ref:`bytes <syntax-byte>` to allocate.
 
 2. Let :math:`a` be the first free :ref:`data address <syntax-dataaddr>` in :math:`S`.
 
-3. Let :math:`\datainst` be the :ref:`data instance <syntax-datainst>` :math:`\{ \DIDATA~b^\ast \}`.
+3. Let :math:`\datainst` be the :ref:`data instance <syntax-datainst>` :math:`\{ \DIDATA~\bytes \}`.
 
 4. Append :math:`\datainst` to the |SDATAS| of :math:`S`.
 
@@ -202,10 +228,10 @@ New instances of :ref:`functions <syntax-funcinst>`, :ref:`tables <syntax-tablei
 
 .. math::
   \begin{array}{rlll}
-  \allocdata(S, b^\ast) &=& S', \dataaddr \\[1ex]
+  \allocdata(S, \bytes) &=& S', \dataaddr \\[1ex]
   \mbox{where:} \hfill \\
   \dataaddr &=& |S.\SDATAS| \\
-  \datainst &=& \{ \DIDATA~b^\ast \} \\
+  \datainst &=& \{ \DIDATA~\bytes \} \\
   S' &=& S \compose \{\SDATAS~\datainst\} \\
   \end{array}
 
@@ -296,9 +322,11 @@ and list of :ref:`reference <syntax-ref>` vectors for the module's :ref:`element
 
 1. Let :math:`\module` be the :ref:`module <syntax-module>` to allocate and :math:`\externval_{\F{im}}^\ast` the vector of :ref:`external values <syntax-externval>` providing the module's imports, :math:`\val_{\F{g}}^\ast` the initialization :ref:`values <syntax-val>` of the module's :ref:`globals <syntax-global>`, :math:`\reff_{\F{t}}^\ast` the initializer :ref:`reference <syntax-ref>` of the module's :ref:`tables <syntax-table>`, and :math:`(\reff_{\F{e}}^\ast)^\ast` the :ref:`reference <syntax-ref>` vectors of the module's :ref:`element segments <syntax-elem>`.
 
-2. For each :ref:`defined type <syntax-deftype>` :math:`\deftype'_i` in :math:`\module.\MTYPES`, do:
+2. For each :ref:`function type <syntax-functype>` :math:`\functype_i` in :math:`\module.\MTYPES`, do:
+
+   a. Let :math:`\functype'_i` be the :ref:`dynamic <syntax-type-dyn>` :ref:`function type <syntax-functype>` obtained from :math:`\functype_i` in :math:`\moduleinst` defined below.
 
-   a. Let :math:`\deftype_i` be the :ref:`instantiation <type-inst>` :math:`\deftype'_i` in :math:`\moduleinst` defined below.
+   b. Let :math:`\typeaddr_i` be the :ref:`type address <syntax-typeaddr>` resulting from :ref:`allocating <alloc-type>` :math:`\functype'_i`.
 
 3. For each :ref:`function <syntax-func>` :math:`\func_i` in :math:`\module.\MFUNCS`, do:
 
@@ -306,25 +334,25 @@ and list of :ref:`reference <syntax-ref>` vectors for the module's :ref:`element
 
 4. For each :ref:`table <syntax-table>` :math:`\table_i` in :math:`\module.\MTABLES`, do:
 
-   a. Let :math:`\limits_i~t_i` be the :ref:`table type <syntax-tabletype>` obtained by :ref:`instantiating <type-inst>` :math:`\table_i.\TTYPE` in :math:`\moduleinst` defined below.
+   a. Let :math:`\limits_i~t_i` be the :ref:`dynamic <syntax-type-dyn>` :ref:`table type <syntax-tabletype>` obtained from :math:`\table_i.\TTYPE` in :math:`\moduleinst` defined below.
 
    b. Let :math:`\tableaddr_i` be the :ref:`table address <syntax-tableaddr>` resulting from :ref:`allocating <alloc-table>` :math:`\table_i.\TTYPE` with initialization value :math:`\reff_{\F{t}}^\ast[i]`.
 
 5. For each :ref:`memory <syntax-mem>` :math:`\mem_i` in :math:`\module.\MMEMS`, do:
 
-   a. Let :math:`\memtype_i` be the :ref:`memory type <syntax-memtype>` obtained by :ref:`insantiating <type-inst>` :math:`\mem_i.\MTYPE` in :math:`\moduleinst` defined below.
+   a. Let :math:`\memtype_i` be the :ref:`dynamic <syntax-type-dyn>` :ref:`memory type <syntax-memtype>` obtained from :math:`\mem_i.\MTYPE` in :math:`\moduleinst` defined below.
 
    b. Let :math:`\memaddr_i` be the :ref:`memory address <syntax-memaddr>` resulting from :ref:`allocating <alloc-mem>` :math:`\memtype_i`.
 
 6. For each :ref:`global <syntax-global>` :math:`\global_i` in :math:`\module.\MGLOBALS`, do:
 
-   a. Let :math:`\globaltype_i` be the :ref:`global type <syntax-globaltype>` obtained by :ref:`instantiating <type-inst>` :math:`\global_i.\GTYPE` in :math:`\moduleinst` defined below.
+   a. Let :math:`\globaltype_i` be the :ref:`dynamic <syntax-type-dyn>` :ref:`global type <syntax-globaltype>` obtained from :math:`\global_i.\GTYPE` in :math:`\moduleinst` defined below.
 
    b. Let :math:`\globaladdr_i` be the :ref:`global address <syntax-globaladdr>` resulting from :ref:`allocating <alloc-global>` :math:`\globaltype_i` with initializer value :math:`\val_{\F{g}}^\ast[i]`.
 
 7. For each :ref:`element segment <syntax-elem>` :math:`\elem_i` in :math:`\module.\MELEMS`, do:
 
-   a. Let :math:`\reftype_i` be the element :ref:`reference type <syntax-reftype>` obtained by `instantiating <type-inst>` :math:`\elem_i.\ETYPE` in :math:`\moduleinst` defined below.
+   a. Let :math:`\reftype_i` be the :ref:`dynamic <syntax-type-dyn>` element :ref:`reference type <syntax-reftype>` obtained from :math:`\elem_i.\ETYPE` in :math:`\moduleinst` defined below.
 
    b. Let :math:`\elemaddr_i` be the :ref:`element address <syntax-elemaddr>` resulting from :ref:`allocating <alloc-elem>` a :ref:`element instance <syntax-eleminst>` of :ref:`reference type <syntax-reftype>` :math:`\reftype_i` with contents :math:`(\reff_{\F{e}}^\ast)^\ast[i]`.
 
@@ -332,7 +360,7 @@ and list of :ref:`reference <syntax-ref>` vectors for the module's :ref:`element
 
    a. Let :math:`\dataaddr_i` be the :ref:`data address <syntax-dataaddr>` resulting from :ref:`allocating <alloc-data>` a :ref:`data instance <syntax-datainst>` with contents :math:`\data_i.\DINIT`.
 
-9. Let :math:`\deftype^\ast` be the concatenation of the :ref:`defined types <syntax-deftype>` :math:`\deftype_i` in index order.
+9. Let :math:`\typeaddr^\ast` be the concatenation of the :ref:`function addresses <syntax-typeaddr>` :math:`\typeaddr_i` in index order.
 
 10. Let :math:`\funcaddr^\ast` be the concatenation of the :ref:`function addresses <syntax-funcaddr>` :math:`\funcaddr_i` in index order.
 
@@ -368,7 +396,7 @@ and list of :ref:`reference <syntax-ref>` vectors for the module's :ref:`element
 
 21. Let :math:`\exportinst^\ast` be the concatenation of the :ref:`export instances <syntax-exportinst>` :math:`\exportinst_i` in index order.
 
-22. Let :math:`\moduleinst` be the :ref:`module instance <syntax-moduleinst>` :math:`\{\MITYPES~\deftype^\ast,` :math:`\MIFUNCS~\funcaddr_{\F{mod}}^\ast,` :math:`\MITABLES~\tableaddr_{\F{mod}}^\ast,` :math:`\MIMEMS~\memaddr_{\F{mod}}^\ast,` :math:`\MIGLOBALS~\globaladdr_{\F{mod}}^\ast,` :math:`\MIEXPORTS~\exportinst^\ast\}`.
+22. Let :math:`\moduleinst` be the :ref:`module instance <syntax-moduleinst>` :math:`\{\MITYPES~\typeaddr^\ast,` :math:`\MIFUNCS~\funcaddr_{\F{mod}}^\ast,` :math:`\MITABLES~\tableaddr_{\F{mod}}^\ast,` :math:`\MIMEMS~\memaddr_{\F{mod}}^\ast,` :math:`\MIGLOBALS~\globaladdr_{\F{mod}}^\ast,` :math:`\MIEXPORTS~\exportinst^\ast\}`.
 
 23. Return :math:`\moduleinst`.
 
@@ -391,7 +419,7 @@ where:
    \export^\ast &=& \module.\MEXPORTS \\[1ex]
    \moduleinst &=& \{~
      \begin{array}[t]{@{}l@{}}
-     \MITYPES~\deftype^\ast, \\
+     \MITYPES~\typeaddr^\ast, \\
      \MIFUNCS~\evfuncs(\externval_{\F{im}}^\ast)~\funcaddr^\ast, \\
      \MITABLES~\evtables(\externval_{\F{im}}^\ast)~\tableaddr^\ast, \\
      \MIMEMS~\evmems(\externval_{\F{im}}^\ast)~\memaddr^\ast, \\
@@ -400,21 +428,21 @@ where:
      \MIDATAS~\dataaddr^\ast, \\
      \MIEXPORTS~\exportinst^\ast ~\}
      \end{array} \\[1ex]
-   \deftype^\ast &=&
-     \insttype_{\moduleinst}(\module.\MTYPES) \\
-   S_1, \funcaddr^\ast &=&
-     \allocfunc^\ast(S, \module.\MFUNCS, \moduleinst) \\
-   S_2, \tableaddr^\ast &=&
-     \alloctable^\ast(S_1, \insttype_{\moduleinst}(\table.\TTYPE)^\ast, \reff_{\F{t}}^\ast)
+   S_1, \typeaddr^\ast &=&
+     \alloctype^\ast(S, \dyn_{\moduleinst}(\module.\MTYPES)) \\
+   S_2, \funcaddr^\ast &=&
+     \allocfunc^\ast(S_1, \module.\MFUNCS, \moduleinst) \\
+   S_3, \tableaddr^\ast &=&
+     \alloctable^\ast(S_2, \dyn_{\moduleinst}(\table.\TTYPE)^\ast, \reff_{\F{t}}^\ast)
      \quad (\where (\table.\TTYPE)^\ast = (\limits~t)^\ast) \\
-   S_3, \memaddr^\ast &=&
-     \allocmem^\ast(S_2, \insttype_{\moduleinst}(\mem.\MTYPE)^\ast) \\
-   S_4, \globaladdr^\ast &=&
-     \allocglobal^\ast(S_3, \insttype_{\moduleinst}(\global.\GTYPE)^\ast, \val_{\F{g}}^\ast) \\
-   S_5, \elemaddr^\ast &=&
-     \allocelem^\ast(S_4, \insttype_{\moduleinst}(\elem.\ETYPE)^\ast, (\reff_{\F{e}}^\ast)^\ast) \\
+   S_4, \memaddr^\ast &=&
+     \allocmem^\ast(S_3, \dyn_{\moduleinst}(\mem.\MTYPE)^\ast) \\
+   S_5, \globaladdr^\ast &=&
+     \allocglobal^\ast(S_3, \dyn_{\moduleinst}(\global.\GTYPE)^\ast, \val_{\F{g}}^\ast) \\
+   S_6, \elemaddr^\ast &=&
+     \allocelem^\ast(S_5, \dyn_{\moduleinst}(\elem.\ETYPE)^\ast, (\reff_{\F{e}}^\ast)^\ast) \\
    S', \dataaddr^\ast &=&
-     \allocdata^\ast(S_5, \data.\DINIT^\ast) \\
+     \allocdata^\ast(S_6, \dyn_{\moduleinst}(\data.\DINIT)^\ast) \\
    \exportinst^\ast &=&
      \{ \EINAME~(\export.\ENAME), \EIVALUE~\externval_{\F{ex}} \}^\ast \\[1ex]
    \evfuncs(\externval_{\F{ex}}^\ast) &=& (\moduleinst.\MIFUNCS[x])^\ast
@@ -483,7 +511,7 @@ It is up to the :ref:`embedder <embedder>` to define how such conditions are rep
 
       i. Fail.
 
-   b. Let :math:`\externtype''_i` be the :ref:`external type <syntax-externtype>` obtained by :ref:`instantiating <type-inst>` :math:`\externtype'_i` in :math:`\moduleinst` defined below.
+   b. Let :math:`\externtype''_i` be the :ref:`dynamic <syntax-type-dyn>` :ref:`external type <syntax-externtype>` obtained by :ref:`instantiating <dyn>` :math:`\externtype'_i` in :math:`\moduleinst` defined below.
 
    c. If :math:`\externtype_i` does not :ref:`match <match-externtype>` :math:`\externtype''_i`, then:
 
@@ -596,7 +624,7 @@ It is up to the :ref:`embedder <embedder>` to define how such conditions are rep
    &(\iff
      & \vdashmodule \module : \externtype_{\F{im}}^k \rightarrow \externtype_{\F{ex}}^\ast \\
      &\wedge& (S' \vdashexternval \externval : \externtype)^k \\
-     &\wedge& (S' \vdashexterntypematch \externtype \matchesexterntype \insttype_{\moduleinst}(\externtype_{\F{im}}))^k \\[1ex]
+     &\wedge& (S' \vdashexterntypematch \externtype \matchesexterntype \dyn_{\moduleinst}(\externtype_{\F{im}}))^k \\[1ex]
      &\wedge& \module.\MGLOBALS = \global^\ast \\
      &\wedge& \module.\MELEMS = \elem^n \\
      &\wedge& \module.\MDATAS = \data^m \\
@@ -609,16 +637,19 @@ It is up to the :ref:`embedder <embedder>` to define how such conditions are rep
      &\wedge& (S'; F; \expr_{\F{g}} \stepto^\ast S'; F; \val_{\F{g}}~\END)^\ast \\
      &\wedge& (S'; F; \expr_{\F{t}} \stepto^\ast S'; F; \reff_{\F{t}}~\END)^\ast \\
      &\wedge& ((S'; F; \expr_{\F{e}} \stepto^\ast S'; F; \reff_{\F{e}}~\END)^\ast)^n \\
+     &\wedge& (\tableaddr = \moduleinst.\MITABLES[\elem.\ETABLE])^\ast \\
+     &\wedge& (\memaddr = \moduleinst.\MIMEMS[\data.\DMEM])^\ast \\
+     &\wedge& (\funcaddr = \moduleinst.\MIFUNCS[\start.\SFUNC])^?)
    \end{array}
 
 where:
 
 .. math::
    \begin{array}{@{}l}
-   \F{runelem}_i(\{\ETYPE~\X{et}, \EINIT~\expr^n, \EMODE~\EPASSIVE\}) \quad=\quad \epsilon \\
-   \F{runelem}_i(\{\ETYPE~\X{et}, \EINIT~\expr^n, \EMODE~\EACTIVE \{\ETABLE~x, \EOFFSET~\instr^\ast~\END\}\}) \quad=\\ \qquad
+   \F{runelem}_i(\{\ETYPE~\X{et}, \EINIT~\reff^n, \EMODE~\EPASSIVE\}) \quad=\\ \qquad \epsilon \\
+   \F{runelem}_i(\{\ETYPE~\X{et}, \EINIT~\reff^n, \EMODE~\EACTIVE \{\ETABLE~x, \EOFFSET~\instr^\ast~\END\}\}) \quad=\\ \qquad
      \instr^\ast~(\I32.\CONST~0)~(\I32.\CONST~n)~(\TABLEINIT~x~i)~(\ELEMDROP~i) \\
-   \F{runelem}_i(\{\ETYPE~\X{et}, \EINIT~\expr^n, \EMODE~\EDECLARATIVE\}) \quad=\\ \qquad
+   \F{runelem}_i(\{\ETYPE~\X{et}, \EINIT~\reff^n, \EMODE~\EDECLARATIVE\}) \quad=\\ \qquad
      (\ELEMDROP~i) \\[1ex]
    \F{rundata}_i(\{\DINIT~b^n, \DMODE~\DPASSIVE\}) \quad=\\ \qquad \epsilon \\
    \F{rundata}_i(\{\DINIT~b^n, \DMODE~\DACTIVE \{\DMEM~0, \DOFFSET~\instr^\ast~\END\}\}) \quad=\\ \qquad
@@ -626,7 +657,7 @@ where:
    \end{array}
 
 .. note::
-   Checking import types assumes that the :ref:`module instance <syntax-moduleinst>` has already been :ref:`allocated <alloc-module>` to compute the respective :ref:`closed <type-closed>` :ref:`defined types <syntax-deftype>`.
+   Checking import types assumes that the :ref:`module instance <syntax-moduleinst>` has already been :ref:`allocated <alloc-module>` and the resulting :ref:`type addresses <syntax-typeaddr>` are available, in order to :ref:`instantiate <dyn>` all relevant types.
    However, this forward reference merely is a way to simplify the specification.
    In practice, implementations will likely allocate or canonicalize types beforehand, when *compiling* a module, in a stage before instantiation and before imports are checked.
 
@@ -663,25 +694,29 @@ The following steps are performed:
 
 2. Let :math:`\funcinst` be the :ref:`function instance <syntax-funcinst>` :math:`S.\SFUNCS[\funcaddr]`.
 
-3. Let :math:`[t_1^n] \toF [t_2^m]` be the :ref:`function type <syntax-functype>` :math:`\funcinst.\FITYPE`.
+3. Let :math:`\typeaddr` be the :ref:`type address <syntax-typeaddr>` :math:`\funcinst.\FITYPE`.
+
+4. Assert: :math:`S.\STYPES[\typeaddr]` exists.
+
+5. Let :math:`[t_1^n] \toF [t_2^m]` be the :ref:`dynamic <syntax-type-dyn>` :ref:`function type <syntax-functype>` :math:`S.\STYPES[\typeaddr]`.
 
-4. If the length :math:`|\val^\ast|` of the provided argument values is different from the number :math:`n` of expected arguments, then:
+6. If the length :math:`|\val^\ast|` of the provided argument values is different from the number :math:`n` of expected arguments, then:
 
    a. Fail.
 
-5. For each :ref:`value type <syntax-valtype>` :math:`t_i` in :math:`t_1^n` and corresponding :ref:`value <syntax-val>` :math:`val_i` in :math:`\val^\ast`, do:
+7. For each :ref:`value type <syntax-valtype>` :math:`t_i` in :math:`t_1^n` and corresponding :ref:`value <syntax-val>` :math:`val_i` in :math:`\val^\ast`, do:
 
    a. If :math:`\val_i` is not :ref:`valid <valid-val>` with value type :math:`t_i`, then:
 
       i. Fail.
 
-6. Let :math:`F` be the dummy :ref:`frame <syntax-frame>` :math:`\{ \AMODULE~\{\}, \ALOCALS~\epsilon \}`.
+8. Let :math:`F` be the dummy :ref:`frame <syntax-frame>` :math:`\{ \AMODULE~\{\}, \ALOCALS~\epsilon \}`.
 
-7. Push the frame :math:`F` to the stack.
+9. Push the frame :math:`F` to the stack.
 
-8. Push the values :math:`\val^\ast` to the stack.
+10. Push the values :math:`\val^\ast` to the stack.
 
-9. :ref:`Invoke <exec-invoke>` the function instance at address :math:`\funcaddr`.
+11. :ref:`Invoke <exec-invoke>` the function instance at address :math:`\funcaddr`.
 
 Once the function has returned, the following steps are executed:
 
@@ -695,7 +730,7 @@ The values :math:`\val_{\F{res}}^m` are returned as the results of the invocatio
    ~\\[-1ex]
    \begin{array}{@{}lcl}
    \invoke(S, \funcaddr, \val^n) &=& S; F; \val^n~(\INVOKE~\funcaddr) \\
-     &(\iff & S.\SFUNCS[\funcaddr].\FITYPE = [t_1^n] \toF [t_2^m] \\
+     &(\iff & S.\STYPES[S.\SFUNCS[\funcaddr].\FITYPE] = [t_1^n] \toF [t_2^m] \\
      &\wedge& (S \vdashval \val : t_1)^n \\
      &\wedge& F = \{ \AMODULE~\{\}, \ALOCALS~\epsilon \}) \\
    \end{array}
diff --git a/document/core/exec/runtime.rst b/document/core/exec/runtime.rst
index 23464eae..01655984 100644
--- a/document/core/exec/runtime.rst
+++ b/document/core/exec/runtime.rst
@@ -97,7 +97,7 @@ Store
 ~~~~~
 
 The *store* represents all global state that can be manipulated by WebAssembly programs.
-It consists of the runtime representation of all *instances* of :ref:`functions <syntax-funcinst>`, :ref:`tables <syntax-tableinst>`, :ref:`memories <syntax-meminst>`, and :ref:`globals <syntax-globalinst>`, :ref:`element segments <syntax-eleminst>`, and :ref:`data segments <syntax-datainst>` that have been :ref:`allocated <alloc>` during the life time of the abstract machine. [#gc]_
+It consists of the runtime representation of all *instances* of :ref:`types <syntax-typeinst>`, :ref:`functions <syntax-funcinst>`, :ref:`tables <syntax-tableinst>`, :ref:`memories <syntax-meminst>`, and :ref:`globals <syntax-globalinst>`, :ref:`element segments <syntax-eleminst>`, and :ref:`data segments <syntax-datainst>` that have been :ref:`allocated <alloc>` during the life time of the abstract machine. [#gc]_
 
 It is an invariant of the semantics that no element or data instance is :ref:`addressed <syntax-addr>` from anywhere else but the owning module instances.
 
@@ -107,6 +107,7 @@ Syntactically, the store is defined as a :ref:`record <notation-record>` listing
    \begin{array}{llll}
    \production{store} & \store &::=& \{~
      \begin{array}[t]{l@{~}ll}
+     \STYPES & \typeinst^\ast, \\
      \SFUNCS & \funcinst^\ast, \\
      \STABLES & \tableinst^\ast, \\
      \SMEMS & \meminst^\ast, \\
@@ -129,6 +130,7 @@ Convention
 
 
 .. index:: ! address, store, function instance, table instance, memory instance, global instance, element instance, data instance, embedder
+   pair: abstract syntax; type address
    pair: abstract syntax; function address
    pair: abstract syntax; table address
    pair: abstract syntax; memory address
@@ -136,6 +138,7 @@ Convention
    pair: abstract syntax; element address
    pair: abstract syntax; data address
    pair: abstract syntax; host address
+   pair: type; address
    pair: function; address
    pair: table; address
    pair: memory; address
@@ -143,6 +146,7 @@ Convention
    pair: element; address
    pair: data; address
    pair: host; address
+.. _syntax-typeaddr:
 .. _syntax-funcaddr:
 .. _syntax-tableaddr:
 .. _syntax-memaddr:
@@ -155,7 +159,7 @@ Convention
 Addresses
 ~~~~~~~~~
 
-:ref:`Function instances <syntax-funcinst>`, :ref:`table instances <syntax-tableinst>`, :ref:`memory instances <syntax-meminst>`, and :ref:`global instances <syntax-globalinst>`, :ref:`element instances <syntax-eleminst>`, and :ref:`data instances <syntax-datainst>` in the :ref:`store <syntax-store>` are referenced with abstract *addresses*.
+:ref:`Type instances <syntax-typeinst>`, :ref:`function instances <syntax-funcinst>`, :ref:`table instances <syntax-tableinst>`, :ref:`memory instances <syntax-meminst>`, and :ref:`global instances <syntax-globalinst>`, :ref:`element instances <syntax-eleminst>`, and :ref:`data instances <syntax-datainst>` in the :ref:`store <syntax-store>` are referenced with abstract *addresses*.
 These are simply indices into the respective store component.
 In addition, an :ref:`embedder <embedder>` may supply an uninterpreted set of *host addresses*.
 
@@ -163,6 +167,8 @@ In addition, an :ref:`embedder <embedder>` may supply an uninterpreted set of *h
    \begin{array}{llll}
    \production{address} & \addr &::=&
      0 ~|~ 1 ~|~ 2 ~|~ \dots \\
+   \production{type address} & \typeaddr &::=&
+     \addr \\
    \production{function address} & \funcaddr &::=&
      \addr \\
    \production{table address} & \tableaddr &::=&
@@ -194,6 +200,7 @@ even where this identity is not observable from within WebAssembly code itself
    hence logical addresses can be arbitrarily large natural numbers.
 
 
+.. _free-typeaddr:
 .. _free-funcaddr:
 .. _free-tableaddr:
 .. _free-memaddr:
@@ -227,7 +234,7 @@ and collects runtime representations of all entities that are imported, defined,
    \begin{array}{llll}
    \production{module instance} & \moduleinst &::=& \{
      \begin{array}[t]{l@{~}ll}
-     \MITYPES & \deftype^\ast, \\
+     \MITYPES & \typeaddr^\ast, \\
      \MIFUNCS & \funcaddr^\ast, \\
      \MITABLES & \tableaddr^\ast, \\
      \MIMEMS & \memaddr^\ast, \\
@@ -239,11 +246,29 @@ and collects runtime representations of all entities that are imported, defined,
    \end{array}
 
 Each component references runtime instances corresponding to respective declarations from the original module -- whether imported or defined -- in the order of their static :ref:`indices <syntax-index>`.
-:ref:`Function instances <syntax-funcinst>`, :ref:`table instances <syntax-tableinst>`, :ref:`memory instances <syntax-meminst>`, and :ref:`global instances <syntax-globalinst>` are referenced with an indirection through their respective :ref:`addresses <syntax-addr>` in the :ref:`store <syntax-store>`.
+:ref:`Type instances <syntax-typeinst>`, :ref:`function instances <syntax-funcinst>`, :ref:`table instances <syntax-tableinst>`, :ref:`memory instances <syntax-meminst>`, and :ref:`global instances <syntax-globalinst>` are referenced with an indirection through their respective :ref:`addresses <syntax-addr>` in the :ref:`store <syntax-store>`.
 
 It is an invariant of the semantics that all :ref:`export instances <syntax-exportinst>` in a given module instance have different :ref:`names <syntax-name>`.
 
 
+.. index:: ! type instance, function type, module
+   pair: abstract syntax; function instance
+   pair: function; instance
+.. _syntax-typeinst:
+
+Type Instances
+~~~~~~~~~~~~~~
+
+A *type instance* is the runtime representation of a :ref:`function type <syntax-functype>`.
+It is a :ref:`dynamic type <syntax-type-dyn>` equivalent to the respective :ref:`static type <syntax-type-stat>` that appeared in the module.
+
+.. math::
+   \begin{array}{llll}
+   \production{type instance} & \typeinst &::=&
+     \functype
+   \end{array}
+
+
 .. index:: ! function instance, module instance, function, closure, module, ! host function, invocation
    pair: abstract syntax; function instance
    pair: function; instance
@@ -260,8 +285,8 @@ The module instance is used to resolve references to other definitions during ex
 .. math::
    \begin{array}{llll}
    \production{function instance} & \funcinst &::=&
-     \{ \FITYPE~\functype, \FIMODULE~\moduleinst, \FICODE~\func \} \\ &&|&
-     \{ \FITYPE~\functype, \FIHOSTCODE~\hostfunc \} \\
+     \{ \FITYPE~\typeaddr, \FIMODULE~\moduleinst, \FICODE~\func \} \\ &&|&
+     \{ \FITYPE~\typeaddr, \FIHOSTCODE~\hostfunc \} \\
    \production{host function} & \hostfunc &::=& \dots \\
    \end{array}
 
@@ -527,7 +552,7 @@ Conventions
 
 .. math::
    \begin{array}{lll}
-   \expand_{S;F}(\typeidx) &=& F.\AMODULE.\MITYPES[\typeidx] \\
+   \expand_{S;F}(\typeidx) &=& S.\STYPES[F.\AMODULE.\MITYPES[\typeidx]] \\
    \expand_{S;F}([\valtype^?]) &=& [] \to [\valtype^?] \\
    \end{array}
 
diff --git a/document/core/exec/types.rst b/document/core/exec/types.rst
index 6742ba1a..19175460 100644
--- a/document/core/exec/types.rst
+++ b/document/core/exec/types.rst
@@ -4,23 +4,69 @@
 Types
 -----
 
-Execution has to check and compare :ref:`types <syntax-type>` in a few places, such as :ref:`executing <exec-call_indirect>` |CALLINDIRECT| or :ref:`instantiating <exec-instantiation>` :ref:`modules <syntax-module>`.
-
-It is an invariant of the semantics that all types occurring during execution are :ref:`closed <type-closed>`.
+Execution has to check and compare :ref:`types <syntax-type>` and :ref:`type instances <syntax-typeinst>` in a few places, such as :ref:`executing <exec-call_indirect>` |CALLINDIRECT| or :ref:`instantiating <exec-instantiation>` :ref:`modules <syntax-module>`.
+During execution, types of all forms are represented as :ref:`dynamic <syntax-type-dyn>` types, where all occurring :ref:`type identifiers <syntax-typeid>` are interpreted as :ref:`type addresses <syntax-typeaddr>`.
+Relevant type relations need to be redefined accordingly.
 
 .. note::
    Runtime type checks generally involve types from multiple modules or types not defined by a module at all, such that module-local :ref:`type indices <syntax-typeidx>` are not meaningful.
+   Type addresses are global to a :ref:`store <syntax-store>` and can hence be interpreted independent of module boundaries.
+
+
+.. index:: type identifier, type address, store
+   pair: validation; type identifier
+   single: abstract syntax; type identifier
+.. _valid-typeaddr:
+
+Type Identifiers
+~~~~~~~~~~~~~~~~
+
+During execution, :ref:`type identifiers <syntax-typeid>` are represented as :ref:`type addresses <syntax-typeaddr>`, which are looked up as :ref:`function types <syntax-functype>` in the :ref:`store <syntax-store>` by the following rule.
+
+:math:`\typeaddr`
+.................
+
+* The type :math:`S.\STYPES[\typeaddr]` must be defined in the store.
+
+* Then the type address is valid as :ref:`function type <syntax-functype>` :math:`S.\STYPES[\typeaddr]`.
+
+.. math::
+   \frac{
+     S.\STYPES[\typeaddr] = \functype
+   }{
+     S; C \vdashtypeid \typeaddr : \functype
+   }
 
+.. note::
+   Unlike :ref:`type indices <syntax-typeidx>` recorded in a context, the number of type addresses in a store is not bounded by :math:`2^{32}`.
 
 
-.. index:: type index, defined type, type instantiation, module instance, dynamic type
+.. index:: type identifier, type index, type address, type instantiation, module instance, dynamic type
 
-.. _type-inst:
+.. _dyn:
 
 Instantiation
 ~~~~~~~~~~~~~
 
-Any form of :ref:`type <syntax-type>` can be *instantiated* into a :ref:`closed <type-closed>` type inside a :ref:`module instance <syntax-moduleinst>` by :ref:`substituting <notation-subst>` each :ref:`type index <syntax-typeidx>` :math:`x` occurring in it with the corresponding :ref:`defined type <syntax-deftype>` :math:`\moduleinst.\MITYPES[x]`.
+Any form of :ref:`static <syntax-type-stat>` :ref:`type <syntax-type>` can be *instantiated* into a :ref:`dynamic <syntax-type-dyn>` type inside a :ref:`module instance <syntax-moduleinst>` by :ref:`substituting <notation-subst>` each :ref:`type index <syntax-typeidx>` :math:`x` occurring in it with the corresponding :ref:`type address <syntax-typeaddr>` :math:`\moduleinst.\MITYPES[x]`.
 
 .. math::
-   \insttype_{\moduleinst}(t) = t[\subst \moduleinst.\MITYPES]
+   \dyn_{\moduleinst}(t) = t[\subst \moduleinst.\MITYPES]
+
+
+.. index:: type, matching, store, dynamic types, validity
+.. _exec-valid-type:
+.. _exec-match:
+
+Dynamic Typing
+~~~~~~~~~~~~~~
+
+To handle :ref:`dynamic <syntax-type-dyn>` types, all static judgements :math:`C \vdash \X{prop}` on types (such as :ref:`validity <valid-type>` and :ref:`matching <match>`) are generalized to include the store, as in :math:`S; C \vdash \X{prop}`, by implicitly adding a :ref:`store <syntax-store>` :math:`S` to all rules -- :math:`S` is never modified by the pre-existing rules, but it is accessed in the extra rule for :ref:`type addresses <syntax-typeaddr>` given :ref:`above <valid-typeaddr>`.
+
+It is an invariant of the semantics that all types inspected by execution rules are dynamic, i.e., the :ref:`context <context>` is always empty and never used.
+To avoid unnecessary clutter, empty contexts are omitted from the rules, writing just :math:`S \vdash \X{prop}`.
+
+.. note::
+   Only matching rules are invoked during execution.
+   Dynamic validity is only needed to prove :ref:`type soundness <soundness>`
+   and for specifying parts of the :ref:`embedder <embed>` interface.
diff --git a/document/core/exec/values.rst b/document/core/exec/values.rst
index e0fd90e2..f5a87349 100644
--- a/document/core/exec/values.rst
+++ b/document/core/exec/values.rst
@@ -11,7 +11,7 @@ Value Typing
 ~~~~~~~~~~~~
 
 For the purpose of checking argument :ref:`values <syntax-externval>` against the parameter types of exported :ref:`functions <syntax-func>`,
-values are classified by :ref:`value types <syntax-valtype>`.
+values are classified by :ref:`dynamic <syntax-type-dyn>` :ref:`value types <syntax-valtype>`.
 The following auxiliary typing rules specify this typing relation relative to a :ref:`store <syntax-store>` :math:`S` in which possibly referenced addresses live.
 
 .. _valid-num:
@@ -45,13 +45,13 @@ The following auxiliary typing rules specify this typing relation relative to a
 :ref:`Null References <syntax-ref>` :math:`\REFNULL~t`
 ......................................................
 
-* The :ref:`heap type <syntax-heaptype>` must be :ref:`valid <valid-heaptype>` under the empty :ref:`context <context>`.
+* The :ref:`dynamic <syntax-type-dyn>` :ref:`heap type <syntax-heaptype>` must be :ref:`valid <valid-heaptype>`.
 
 * Then value is valid with :ref:`reference type <syntax-reftype>` :math:`(\REF~\NULL~t)`.
 
 .. math::
    \frac{
-     \vdashheaptype t \ok
+     S \vdashheaptype t \ok
    }{
      S \vdashval \REFNULL~t : (\REF~\NULL~t)
    }
@@ -60,15 +60,15 @@ The following auxiliary typing rules specify this typing relation relative to a
 :ref:`Function References <syntax-ref>` :math:`\REFFUNCADDR~a`
 ..............................................................
 
-* The :ref:`external value <syntax-externval>` :math:`\EVFUNC~a` must be :ref:`valid <valid-externval>` with :ref:`external type <syntax-externtype>` :math:`\ETFUNC~\functype`.
+* The :ref:`external value <syntax-externval>` :math:`\EVFUNC~a` must be :ref:`valid <valid-externval>` with :ref:`dynamic <syntax-type-dyn>` :ref:`external type <syntax-externtype>` :math:`\ETFUNC~a'`.
 
-* Then the value is valid with :ref:`reference type <syntax-reftype>` :math:`(\REF~\functype)`.
+* Then the value is valid with :ref:`dynamic <syntax-type-dyn>` :ref:`reference type <syntax-reftype>` :math:`(\REF~a')`.
 
 .. math::
    \frac{
-     S \vdashexternval \EVFUNC~a : \ETFUNC~\functype
+     S \vdashexternval \EVFUNC~a : \ETFUNC~a'
    }{
-     S \vdashval \REFFUNCADDR~a : \REF~\functype
+     S \vdashval \REFFUNCADDR~a : \REF~a'
    }
 
 
@@ -92,7 +92,7 @@ External Typing
 ~~~~~~~~~~~~~~~
 
 For the purpose of checking :ref:`external values <syntax-externval>` against :ref:`imports <syntax-import>`,
-such values are classified by :ref:`external types <syntax-externtype>`.
+such values are classified by :ref:`dynamic <syntax-type-dyn>` :ref:`external types <syntax-externtype>`.
 The following auxiliary typing rules specify this typing relation relative to a :ref:`store <syntax-store>` :math:`S` in which the referenced instances live.
 
 
diff --git a/document/core/syntax/types.rst b/document/core/syntax/types.rst
index 5d1b355c..15a57fb1 100644
--- a/document/core/syntax/types.rst
+++ b/document/core/syntax/types.rst
@@ -9,6 +9,51 @@ Various entities in WebAssembly are classified by types.
 Types are checked during :ref:`validation <valid>`, :ref:`instantiation <exec-instantiation>`, and possibly :ref:`execution <syntax-call_indirect>`.
 
 
+
+.. index:: ! type identifier, type index, type address, ! static type, ! dynamic type
+   pair: abstract syntax; type identifier
+.. _syntax-typeid:
+.. _syntax-type-stat:
+.. _syntax-type-dyn:
+
+Type Identifiers
+~~~~~~~~~~~~~~~~
+
+Defined types like :ref:`function types <syntax-functype>` are not embedded directly into other types, such as :ref:`reference types <syntax-reftype>`.
+Instead, they are referred to indirectly.
+
+In a :ref:`module <syntax-module>` and during :ref:`validation <valid>`, this indirection is expressed through a :ref:`type index <syntax-typeidx>`, whose meaning is confined to one module.
+
+During :ref:`execution <exec>`, where types from multiple modules may interact, it is expressed through :ref:`type addresses <syntax-typeaddr>` that refer to the global :ref:`store <store>`.
+
+The type grammar hence allows multiple representations of type identifiers:
+
+.. math::
+   \begin{array}{llll}
+   \production{type identifier} & \typeid &::=&
+     \typeidx ~|~ \typeaddr
+   \end{array}
+
+Types represented with type indices are referred to as *static types*,
+whereas types represented with type addresses are referred to as *dynamic types*.
+
+Static types are transformed into dynamic types during module :ref:`instantiation <exec-instantiation>`.
+
+It is an invariant of the semantics that only static types arise during :ref:`validation <valid>`, while only dynamic types are used during :ref:`execution <exec>`.
+However, for the proof of :ref:`type soundness <soundness>`, both forms of types must be considered together, and static types may refer to dynamic types.
+
+.. _notation-subst:
+
+Convention
+..........
+
+The following notation expresses conversion between static and dynamic types:
+
+* :math:`t[x^\ast \subst a^\ast]` denotes the parallel substitution of :ref:`type indices <syntax-typeidx>` :math:`x^\ast` with :ref:`type addresses <syntax-typeaddr>` :math:`a^\ast`, provided :math:`|x^\ast| = |a^\ast|`.
+
+* :math:`t[\subst a^\ast]` is shorthand for the substitution :math:`t[x^\ast \subst a^\ast]` where :math:`x^\ast = 0 \cdots (|a^\ast| - 1)`.
+
+
 .. index:: ! number type, integer, floating-point, IEEE 754, bit width, memory
    pair: abstract syntax; number type
    pair: number; type
@@ -72,11 +117,8 @@ Conventions
 * The notation :math:`|t|` for :ref:`bit width <bitwidth>` extends to vector types as well, that is, :math:`|\V128| = 128`.
 
 
-
-.. index:: ! heap type, store, type identifier, ! substitution, ! closed type
+.. index:: ! heap type, store, type identifier
    pair: abstract syntax; heap type
-.. _type-subst:
-.. _type-closed:
 .. _syntax-heaptype:
 
 Heap Types
@@ -87,35 +129,19 @@ Heap Types
 .. math::
    \begin{array}{llll}
    \production{heap type} & \heaptype &::=&
-     \FUNC ~|~ \EXTERN ~|~ \typeidx ~|~ \functype ~|~ \BOT \\
+     \FUNC ~|~ \EXTERN ~|~ \typeid ~|~ \BOT \\
    \end{array}
 
 The type |FUNC| denotes the infinite union of all types of :ref:`functions <syntax-func>`, regardless of their concrete :ref:`function types <syntax-functype>`.
 
 The type |EXTERN| denotes the infinite union of all objects owned by the :ref:`embedder <embedder>` and that can be passed into WebAssembly under this type.
 
-A *concrete* heap type consists of a :ref:`type index <syntax-typeidx>` and classifies an object of the respective :ref:`type <syntax-type>` defined in some module.
-
-A concrete heap type can also consist of a :ref:`function type <syntax-functype>` directly.
-However, this form is representable in neither the :ref:`binary format <binary-valtype>` nor the :ref:`text format <text-valtype>`, such that it cannot be used in a program;
-it only occurs during :ref:`validation <valid>` or :ref:`execution <exec>`, as the result of *substituting* a :ref:`type index <syntax-typeidx>` with its definition.
+A *concrete* heap type consists of a :ref:`type identifier <syntax-typeid>` and classifies an object of the respective :ref:`type <syntax-type>` defined in some module.
 
 The type :math:`\BOT` is a :ref:`subtype <match-heaptype>` of all other heap types.
 By virtue of being representable in neither the :ref:`binary format <binary-valtype>` nor the :ref:`text format <text-valtype>`, it cannot be used in a program;
 it only occurs during :ref:`validation <valid>`, as a part of a possible operand type for instructions.
 
-A type of any form is *closed* when it does not contain a heap type that is a :ref:`type index <syntax-typeidx>`,
-i.e., all :ref:`type indices <syntax-typeidx>` have been :ref:`substituted <notation-subst>` with their :ref:`defined type <syntax-deftype>`.
-
-.. _notation-subst:
-
-Convention
-..........
-
-* :math:`t[x^\ast \subst \X{ft}^\ast]` denotes the parallel *substitution* of :ref:`type indices <syntax-typeidx>` :math:`x^\ast` with :ref:`function types <syntax-functype>` :math:`\X{ft}^\ast`, provided :math:`|x^\ast| = |\X{ft}^\ast|` in type :math:`t`.
-
-* :math:`t[\subst \X{ft}^\ast]` is shorthand for the substitution :math:`t[x^\ast \subst \X{ft}^\ast]` where :math:`x^\ast = 0 \cdots (|\X{ft}^\ast| - 1)` in type :math:`t`.
-
 
 .. index:: ! reference type, heap type, reference, table, function, function type, null
    pair: abstract syntax; reference type
@@ -257,25 +283,6 @@ They are also used to classify the inputs and outputs of :ref:`instructions <syn
    \end{array}
 
 
-.. index:: ! defined type, function type
-   pair: abstract syntax; defined type
-.. _syntax-deftype:
-
-Defined Types
-~~~~~~~~~~~~~
-
-*Defined types* are the ones that can be defined in a :ref:`module <syntax-module>`, assigning them a :ref:`type index <syntax-typeidx>`.
-
-.. math::
-   \begin{array}{llll}
-   \production{defined type} & \deftype &::=&
-     \functype \\
-   \end{array}
-
-.. note::
-   Future versions of WebAssembly may introduce additional forms of defined types.
-
-
 .. index:: ! limits, memory type, table type
    pair: abstract syntax; limits
    single: memory; limits
@@ -377,7 +384,7 @@ External Types
 .. math::
    \begin{array}{llll}
    \production{external types} & \externtype &::=&
-     \ETFUNC~\functype ~|~
+     \ETFUNC~\typeid ~|~
      \ETTABLE~\tabletype ~|~
      \ETMEM~\memtype ~|~
      \ETGLOBAL~\globaltype \\
@@ -390,7 +397,7 @@ Conventions
 The following auxiliary notation is defined for sequences of external types.
 It filters out entries of a specific kind in an order-preserving fashion:
 
-* :math:`\etfuncs(\externtype^\ast) = [\functype ~|~ (\ETFUNC~\functype) \in \externtype^\ast]`
+* :math:`\etfuncs(\externtype^\ast) = [\typeid ~|~ (\ETFUNC~\typeid) \in \externtype^\ast]`
 
 * :math:`\ettables(\externtype^\ast) = [\tabletype ~|~ (\ETTABLE~\tabletype) \in \externtype^\ast]`
 
diff --git a/document/core/util/bikeshed_fixup.py b/document/core/util/bikeshed_fixup.py
index 05439207..dcd4fd07 100755
--- a/document/core/util/bikeshed_fixup.py
+++ b/document/core/util/bikeshed_fixup.py
@@ -11,12 +11,6 @@ SCRIPT_DIR = os.path.dirname(os.path.realpath(__file__))
 def Main():
   data = open(sys.argv[1]).read()
 
-  # Make bikeshed happy
-  # Apparently it can't handle empty line before DOCTYPE comment
-  data = data.replace('\n<!DOCTYPE', '<!DOCTYPE')
-  # Ensure newline before <pre>
-  data = data.replace('<pre>', '\n<pre>')
-
   # Don't add more than 3 levels to TOC.
   data = data.replace('<h5>', '<h5 class="no-toc">')
 
diff --git a/document/core/util/macros.def b/document/core/util/macros.def
index 010a061e..73a238ec 100644
--- a/document/core/util/macros.def
+++ b/document/core/util/macros.def
@@ -221,6 +221,7 @@
 
 .. Types, non-terminals
 
+.. |typeid| mathdef:: \xref{syntax/types}{syntax-typeid}{\X{typeid}}
 .. |numtype| mathdef:: \xref{syntax/types}{syntax-numtype}{\X{numtype}}
 .. |vectype| mathdef:: \xref{syntax/types}{syntax-vectype}{\X{vectype}}
 .. |heaptype| mathdef:: \xref{syntax/types}{syntax-heaptype}{\X{heaptype}}
@@ -228,7 +229,6 @@
 .. |valtype| mathdef:: \xref{syntax/types}{syntax-valtype}{\X{valtype}}
 .. |resulttype| mathdef:: \xref{syntax/types}{syntax-resulttype}{\X{resulttype}}
 .. |functype| mathdef:: \xref{syntax/types}{syntax-functype}{\X{functype}}
-.. |deftype| mathdef:: \xref{syntax/types}{syntax-deftype}{\X{deftype}}
 
 .. |globaltype| mathdef:: \xref{syntax/types}{syntax-globaltype}{\X{globaltype}}
 .. |tabletype| mathdef:: \xref{syntax/types}{syntax-tabletype}{\X{tabletype}}
@@ -341,7 +341,7 @@
 .. Modules, non-terminals
 
 .. |module| mathdef:: \xref{syntax/modules}{syntax-module}{\X{module}}
-.. |type| mathdef:: \xref{syntax/types}{syntax-deftype}{\X{type}}
+.. |type| mathdef:: \xref{syntax/types}{syntax-functype}{\X{type}}
 .. |func| mathdef:: \xref{syntax/modules}{syntax-func}{\X{func}}
 .. |local| mathdef:: \xref{syntax/modules}{syntax-local}{\X{local}}
 .. |table| mathdef:: \xref{syntax/modules}{syntax-table}{\X{table}}
@@ -627,7 +627,6 @@
 .. |Bvaltype| mathdef:: \xref{binary/types}{binary-valtype}{\B{valtype}}
 .. |Bresulttype| mathdef:: \xref{binary/types}{binary-resulttype}{\B{resulttype}}
 .. |Bfunctype| mathdef:: \xref{binary/types}{binary-functype}{\B{functype}}
-.. |Bdeftype| mathdef:: \xref{binary/types}{binary-deftype}{\B{deftype}}
 .. |Bglobaltype| mathdef:: \xref{binary/types}{binary-globaltype}{\B{globaltype}}
 .. |Btabletype| mathdef:: \xref{binary/types}{binary-tabletype}{\B{tabletype}}
 .. |Bmemtype| mathdef:: \xref{binary/types}{binary-memtype}{\B{memtype}}
@@ -793,7 +792,6 @@
 .. |Treftype| mathdef:: \xref{text/types}{text-reftype}{\T{reftype}}
 .. |Tvaltype| mathdef:: \xref{text/types}{text-valtype}{\T{valtype}}
 .. |Tfunctype| mathdef:: \xref{text/types}{text-functype}{\T{functype}}
-.. |Tdeftype| mathdef:: \xref{text/types}{text-deftype}{\T{deftype}}
 
 .. |Tglobaltype| mathdef:: \xref{text/types}{text-globaltype}{\T{globaltype}}
 .. |Ttabletype| mathdef:: \xref{text/types}{text-tabletype}{\T{tabletype}}
@@ -936,6 +934,7 @@
 
 .. Judgments
 
+.. |vdashtypeid| mathdef:: \xref{valid/types}{valid-typeid}{\vdash}
 .. |vdashnumtype| mathdef:: \xref{valid/types}{valid-numtype}{\vdash}
 .. |vdashvectype| mathdef:: \xref{valid/types}{valid-vectype}{\vdash}
 .. |vdashheaptype| mathdef:: \xref{valid/types}{valid-heaptype}{\vdash}
@@ -949,7 +948,6 @@
 .. |vdashmemtype| mathdef:: \xref{valid/types}{valid-memtype}{\vdash}
 .. |vdashglobaltype| mathdef:: \xref{valid/types}{valid-globaltype}{\vdash}
 .. |vdashexterntype| mathdef:: \xref{valid/types}{valid-externtype}{\vdash}
-.. |vdashdeftype| mathdef:: \xref{valid/types}{valid-deftype}{\vdash}
 
 .. |vdashinstrtype| mathdef:: \xref{valid/types}{valid-instrtype}{\vdash}
 
@@ -1007,8 +1005,9 @@
 
 .. Allocation
 
-.. |insttype| mathdef:: \xref{exec/types}{type-inst}{\F{clos}}
+.. |dyn| mathdef:: \xref{exec/types}{dyn}{\F{dyn}}
 
+.. |alloctype| mathdef:: \xref{exec/modules}{alloc-type}{\F{alloctype}}
 .. |allocfunc| mathdef:: \xref{exec/modules}{alloc-func}{\F{allocfunc}}
 .. |allochostfunc| mathdef:: \xref{exec/modules}{alloc-hostfunc}{\F{allochostfunc}}
 .. |alloctable| mathdef:: \xref{exec/modules}{alloc-table}{\F{alloctable}}
@@ -1025,6 +1024,7 @@
 .. Addresses, non-terminals
 
 .. |addr| mathdef:: \xref{exec/runtime}{syntax-addr}{\X{addr}}
+.. |typeaddr| mathdef:: \xref{exec/runtime}{syntax-typeaddr}{\X{typeaddr}}
 .. |funcaddr| mathdef:: \xref{exec/runtime}{syntax-funcaddr}{\X{funcaddr}}
 .. |tableaddr| mathdef:: \xref{exec/runtime}{syntax-tableaddr}{\X{tableaddr}}
 .. |memaddr| mathdef:: \xref{exec/runtime}{syntax-memaddr}{\X{memaddr}}
@@ -1036,6 +1036,7 @@
 
 .. Address, meta functions
 
+.. |freetypeaddr| mathdef:: \xref{syntax/modules}{syntax-typeaddr}{\F{typeaddr}}
 .. |freefuncaddr| mathdef:: \xref{syntax/modules}{syntax-funcaddr}{\F{funcaddr}}
 .. |freetableaddr| mathdef:: \xref{syntax/modules}{syntax-tableaddr}{\F{tableaddr}}
 .. |freememaddr| mathdef:: \xref{syntax/modules}{syntax-memaddr}{\F{memaddr}}
@@ -1088,6 +1089,7 @@
 .. |externval| mathdef:: \xref{exec/runtime}{syntax-externval}{\X{externval}}
 
 .. |moduleinst| mathdef:: \xref{exec/runtime}{syntax-moduleinst}{\X{moduleinst}}
+.. |typeinst| mathdef:: \xref{exec/runtime}{syntax-typeinst}{\X{typeinst}}
 .. |funcinst| mathdef:: \xref{exec/runtime}{syntax-funcinst}{\X{funcinst}}
 .. |tableinst| mathdef:: \xref{exec/runtime}{syntax-tableinst}{\X{tableinst}}
 .. |meminst| mathdef:: \xref{exec/runtime}{syntax-meminst}{\X{meminst}}
@@ -1109,6 +1111,7 @@
 
 .. Store, terminals
 
+.. |STYPES| mathdef:: \xref{exec/runtime}{syntax-store}{\K{types}}
 .. |SFUNCS| mathdef:: \xref{exec/runtime}{syntax-store}{\K{funcs}}
 .. |STABLES| mathdef:: \xref{exec/runtime}{syntax-store}{\K{tables}}
 .. |SMEMS| mathdef:: \xref{exec/runtime}{syntax-store}{\K{mems}}
@@ -1306,6 +1309,7 @@
 .. |vdashval| mathdef:: \xref{appendix/properties}{valid-val}{\vdash}
 .. |vdashresult| mathdef:: \xref{appendix/properties}{valid-result}{\vdash}
 
+.. |vdashtypeinst| mathdef:: \xref{appendix/properties}{valid-typeinst}{\vdash}
 .. |vdashfuncinst| mathdef:: \xref{appendix/properties}{valid-funcinst}{\vdash}
 .. |vdashtableinst| mathdef:: \xref{appendix/properties}{valid-tableinst}{\vdash}
 .. |vdashmeminst| mathdef:: \xref{appendix/properties}{valid-meminst}{\vdash}
@@ -1321,6 +1325,7 @@
 .. |vdashthread| mathdef:: \xref{appendix/properties}{valid-thread}{\vdash}
 .. |vdashframe| mathdef:: \xref{appendix/properties}{valid-frame}{\vdash}
 
+.. |vdashtypeinstextends| mathdef:: \xref{appendix/properties}{extend-typeinst}{\vdash}
 .. |vdashfuncinstextends| mathdef:: \xref{appendix/properties}{extend-funcinst}{\vdash}
 .. |vdashtableinstextends| mathdef:: \xref{appendix/properties}{extend-tableinst}{\vdash}
 .. |vdashmeminstextends| mathdef:: \xref{appendix/properties}{extend-meminst}{\vdash}
diff --git a/document/core/valid/conventions.rst b/document/core/valid/conventions.rst
index 5d1767e5..00e517dc 100644
--- a/document/core/valid/conventions.rst
+++ b/document/core/valid/conventions.rst
@@ -34,7 +34,7 @@ Validity of an individual definition is specified relative to a *context*,
 which collects relevant information about the surrounding :ref:`module <syntax-module>` and the definitions in scope:
 
 * *Types*: the list of :ref:`types <syntax-type>` defined in the current module.
-* *Functions*: the list of :ref:`functions <syntax-func>` declared in the current module, represented by their :ref:`function type <syntax-functype>`.
+* *Functions*: the list of :ref:`functions <syntax-func>` declared in the current module, represented by a :ref:`type identifier <syntax-typeid>` for their :ref:`function type <syntax-functype>`.
 * *Tables*: the list of :ref:`tables <syntax-table>` declared in the current module, represented by their :ref:`table type <syntax-tabletype>`.
 * *Memories*: the list of :ref:`memories <syntax-mem>` declared in the current module, represented by their :ref:`memory type <syntax-memtype>`.
 * *Globals*: the list of :ref:`globals <syntax-global>` declared in the current module, represented by their :ref:`global type <syntax-globaltype>`.
@@ -56,8 +56,8 @@ More concretely, contexts are defined as :ref:`records <notation-record>` :math:
    \begin{array}{llll}
    \production{context} & C &::=&
      \begin{array}[t]{l@{~}ll}
-     \{ & \CTYPES & \deftype^\ast, \\
-        & \CFUNCS & \functype^\ast, \\
+     \{ & \CTYPES & \functype^\ast, \\
+        & \CFUNCS & \typeid^\ast, \\
         & \CTABLES & \tabletype^\ast, \\
         & \CMEMS & \memtype^\ast, \\
         & \CGLOBALS & \globaltype^\ast, \\
diff --git a/document/core/valid/instructions.rst b/document/core/valid/instructions.rst
index 05581d4e..d8539c0b 100644
--- a/document/core/valid/instructions.rst
+++ b/document/core/valid/instructions.rst
@@ -1603,11 +1603,13 @@ Control Instructions
 
 * The :ref:`result type <syntax-resulttype>` :math:`[t_2^\ast]` must be the same as :math:`C.\CRETURN`.
 
-* Then the instruction is valid with any :ref:`valid <valid-instrtype>` type :math:`[t_3^\ast~t_1^\ast] \to [t_4^\ast]`.
+* Then the instruction is valid with type :math:`[t_3^\ast~t_1^\ast] \to [t_4^\ast]`, for any sequences of :ref:`value types <syntax-valtype>` :math:`t_3^\ast` and :math:`t_4^\ast`.
 
 .. math::
    \frac{
-     C.\CFUNCS[x] = [t_1^\ast] \toF C.\CRETURN
+     C.\CFUNCS[x] = [t_1^\ast] \toF [t_2^\ast]
+     \qquad
+     C.\CRETURN = [t_2^\ast]
    }{
      C \vdashinstr \RETURNCALL~x : [t_3^\ast~t_1^\ast] \to [t_4^\ast]
    }
@@ -1627,18 +1629,17 @@ Control Instructions
 
 * The :ref:`result type <syntax-resulttype>` :math:`[t_2^\ast]` must be the same as :math:`C.\CRETURN`.
 
-* Then the instruction is valid with any :ref:`valid <valid-instrtype>` type :math:`[t_3^\ast~t_1^\ast~(\REF~\NULL~x)] \to [t_4^\ast]`.
+* Then the instruction is valid with type :math:`[t_1^\ast~(\REF~\NULL~x)] \to [t_2^\ast]`.
 
 .. math::
    \frac{
-     C.\CTYPES[x] = [t_1^\ast] \toF C.\CRETURN
+     C.\CTYPES[x] = [t_1^\ast] \toF [t_2^\ast]
+     \qquad
+     C.\CRETURN = [t_2^\ast]
    }{
-     C \vdashinstr \CALLREF~x : [t_3^\ast~t_1^\ast~(\REF~\NULL~x)] \to [t_4^\ast]
+     C \vdashinstr \CALLREF~x : [t_1^\ast~(\REF~\NULL~x)] \to [t_2^\ast]
    }
 
-.. note::
-   The |RETURNCALLREF| instruction is :ref:`stack-polymorphic <polymorphism>`.
-
 
 .. _valid-return_call_indirect:
 
@@ -1661,11 +1662,14 @@ Control Instructions
 
 * Then the instruction is valid with type :math:`[t_3^\ast~t_1^\ast~\I32] \to [t_4^\ast]`, for any sequences of :ref:`value types <syntax-valtype>` :math:`t_3^\ast` and :math:`t_4^\ast`.
 
+
 .. math::
    \frac{
      C.\CTABLES[x] = \limits~\FUNCREF
      \qquad
-     C.\CTYPES[y] = [t_1^\ast] \toF C.\CRETURN
+     C.\CTYPES[y] = [t_1^\ast] \toF [t_2^\ast]
+     \qquad
+     C.\CRETURN = [t_2^\ast]
    }{
      C \vdashinstr \RETURNCALLINDIRECT~x~y : [t_3^\ast~t_1^\ast~\I32] \to [t_4^\ast]
    }
diff --git a/document/core/valid/matching.rst b/document/core/valid/matching.rst
index e6fededd..ac922955 100644
--- a/document/core/valid/matching.rst
+++ b/document/core/valid/matching.rst
@@ -54,13 +54,9 @@ A :ref:`heap type <syntax-heaptype>` :math:`\heaptype_1` matches a :ref:`heap ty
 
 * Either both :math:`\heaptype_1` and :math:`\heaptype_2` are the same.
 
-* Or :math:`\heaptype_1` is a :ref:`function type <syntax-functype>` and :math:`\heaptype_2` is :math:`FUNC`.
+* Or :math:`\heaptype_1` is a :ref:`type identifier <syntax-typeid>` that defines a function type and :math:`\heaptype_2` is :math:`FUNC`.
 
-* Or :math:`\heaptype_1` is a :ref:`function type <syntax-functype>` :math:`\functype_1` and :math:`\heaptype_2` is a :ref:`function type <syntax-functype>` :math:`\functype_2`, and :math:`\functype_1` :ref:`matches <match-functype>` :math:`\functype_2`.
-
-* Or :math:`\heaptype_1` is a :ref:`type index <syntax-typeidx>` :math:`x_1`, and :math:`C.\CTYPES[x_1]` :ref:`matches <match-heaptype>` :math:`\heaptype_2`.
-
-* Or :math:`\heaptype_2` is a :ref:`type index <syntax-typeidx>` :math:`x_2`, and :math:`\heaptype_1` :ref:`matches <match-heaptype>` :math:`C.\CTYPES[x_2]`.
+* Or :math:`\heaptype_1` is a :ref:`type identifier <syntax-typeid>` that defines a function type :math:`\functype_1`, and :math:`\heaptype_2` is a :ref:`type identifier <syntax-typeid>` that defines a function type :math:`\functype_2`, and :math:`\functype_1` :ref:`matches <match-functype>` :math:`\functype_2`.
 
 .. math::
    ~\\[-1ex]
@@ -70,34 +66,24 @@ A :ref:`heap type <syntax-heaptype>` :math:`\heaptype_1` matches a :ref:`heap ty
    }
    \qquad
    \frac{
+     C \vdashtypeid \typeid : \functype
    }{
-     C \vdashheaptypematch \functype \matchesheaptype \FUNC
+     C \vdashheaptypematch \typeid \matchesheaptype \FUNC
    }
 
 .. math::
    ~\\[-1ex]
    \frac{
+     C \vdashtypeid \typeid_1 : \functype_1
+     \qquad
+     C \vdashtypeid \typeid_2 : \functype_2
+     \qquad
      C \vdashfunctypematch \functype_1 \matchesfunctype \functype_2
    }{
-     C \vdashheaptypematch \functype_1 \matchesheaptype \functype_2
-   }
-
-.. math::
-   ~\\[-1ex]
-   \frac{
-     C \vdashheaptypematch C.\CTYPES[\typeidx_1] \matchesheaptype \heaptype_2
-   }{
-     C \vdashheaptypematch \typeidx_1 \matchesheaptype \heaptype_2
-   }
-   \qquad
-   \frac{
-     C \vdashheaptypematch \heaptype_1 \matchesheaptype C.\CTYPES[\typeidx_2]
-   }{
-     C \vdashheaptypematch \heaptype_1 \matchesheaptype \typeidx_2
+     C \vdashheaptypematch \typeid_1 \matchesheaptype \typeid_2
    }
 
 
-
 .. index:: reference type
 .. _match-reftype:
 
@@ -362,16 +348,16 @@ External Types
 Functions
 .........
 
-An :ref:`external type <syntax-externtype>` :math:`\ETFUNC~\functype_1` matches :math:`\ETFUNC~\functype_2` if and only if:
+An :ref:`external type <syntax-externtype>` :math:`\ETFUNC~\typeid_1` matches :math:`\ETFUNC~\typeid_2` if and only if:
 
-* The :ref:`function type <syntax-functype>` :math:`\functype_1` :ref:`matches <match-functype>` :math:`\functype_2`.
+* The :ref:`heap type <syntax-heaptype>` :math:`\typeid_1` :ref:`matches <match-heaptype>` :math:`\typeid_2`.
 
 .. math::
    ~\\[-1ex]
    \frac{
-     C \vdashfunctypematch \functype_1 \matchesfunctype \functype_2
+     C \vdashheaptypematch \typeid_1 \matchesheaptype \typeid_2
    }{
-     C \vdashexterntypematch \ETFUNC~\functype_1 \matchesexterntype \ETFUNC~\functype_2
+     C \vdashexterntypematch \ETFUNC~\typeid_1 \matchesexterntype \ETFUNC~\typeid_2
    }
 
 
diff --git a/document/core/valid/modules.rst b/document/core/valid/modules.rst
index f620103f..4419aa6d 100644
--- a/document/core/valid/modules.rst
+++ b/document/core/valid/modules.rst
@@ -428,9 +428,9 @@ Exports :math:`\export` and export descriptions :math:`\exportdesc` are classifi
 
 .. math::
    \frac{
-     C.\CFUNCS[x] = \functype
+     C.\CFUNCS[x] = \typeid
    }{
-     C \vdashexportdesc \EDFUNC~x : \ETFUNC~\functype
+     C \vdashexportdesc \EDFUNC~x : \ETFUNC~\typeid
    }
 
 
diff --git a/document/core/valid/types.rst b/document/core/valid/types.rst
index dc21aa29..d281885b 100644
--- a/document/core/valid/types.rst
+++ b/document/core/valid/types.rst
@@ -9,6 +9,36 @@ However, restrictions apply to most other types, such as :ref:`reference types <
 Moreover, :ref:`block types <syntax-blocktype>` are converted to plain :ref:`function types <syntax-functype>` for ease of processing.
 
 
+.. index:: type identifier, type index
+   pair: validation; type identifier
+   single: abstract syntax; type identifier
+.. _valid-typeid:
+.. _valid-typeidx:
+
+Type Identifiers
+~~~~~~~~~~~~~~~~
+
+During validation, :ref:`type identifiers <syntax-typeid>` are represented as :ref:`type indices <syntax-typeidx>`, which are lookued up as :ref:`function types <syntax-functype>` by the following rule.
+
+:math:`\typeidx`
+................
+
+* The type :math:`C.\CTYPES[\typeidx]` must be defined in the context.
+
+* Then the type identifier is valid as :ref:`function type <syntax-functype>` :math:`C.\CTYPES[\typeidx]`.
+
+.. math::
+   \frac{
+     C.\CTYPES[\typeidx] = \functype
+   }{
+     C \vdashtypeid \typeidx : \functype
+   }
+
+.. note::
+   :ref:`Dynamic types <syntax-type-dyn>` do not arise during validation.
+   They only need to be :ref:`looked up <valid-typeaddr>` during :ref:`execution <exec-type>`.
+
+
 .. index:: number type
    pair: validation; number type
    single: abstract syntax; number type
@@ -51,7 +81,7 @@ Vector Types
 Heap Types
 ~~~~~~~~~~
 
-Concrete :ref:`Heap types <syntax-heaptype>` are only valid when the :ref:`type index <syntax-typeidx>` is.
+Concrete :ref:`Heap types <syntax-heaptype>` are only valid when the :ref:`type identifier <syntax-typeid>` is.
 
 :math:`\FUNC`
 .............
@@ -75,18 +105,18 @@ Concrete :ref:`Heap types <syntax-heaptype>` are only valid when the :ref:`type
      C \vdashheaptype \EXTERN \ok
    }
 
-:math:`\typeidx`
-................
+:math:`\typeid`
+...............
 
-* The type :math:`C.\CTYPES[\typeidx]` must be defined in the context.
+* The type identifier :math:`\typeid` must be valid.
 
 * Then the heap type is valid.
 
 .. math::
    \frac{
-     C.\CTYPES[\typeidx] = \deftype
+     C \vdashtypeid \typeid : \functype
    }{
-     C \vdashheaptype \typeidx \ok
+     C \vdashheaptype \typeid \ok
    }
 
 :math:`\BOT`
@@ -248,7 +278,6 @@ Instruction Types
    pair: validation; function type
    single: abstract syntax; function type
 .. _valid-functype:
-.. _valid-deftype:
 
 Function Types
 ~~~~~~~~~~~~~~
diff --git a/document/js-api/index.bs b/document/js-api/index.bs
index c085e583..19faf7ed 100644
--- a/document/js-api/index.bs
+++ b/document/js-api/index.bs
@@ -37,12 +37,66 @@ urlPrefix: https://tc39.github.io/ecma262/; spec: ECMASCRIPT
         url: sec-returnifabrupt-shorthands
             text: !
             text: ?
-        text: Type; url: sec-ecmascript-data-types-and-values
+        text: agent cluster; url: sec-agent-clusters
+        text: agent; url: agent
+        text: data block; url: sec-data-blocks
+        text: Bound Function; url: sec-bound-function-exotic-objects
+        text: NumericLiteral; url: sec-literals-numeric-literals
+        text: surrounding agent; url: surrounding-agent
+        text: ToNumber; url: sec-tonumber
+        text: ToInt32; url: sec-toint32
+        text: ToString; url: sec-tostring
+        url: sec-ecmascript-data-types-and-values
+            text: Type
+            text: Type(x)
+        url: sec-iscallable
+            text: IsCallable
+            text: callable; for: ECMAScript
+        url: sec-well-known-intrinsic-objects
+            text: %ErrorPrototype%
+        text: %ObjectPrototype%; url: sec-properties-of-the-object-prototype-object
+        text: %Promise%; url: sec-promise-constructor
+        text: Property Descriptor; url: sec-property-descriptor-specification-type
+        text: array index; url: sec-array-exotic-objects
+        text: OrdinaryGetOwnProperty; url: sec-ordinarygetownproperty
+        text: OrdinaryDefineOwnProperty; url: sec-ordinarydefineownproperty
+        text: OrdinaryPreventExtensions; url: sec-ordinarypreventextensions
+        text: OrdinarySet; url: sec-ordinaryset
+        text: equally close values; url: sec-ecmascript-language-types-number-type
+        text: internal slot; url: sec-object-internal-methods-and-internal-slots
+        text: JavaScript execution context stack; url: execution-context-stack
+        text: running JavaScript execution context; url: running-execution-context
+        text: GetIterator; url: sec-getiterator
+        text: IteratorStep; url: sec-iteratorstep
+        text: NormalCompletion; url: sec-normalcompletion
+        text: IteratorValue; url: sec-iteratorvalue
+        url: sec-well-known-symbols
+            text: @@iterator
+            text: @@toStringTag
+        text: CreateDataProperty; url: sec-createdataproperty
+        text: DetachArrayBuffer; url: sec-detacharraybuffer
+        text: SetIntegrityLevel; url: sec-setintegritylevel
+        text: Call; url: sec-call
+        text: Get; url: sec-get-o-p
+        text: DefinePropertyOrThrow; url: sec-definepropertyorthrow
         text: current Realm; url: current-realm
+        text: ObjectCreate; url: sec-objectcreate
+        text: CreateBuiltinFunction; url: sec-createbuiltinfunction
+        text: SetFunctionName; url: sec-setfunctionname
+        text: SetFunctionLength; url: sec-setfunctionlength
+        text: the Number value; url: sec-ecmascript-language-types-number-type
+        text: NumberToRawBytes; url: sec-numbertorawbytes
         text: Built-in Function Objects; url: sec-built-in-function-objects
         text: NativeError Object Structure; url: sec-nativeerror-object-structure
+        text: CreateArrayFromList; url: sec-createarrayfromlist
+        text: GetMethod; url: sec-getmethod
+        text: IterableToList; url: sec-iterabletolist
+        text: ToBigInt64; url: #sec-tobigint64
+        text: BigInt; url: #sec-ecmascript-language-types-bigint-type
         text: 𝔽; url: #𝔽
         text: ℤ; url: #ℤ
+    type: abstract-op
+        text: CreateMethodProperty; url: sec-createmethodproperty
 urlPrefix: https://webassembly.github.io/spec/core/; spec: WebAssembly; type: dfn
     url: valid/modules.html#valid-module
         text: valid
@@ -313,11 +367,11 @@ A {{Module}} object represents a single WebAssembly module. Each {{Module}} obje
     1. If |module|.[=imports=] [=list/is empty|is not empty=], and |importObject| is undefined, throw a {{TypeError}} exception.
     1. Let |imports| be « ».
     1. [=list/iterate|For each=] (|moduleName|, |componentName|, |externtype|) of [=module_imports=](|module|),
-        1. Let |o| be [=?=] [$Get$](|importObject|, |moduleName|).
+        1. Let |o| be [=?=] [=Get=](|importObject|, |moduleName|).
         1. If [=Type=](|o|) is not Object, throw a {{TypeError}} exception.
-        1. Let |v| be [=?=] [$Get$](|o|, |componentName|).
+        1. Let |v| be [=?=] [=Get=](|o|, |componentName|).
         1. If |externtype| is of the form [=func=] |functype|,
-            1. If [$IsCallable$](|v|) is false, throw a {{LinkError}} exception.
+            1. If [=IsCallable=](|v|) is false, throw a {{LinkError}} exception.
             1. If |v| has a \[[FunctionAddress]] internal slot, and therefore is an [=Exported Function=],
                 1. Let |funcaddr| be the value of |v|'s \[[FunctionAddress]] internal slot.
             1. Otherwise,
@@ -361,7 +415,7 @@ The verification of WebAssembly type requirements is deferred to the
 
 <div algorithm>
   To <dfn>create an exports object</dfn> from a WebAssembly module |module| and instance |instance|, perform the following steps:
-    1. Let |exportsObject| be [=!=] [$OrdinaryObjectCreate$](null).
+    1. Let |exportsObject| be [=!=] [=ObjectCreate=](null).
     1. [=list/iterate|For each=] (|name|, |externtype|) of [=module_exports=](|module|),
         1. Let |externval| be [=instance_export=](|instance|, |name|).
         1. Assert: |externval| is not [=error=].
@@ -385,11 +439,11 @@ The verification of WebAssembly type requirements is deferred to the
             1. Let [=external value|table=] |tableaddr| be |externval|.
             1. Let |table| be [=create a Table object|a new Table object=] created from |tableaddr|.
             1. Let |value| be |table|.
-        1. Let |status| be [=!=] [$CreateDataProperty$](|exportsObject|, |name|, |value|).
+        1. Let |status| be [=!=] [=CreateDataProperty=](|exportsObject|, |name|, |value|).
         1. Assert: |status| is true.
 
         Note: the validity and uniqueness checks performed during [=WebAssembly module validation=] ensure that each property name is valid and no properties are defined twice.
-    1. Perform [=!=] [$SetIntegrityLevel$](|exportsObject|, `"frozen"`).
+    1. Perform [=!=] [=SetIntegrityLevel=](|exportsObject|, `"frozen"`).
     1. Return |exportsObject|.
 </div>
 
@@ -652,7 +706,7 @@ which can be simultaneously referenced by multiple {{Instance}} objects. Each
     1. Let |map| be the [=surrounding agent=]'s associated [=Memory object cache=].
     1. Assert: |map|[|memaddr|] [=map/exists=].
     1. Let |memory| be |map|[|memaddr|].
-    1. Perform [=!=] [$DetachArrayBuffer$](|memory|.\[[BufferObject]], "WebAssembly.Memory").
+    1. Perform [=!=] [=DetachArrayBuffer=](|memory|.\[[BufferObject]], "WebAssembly.Memory").
     1. Let |buffer| be the result of [=create a memory buffer|creating a memory buffer=] from |memaddr|.
     1. Set |memory|.\[[BufferObject]] to |buffer|.
 </div>
@@ -936,13 +990,13 @@ This slot holds a [=function address=] relative to the [=surrounding agent=]'s [
     1. Let |store| be the [=surrounding agent=]'s [=associated store=].
     1. Let |funcinst| be |store|.funcs[|funcaddr|].
     1. If |funcinst| is of the form {type <var ignore>functype</var>, hostcode |hostfunc|},
-        1. Assert: |hostfunc| is a JavaScript object and [$IsCallable$](|hostfunc|) is true.
+        1. Assert: |hostfunc| is a JavaScript object and [=IsCallable=](|hostfunc|) is true.
         1. Let |index| be the [=index of the host function=] |funcaddr|.
     1. Otherwise,
         1. Let |moduleinst| be |funcinst|.module.
         1. Assert: |funcaddr| is contained in |moduleinst|.funcaddrs.
         1. Let |index| be the index of |moduleinst|.funcaddrs where |funcaddr| is found.
-    1. Return [=!=] [$ToString$](|index|).
+    1. Return [=!=] [=ToString=](|index|).
 </div>
 
 <div algorithm>
@@ -958,7 +1012,7 @@ This slot holds a [=function address=] relative to the [=surrounding agent=]'s [
     1. Let [|paramTypes|] → [<var ignore>resultTypes</var>] be |functype|.
     1. Let |arity| be |paramTypes|'s [=list/size=].
     1. Let |name| be the [=name of the WebAssembly function=] |funcaddr|.
-    1. Let |function| be [=!=] [$CreateBuiltinFunction$](|steps|, |arity|, |name|, « \[[FunctionAddress]] », |realm|).
+    1. Let |function| be [=!=] [=CreateBuiltinFunction=](|steps|, |arity|, |name|, « \[[FunctionAddress]] », |realm|).
     1. Set |function|.\[[FunctionAddress]] to |funcaddr|.
     1. [=map/Set=] |map|[|funcaddr|] to |function|.
     1. Return |function|.
@@ -990,7 +1044,7 @@ This slot holds a [=function address=] relative to the [=surrounding agent=]'s [
         1. Let |values| be « ».
         1. [=list/iterate|For each=] |r| of |ret|,
             1. [=list/Append=] [=ToJSValue=](|r|) to |values|.
-        1. Return [$CreateArrayFromList$](|values|).
+        1. Return [=CreateArrayFromList=](|values|).
 </div>
 
 Note: [=call an Exported Function|Calling an Exported Function=] executes in the \[[Realm]] of the callee Exported Function, as per the definition of [=built-in function objects=].
@@ -1005,14 +1059,14 @@ Note: Exported Functions do not have a \[[Construct]] method and thus it is not
     1. Let |jsArguments| be « ».
     1. [=list/iterate|For each=] |arg| of |arguments|,
         1. [=list/Append=] [=!=] [=ToJSValue=](|arg|) to |jsArguments|.
-    1. Let |ret| be [=?=] [$Call$](|func|, undefined, |jsArguments|).
+    1. Let |ret| be [=?=] [=Call=](|func|, undefined, |jsArguments|).
     1. Let |resultsSize| be |results|'s [=list/size=].
     1. If |resultsSize| is 0, return « ».
     1. Otherwise, if |resultsSize| is 1, return « [=?=] [=ToWebAssemblyValue=](|ret|, |results|[0]) ».
     1. Otherwise,
-        1. Let |method| be [=?=] [$GetMethod$](|ret|, {{@@iterator}}).
+        1. Let |method| be [=?=] [=GetMethod=](|ret|, [=@@iterator=]).
         1. If |method| is undefined, [=throw=] a {{TypeError}}.
-        1. Let |values| be [=?=] [$IterableToList$](|ret|, |method|).
+        1. Let |values| be [=?=] [=IterableToList=](|ret|, |method|).
         1. Let |wasmValues| be a new, empty [=list=].
         1. If |values|'s [=list/size=] is not |resultsSize|, throw a {{TypeError}} exception.
         1. For each |value| and |resultType| in |values| and |results|, paired linearly,
@@ -1023,11 +1077,11 @@ Note: Exported Functions do not have a \[[Construct]] method and thus it is not
 <div algorithm>
   To <dfn>create a host function</dfn> from the JavaScript object |func| and type |functype|, perform the following steps:
 
-    1. Assert: [$IsCallable$](|func|).
+    1. Assert: [=IsCallable=](|func|).
     1. Let |stored settings| be the <a spec=HTML>incumbent settings object</a>.
     1. Let |hostfunc| be a [=host function=] which performs the following steps when called with arguments |arguments|:
         1. Let |realm| be |func|'s [=associated Realm=].
-        1. Let |relevant settings| be |realm|'s [=realm/settings object=].
+        1. Let |relevant settings| be |realm|'s [=Realm/settings object=].
         1. [=Prepare to run script=] with |relevant settings|.
         1. [=Prepare to run a callback=] with |stored settings|.
         1. Let |result| be the result of [=run a host function|running a host function=] from |func|, |functype|, and |arguments|.
@@ -1062,7 +1116,7 @@ The algorithm <dfn>ToJSValue</dfn>(|w|) coerces a [=WebAssembly value=] to a Jav
 1. If |w| is of the form [=ref.func=] |funcaddr|, return the result of creating [=a new Exported Function=] from |funcaddr|.
 1. If |w| is of the form [=ref.extern=] |externaddr|, return the result of [=retrieving an extern value=] from |externaddr|.
 
-Note: Number values which are equal to NaN may have various observable NaN payloads; see [$NumericToRawBytes$] for details.
+Note: Number values which are equal to NaN may have various observable NaN payloads; see [=NumberToRawBytes=] for details.
 </div>
 
 <div algorithm>
@@ -1080,13 +1134,13 @@ The algorithm <dfn>ToWebAssemblyValue</dfn>(|v|, |type|) coerces a JavaScript va
 
 1. Assert: |type| is not [=v128=].
 1. If |type| is [=i64=],
-    1. Let |i64| be [=?=] [$ToBigInt64$](|v|).
+    1. Let |i64| be [=?=] [=ToBigInt64=](|v|).
     1. Return [=i64.const=] |i64|.
 1. If |type| is [=i32=],
-    1. Let |i32| be [=?=] [$ToInt32$](|v|).
+    1. Let |i32| be [=?=] [=ToInt32=](|v|).
     1. Return [=i32.const=] |i32|.
 1. If |type| is [=f32=],
-    1. Let |number| be [=?=] [$ToNumber$](|v|).
+    1. Let |number| be [=?=] [=ToNumber=](|v|).
     1. If |number| is **NaN**,
         1. Let |n| be an implementation-defined integer such that [=canon=]<sub>32</sub> ≤ |n| < 2<sup>[=signif=](32)</sup>.
         1. Let |f32| be [=nan=](n).
@@ -1094,7 +1148,7 @@ The algorithm <dfn>ToWebAssemblyValue</dfn>(|v|, |type|) coerces a JavaScript va
         1. Let |f32| be |number| rounded to the nearest representable value using IEEE 754-2008 round to nearest, ties to even mode. [[IEEE-754]]
     1. Return [=f32.const=] |f32|.
 1. If |type| is [=f64=],
-    1. Let |number| be [=?=] [$ToNumber$](|v|).
+    1. Let |number| be [=?=] [=ToNumber=](|v|).
     1. If |number| is **NaN**,
         1. Let |n| be an implementation-defined integer such that [=canon=]<sub>64</sub> ≤ |n| < 2<sup>[=signif=](64)</sup>.
         1. Let |f64| be [=nan=](n).
diff --git a/interpreter/dune-project b/dune-project
similarity index 100%
rename from interpreter/dune-project
rename to dune-project
diff --git a/interpreter/Makefile b/interpreter/Makefile
index 3294e268..97e6e17c 100644
--- a/interpreter/Makefile
+++ b/interpreter/Makefile
@@ -41,12 +41,10 @@ all:		unopt opt libunopt libopt test
 land:		$(WINMAKE) all
 zip: 		$(ZIP)
 smallint:	smallint.native
-ci:			land wast.js dunebuild
 
 dunebuild:
 	dune build
 
-
 # Building executable
 
 empty =
@@ -177,7 +175,6 @@ smallinttest:	smallint
 dunetest:
 	dune test
 
-
 # Miscellaneous targets
 
 .PHONY:		clean
diff --git a/interpreter/README.md b/interpreter/README.md
index 0c763f75..34387532 100644
--- a/interpreter/README.md
+++ b/interpreter/README.md
@@ -15,7 +15,7 @@ The text format defines modules in S-expression syntax. Moreover, it is generali
 
 ## Building
 
-You'll need OCaml 4.12 or higher. Instructions for installing a recent version of OCaml on multiple platforms are available [here](https://ocaml.org/docs/install.html). On most platforms, the recommended way is through [OPAM](https://ocaml.org/docs/install.html#OPAM).
+You'll need OCaml 4.08 or higher. Instructions for installing a recent version of OCaml on multiple platforms are available [here](https://ocaml.org/docs/install.html). On most platforms, the recommended way is through [OPAM](https://ocaml.org/docs/install.html#OPAM).
 
 Once you have OCaml, simply do
 
@@ -253,15 +253,14 @@ op:
   br <var>
   br_if <var>
   br_table <var>+
-  br_on_null <var>
-  br_on_non_null <var>
+  br_on_null <var> <heap_type>
   call <var>
   call_ref <var>
-  call_indirect <var>? (type <var>)? <func_type>
+  call_indirect <var>? <func_type>
   return
   return_call <var>
   return_call_ref <var>
-  return_call_indirect <var>? (type <var>)? <func_type>
+  return_call_indirect <var>? <func_type>
   local.get <var>
   local.set <var>
   local.tee <var>
@@ -288,8 +287,8 @@ op:
   memory.init <var>
   data.drop <var>
   ref.null <heap_type>
-  ref.is_null
-  ref_as_non_null
+  ref.is_null <heap_type>
+  ref_as_non_null <heap_type>
   ref.func <var>
   <num_type>.const <num>
   <num_type>.<unop>
diff --git a/interpreter/binary/decode.ml b/interpreter/binary/decode.ml
index 8fa6db0b..c64a757d 100644
--- a/interpreter/binary/decode.ml
+++ b/interpreter/binary/decode.ml
@@ -144,6 +144,8 @@ let sized f s =
 
 open Types
 
+let zero s = expect 0x00 s "zero byte expected"
+
 let num_type s =
   match s7 s with
   | -0x01 -> I32T
@@ -166,7 +168,7 @@ let var_type s =
 let heap_type s =
   let pos = pos s in
   either [
-    (fun s -> VarHT (StatX (var_type s)));
+    (fun s -> DefHT (Stat (var_type s)));
     (fun s ->
       match s7 s with
       | -0x10 -> FuncHT
@@ -198,9 +200,13 @@ let func_type s =
   let ts2 = result_type s in
   FuncT (ts1, ts2)
 
+let cont_type s =
+  ContT (Stat (var_type s))
+
 let def_type s =
   match s7 s with
   | -0x20 -> DefFuncT (func_type s)
+  | -0x23 -> DefContT (cont_type s) (* TODO(dhil): See comment in encode.ml *)
   | _ -> error s (pos s - 1) "malformed definition type"
 
 
@@ -219,6 +225,11 @@ let memory_type s =
   let lim = limits u32 s in
   MemoryT lim
 
+let tag_type s =
+  zero s;
+  let x = Stat (var_type s) in
+  TagT x
+
 let mutability s =
   match byte s with
   | 0 -> Cons
@@ -236,11 +247,11 @@ let global_type s =
 open Ast
 open Operators
 
+
 let var s = u32 s
 
 let op s = byte s
 let end_ s = expect 0x0b s "END opcode expected"
-let zero s = expect 0x00 s "zero byte expected"
 
 let memop s =
   let align = u32 s in
@@ -255,6 +266,11 @@ let block_type s =
     (fun s -> ValBlockType (Some (val_type s)));
   ] s
 
+let var_pair s =
+  let x = at var s in
+  let y = at var s in
+  x, y
+
 let local s =
   let n = u32 s in
   let t = at val_type s in
@@ -299,7 +315,32 @@ let rec instr s =
     end
 
   | 0x05 -> error s pos "misplaced ELSE opcode"
-  | 0x06| 0x07 | 0x08 | 0x09 | 0x0a as b -> illegal s pos b
+
+  | 0x06 ->
+    let bt = block_type s in
+    let es = instr_block s in
+    let ct = catch_list s in
+    let ca =
+      if peek s = Some 0x19 then begin
+        ignore (byte s);
+        Some (instr_block s)
+      end else
+        None
+    in
+    if ct <> [] || ca <> None then begin
+      end_ s;
+      try_catch bt es ct ca
+    end else begin
+      match op s with
+      | 0x0b -> try_catch bt es [] None
+      | 0x18 -> try_delegate bt es (at var s)
+      | b -> illegal s pos b
+    end
+  | 0x07 -> error s pos "misplaced CATCH opcode"
+  | 0x08 -> throw (at var s)
+  | 0x09 -> rethrow (at var s)
+
+  | 0x0a as b -> illegal s pos b
   | 0x0b -> error s pos "misplaced END opcode"
 
   | 0x0c -> br (at var s)
@@ -324,9 +365,10 @@ let rec instr s =
   | 0x14 -> call_ref (at var s)
   | 0x15 -> return_call_ref (at var s)
 
-  | 0x16 as b -> illegal s pos b
+  | (0x16 | 0x17) as b -> illegal s pos b
 
-  | 0x17 | 0x18 | 0x19 as b -> illegal s pos b
+  | 0x18 -> error s pos "misplaced DELEGATE opcode"
+  | 0x19 -> error s pos "misplaced CATCH_ALL opcode"
 
   | 0x1a -> drop
   | 0x1b -> select None
@@ -527,6 +569,27 @@ let rec instr s =
   | 0xd5 as b -> illegal s pos b
   | 0xd6 -> br_on_non_null (at var s)
 
+  | 0xe0 -> cont_new (at var s)
+  | 0xe1 ->
+    let x = at var s in
+    let y = at var s in
+    cont_bind x y
+  | 0xe2 -> suspend (at var s)
+  | 0xe3 ->
+    let x = at var s in
+    let xls = vec var_pair s in
+    resume x xls
+  | 0xe4 ->
+    let x   = at var s in
+    let tag = at var s in
+    let xls = vec var_pair s in
+    resume_throw x tag xls
+  | 0xe5 ->
+    let bt = block_type s in
+    let es' = instr_block s in
+    end_ s;
+    barrier bt es'
+
   | 0xfc as b ->
     (match u32 s with
     | 0x00l -> i32_trunc_sat_f32_s
@@ -831,11 +894,19 @@ let rec instr s =
 and instr_block s = List.rev (instr_block' s [])
 and instr_block' s es =
   match peek s with
-  | None | Some (0x05 | 0x0b) -> es
+  | None | Some (0x05 | 0x07 | 0x0b | 0x19) -> es
   | _ ->
     let pos = pos s in
     let e' = instr s in
-    instr_block' s ((e' @@ region s pos pos) :: es)
+    instr_block' s (Source.(e' @@ region s pos pos) :: es)
+and catch_list s =
+  if peek s = Some 0x07 then begin
+    ignore (byte s);
+    let tag = at var s in
+    let instrs = instr_block s in
+    (tag, instrs) :: catch_list s
+  end else
+    []
 
 let const s =
   let c = at instr_block s in
@@ -862,6 +933,7 @@ let id s =
     | 10 -> `CodeSection
     | 11 -> `DataSection
     | 12 -> `DataCountSection
+    | 13 -> `TagSection
     | _ -> error s (pos s) "malformed section id"
     ) bo
 
@@ -890,6 +962,7 @@ let import_desc s =
   | 0x01 -> TableImport (table_type s)
   | 0x02 -> MemoryImport (memory_type s)
   | 0x03 -> GlobalImport (global_type s)
+  | 0x04 -> TagImport (tag_type s)
   | _ -> error s (pos s - 1) "malformed import kind"
 
 let import s =
@@ -940,6 +1013,16 @@ let memory_section s =
   section `MemorySection (vec (at memory)) [] s
 
 
+(* Tag section *)
+
+let tag s =
+  let tagtype = tag_type s in
+  {tagtype}
+
+let tag_section s =
+  section `TagSection (vec (at tag)) [] s
+
+
 (* Global section *)
 
 let global s =
@@ -959,6 +1042,7 @@ let export_desc s =
   | 0x01 -> TableExport (at var s)
   | 0x02 -> MemoryExport (at var s)
   | 0x03 -> GlobalExport (at var s)
+  | 0x04 -> TagExport (at var s)
   | _ -> error s (pos s - 1) "malformed export kind"
 
 let export s =
@@ -1135,6 +1219,8 @@ let module_ s =
   iterate custom_section s;
   let memories = memory_section s in
   iterate custom_section s;
+  let tags = tag_section s in
+  iterate custom_section s;
   let globals = global_section s in
   iterate custom_section s;
   let exports = export_section s in
@@ -1159,7 +1245,7 @@ let module_ s =
     s (len s) "data count section required";
   let funcs =
     List.map2 (fun t f -> {f.it with ftype = t} @@ f.at) func_types func_bodies
-  in {types; tables; memories; globals; funcs; imports; exports; elems; datas; start}
+  in {types; tables; memories; tags; globals; funcs; imports; exports; elems; datas; start}
 
 
 let decode name bs = at module_ (stream name bs)
diff --git a/interpreter/binary/encode.ml b/interpreter/binary/encode.ml
index 62110351..0c65cdbd 100644
--- a/interpreter/binary/encode.ml
+++ b/interpreter/binary/encode.ml
@@ -96,7 +96,8 @@ struct
   open Types
 
   let var_type = function
-    | StatX x -> s33 x
+    | Stat x -> s33 x
+    | Dyn _ -> assert false
 
   let num_type = function
     | I32T -> s7 (-0x01)
@@ -110,8 +111,8 @@ struct
   let heap_type = function
     | FuncHT -> s7 (-0x10)
     | ExternHT -> s7 (-0x11)
-    | VarHT x -> var_type x
-    | DefHT _ | BotHT -> assert false
+    | DefHT x -> var_type x
+    | BotHT -> assert false
 
   let ref_type = function
     | (Null, FuncHT) -> s7 (-0x10)
@@ -128,8 +129,15 @@ struct
   let func_type = function
     | FuncT (ts1, ts2) -> vec val_type ts1; vec val_type ts2
 
+  let cont_type = function
+    | ContT x -> var_type x
+
   let def_type = function
     | DefFuncT ft -> s7 (-0x20); func_type ft
+    | DefContT ct -> s7 (-0x23); cont_type ct
+    (* TODO(dhil): This might need to change again in the future as a
+       different proposal might claim this opcode! GC proposal claimed
+       the previous opcode we were using. *)
 
   let limits vu {min; max} =
     bool (max <> None); vu min; opt vu max
@@ -147,6 +155,8 @@ struct
   let global_type = function
     | GlobalT (mut, t) -> val_type t; mutability mut
 
+  let tag_type (TagT x) =
+    u32 0x00l; var_type x
 
   (* Instructions *)
 
@@ -163,6 +173,7 @@ struct
   let memop {align; offset; _} = u32 (Int32.of_int align); u32 offset
 
   let var x = u32 x.it
+  let var_pair (x, y) = var x; var y
 
   let block_type = function
     | ValBlockType None -> s33 (-0x40l)
@@ -190,6 +201,23 @@ struct
       if es2 <> [] then op 0x05;
       list instr es2; end_ ()
 
+    | TryCatch (bt, es, ct, ca) ->
+      op 0x06; block_type bt; list instr es;
+      let catch (tag, es) =
+        op 0x07; var tag; list instr es
+      in
+      list catch ct;
+      begin match ca with
+        | None -> ()
+        | Some es -> op 0x19; list instr es
+      end;
+      end_ ()
+    | TryDelegate (bt, es, x) ->
+      op 0x06; block_type bt; list instr es;
+      op 0x18; var x
+    | Throw x -> op 0x08; var x
+    | Rethrow x -> op 0x09; var x
+
     | Br x -> op 0x0c; var x
     | BrIf x -> op 0x0d; var x
     | BrTable (xs, x) -> op 0x0e; vec var xs; var x
@@ -203,6 +231,14 @@ struct
     | ReturnCallRef x -> op 0x15; var x
     | ReturnCallIndirect (x, y) -> op 0x13; var y; var x
 
+
+    | ContNew x -> op 0xe0; var x
+    | ContBind (x, y) -> op 0xe1; var x; var y
+    | Suspend x -> op 0xe2; var x
+    | Resume (x, xls) -> op 0xe3; var x; vec var_pair xls
+    | ResumeThrow (x, y, xls) -> op 0xe4; var x; var y; vec var_pair xls
+    | Barrier (bt, es) -> op 0xe5; block_type bt; list instr es; end_ ()
+
     | Drop -> op 0x1a
     | Select None -> op 0x1b
     | Select (Some ts) -> op 0x1c; vec val_type ts
@@ -780,6 +816,7 @@ struct
     | TableImport t -> byte 0x01; table_type t
     | MemoryImport t -> byte 0x02; memory_type t
     | GlobalImport t -> byte 0x03; global_type t
+    | TagImport t -> byte 0x04; tag_type t
 
   let import im =
     let {module_name; item_name; idesc} = im.it in
@@ -829,6 +866,12 @@ struct
   let global_section gs =
     section 6 (vec global) gs (gs <> [])
 
+  (* Tag section *)
+  let tag tag =
+    tag_type tag.it.tagtype
+
+  let tag_section ts =
+    section 13 (vec tag) ts (ts <> [])
 
   (* Export section *)
 
@@ -838,6 +881,7 @@ struct
     | TableExport x -> byte 1; var x
     | MemoryExport x -> byte 2; var x
     | GlobalExport x -> byte 3; var x
+    | TagExport x -> byte 4; var x
 
   let export ex =
     let {name = n; edesc} = ex.it in
@@ -964,6 +1008,7 @@ struct
     func_section m.it.funcs;
     table_section m.it.tables;
     memory_section m.it.memories;
+    tag_section m.it.tags;
     global_section m.it.globals;
     export_section m.it.exports;
     start_section m.it.start;
diff --git a/interpreter/exec/eval.ml b/interpreter/exec/eval.ml
index 4a886fe7..22742cd5 100644
--- a/interpreter/exec/eval.ml
+++ b/interpreter/exec/eval.ml
@@ -10,13 +10,17 @@ open Instance
 
 module Link = Error.Make ()
 module Trap = Error.Make ()
-module Crash = Error.Make ()
+module Exception = Error.Make ()
+module Suspension = Error.Make ()
 module Exhaustion = Error.Make ()
+module Crash = Error.Make ()
 
 exception Link = Link.Error
 exception Trap = Trap.Error
-exception Crash = Crash.Error (* failure that cannot happen in valid code *)
+exception Exception = Exception.Error
+exception Suspension = Suspension.Error
 exception Exhaustion = Exhaustion.Error
+exception Crash = Crash.Error (* failure that cannot happen in valid code *)
 
 let table_error at = function
   | Table.Bounds -> "out of bounds table access"
@@ -43,7 +47,7 @@ let numeric_error at = function
   | exn -> raise exn
 
 
-(* Administrative Expressions & Configurations *)
+(* Administrative Expressions & Continuations *)
 
 type 'a stack = 'a list
 
@@ -60,12 +64,51 @@ and admin_instr' =
   | Plain of instr'
   | Refer of ref_
   | Invoke of func_inst
+  | Label of int32 * instr list * code
+  | Frame of int32 * frame * code
+  | Handle of (tag_inst * idx) list option * code
   | Trapping of string
+  | Throwing of tag_inst * value stack
+  | Rethrowing of int32 * (admin_instr -> admin_instr)
+  | Suspending of tag_inst * value stack * ctxt
   | Returning of value stack
   | ReturningInvoke of value stack * func_inst
   | Breaking of int32 * value stack
-  | Label of int * instr list * code
-  | Frame of int * frame * code
+  | Catch of int32 * (Tag.t * instr list) list * instr list option * code
+  | Caught of int32 * Tag.t * value stack * code
+  | Delegate of int32 * code
+  | Delegating of int32 * Tag.t * value stack
+
+and ctxt = code -> code
+
+type cont = int32 * ctxt  (* TODO: represent type properly *)
+type ref_ += ContRef of cont option ref
+
+let () =
+  let type_of_ref' = !Value.type_of_ref' in
+  Value.type_of_ref' := function
+    | ContRef _ -> BotHT  (* TODO *)
+    | r -> type_of_ref' r
+
+let () =
+  let string_of_ref' = !Value.string_of_ref' in
+  Value.string_of_ref' := function
+    | ContRef _ -> "cont"
+    | r -> string_of_ref' r
+
+let plain e = Plain e.it @@ e.at
+
+let is_jumping e =
+  match e.it with
+  | Trapping _ | Throwing _ | Suspending _
+  | Returning _ | ReturningInvoke _ | Breaking _ ->
+    true
+  | _ -> false
+
+let compose (vs1, es1) (vs2, es2) = vs1 @ vs2, es1 @ es2
+
+
+(* Configurations *)
 
 type config =
 {
@@ -78,13 +121,6 @@ let frame inst locals = {inst; locals}
 let config inst vs es =
   {frame = frame inst []; code = vs, es; budget = !Flags.budget}
 
-let plain e = Plain e.it @@ e.at
-
-let is_jumping e =
-  match e.it with
-  | Trapping _ | Returning _ | ReturningInvoke _ | Breaking _ -> true
-  | _ -> false
-
 let lookup category list x =
   try Lib.List32.nth list x.it with Failure _ ->
     Crash.error x.at ("undefined " ^ category ^ " " ^ Int32.to_string x.it)
@@ -94,14 +130,13 @@ let func (inst : module_inst) x = lookup "function" inst.funcs x
 let table (inst : module_inst) x = lookup "table" inst.tables x
 let memory (inst : module_inst) x = lookup "memory" inst.memories x
 let global (inst : module_inst) x = lookup "global" inst.globals x
+let tag (inst : module_inst) x = lookup "tag" inst.tags x
 let elem (inst : module_inst) x = lookup "element segment" inst.elems x
 let data (inst : module_inst) x = lookup "data segment" inst.datas x
 let local (frame : frame) x = lookup "local" frame.locals x
 
-let subst_of (inst : module_inst) (StatX x) =
-  DefHT (type_ inst (x @@ Source.no_region))
-
-let func_type (inst : module_inst) x = as_func_def_type (type_ inst x)
+let func_type (inst : module_inst) x = as_func_def_type (def_of (type_ inst x))
+let cont_type (inst : module_inst) x = as_cont_def_type (def_of (type_ inst x))
 
 let any_ref (inst : module_inst) x i at =
   try Table.load (table inst x) i with Table.Bounds ->
@@ -116,15 +151,15 @@ let func_ref (inst : module_inst) x i at =
 let block_type (inst : module_inst) bt at =
   match bt with
   | ValBlockType None -> InstrT ([], [], [])
-  | ValBlockType (Some t) -> InstrT ([], [subst_val_type (subst_of inst) t], [])
+  | ValBlockType (Some t) -> InstrT ([], [dyn_val_type inst.types t], [])
   | VarBlockType x ->
     let FuncT (ts1, ts2) = func_type inst x in InstrT (ts1, ts2, [])
 
 let take n (vs : 'a stack) at =
-  try Lib.List.take n vs with Failure _ -> Crash.error at "stack underflow"
+  try Lib.List32.take n vs with Failure _ -> Crash.error at "stack underflow"
 
 let drop n (vs : 'a stack) at =
-  try Lib.List.drop n vs with Failure _ -> Crash.error at "stack underflow"
+  try Lib.List32.drop n vs with Failure _ -> Crash.error at "stack underflow"
 
 let split n (vs : 'a stack) at = take n vs at, drop n vs at
 
@@ -163,7 +198,7 @@ let rec step (c : config) : config =
     match e.it, vs with
     | Plain e', vs ->
       (match e', vs with
-      | Unreachable, vs ->
+       | Unreachable, vs ->
         vs, [Trapping "unreachable executed" @@ e.at]
 
       | Nop, vs ->
@@ -171,14 +206,14 @@ let rec step (c : config) : config =
 
       | Block (bt, es'), vs ->
         let InstrT (ts1, ts2, _xs) = block_type c.frame.inst bt e.at in
-        let n1 = List.length ts1 in
-        let n2 = List.length ts2 in
+        let n1 = Lib.List32.length ts1 in
+        let n2 = Lib.List32.length ts2 in
         let args, vs' = take n1 vs e.at, drop n1 vs e.at in
         vs', [Label (n2, [], (args, List.map plain es')) @@ e.at]
 
       | Loop (bt, es'), vs ->
         let InstrT (ts1, ts2, _xs) = block_type c.frame.inst bt e.at in
-        let n1 = List.length ts1 in
+        let n1 = Lib.List32.length ts1 in
         let args, vs' = take n1 vs e.at, drop n1 vs e.at in
         vs', [Label (n1, [e' @@ e.at], (args, List.map plain es')) @@ e.at]
 
@@ -188,6 +223,31 @@ let rec step (c : config) : config =
         else
           vs', [Plain (Block (bt, es1)) @@ e.at]
 
+      | Throw x, vs ->
+        let tagt = tag c.frame.inst x in
+        let TagT x' = Tag.type_of tagt in
+        let FuncT (ts, _) = as_func_def_type (def_of (as_dyn_var x')) in
+        let vs0, vs' = split (Lib.List32.length ts) vs e.at in
+        vs', [Throwing (tagt, vs0) @@ e.at]
+
+      | Rethrow x, vs ->
+        vs, [Rethrowing (x.it, fun e -> e) @@ e.at]
+
+      | TryCatch (bt, es', cts, ca), vs ->
+        let InstrT (ts1, ts2, _xs) = block_type c.frame.inst bt e.at in
+        let n1 = Lib.List32.length ts1 in
+        let n2 = Lib.List32.length ts2 in
+        let args, vs' = take n1 vs e.at, drop n1 vs e.at in
+        let cts' = List.map (fun (x, es'') -> ((tag c.frame.inst x), es'')) cts in
+        vs', [Label (n2, [], ([], [Catch (n2, cts', ca, (args, List.map plain es')) @@ e.at])) @@ e.at]
+
+      | TryDelegate (bt, es', x), vs ->
+        let InstrT (ts1, ts2, _xs) = block_type c.frame.inst bt e.at in
+        let n1 = Lib.List32.length ts1 in
+        let n2 = Lib.List32.length ts2 in
+        let args, vs' = take n1 vs e.at, drop n1 vs e.at in
+        vs', [Label (n2, [], ([], [Delegate (x.it, (args, List.map plain es')) @@ e.at])) @@ e.at]
+
       | Br x, vs ->
         [], [Breaking (x.it, vs) @@ e.at]
 
@@ -234,7 +294,7 @@ let rec step (c : config) : config =
       | CallIndirect (x, y), Num (I32 i) :: vs ->
         let f = func_ref c.frame.inst x i e.at in
         if
-          Match.eq_func_type (func_type c.frame.inst y) (Func.type_of f)
+          Match.eq_func_type [] (func_type c.frame.inst y) (Func.type_of f)
         then
           vs, [Invoke f @@ e.at]
         else
@@ -250,6 +310,74 @@ let rec step (c : config) : config =
         | _ -> assert false
         )
 
+      | ContNew x, Ref (NullRef _) :: vs ->
+        vs, [Trapping "null function reference" @@ e.at]
+
+      | ContNew x, Ref (FuncRef f) :: vs ->
+        let FuncT (ts, _) = Func.type_of f in
+        let ctxt code = compose code ([], [Invoke f @@ e.at]) in
+        Ref (ContRef (ref (Some (Lib.List32.length ts, ctxt)))) :: vs, []
+
+      | ContBind (x, y), Ref (NullRef _) :: vs ->
+        vs, [Trapping "null continuation reference" @@ e.at]
+
+      | ContBind (x, y), Ref (ContRef {contents = None}) :: vs ->
+        vs, [Trapping "continuation already consumed" @@ e.at]
+
+      | ContBind (x, y), Ref (ContRef ({contents = Some (n, ctxt)} as cont)) :: vs ->
+        let ContT z = cont_type c.frame.inst y in
+        let FuncT (ts', _) = as_func_def_type (def_of (as_dyn_var z)) in
+        let args, vs' =
+          try split (Int32.sub n (Lib.List32.length ts')) vs e.at
+          with Failure _ -> Crash.error e.at "type mismatch at continuation bind"
+        in
+        cont := None;
+        let ctxt' code = ctxt (compose code (args, [])) in
+        Ref (ContRef (ref (Some (Int32.sub n (Lib.List32.length args), ctxt')))) :: vs', []
+
+      | Suspend x, vs ->
+        let tagt = tag c.frame.inst x in
+        let TagT x' = Tag.type_of tagt in
+        let FuncT (ts, _) = as_func_def_type (def_of (as_dyn_var x')) in
+        let args, vs' = split (Lib.List32.length ts) vs e.at in
+        vs', [Suspending (tagt, args, fun code -> code) @@ e.at]
+
+      | Resume (x, xls), Ref (NullRef _) :: vs ->
+        vs, [Trapping "null continuation reference" @@ e.at]
+
+      | Resume (x, xls), Ref (ContRef {contents = None}) :: vs ->
+        vs, [Trapping "continuation already consumed" @@ e.at]
+
+      | Resume (x, xls), Ref (ContRef ({contents = Some (n, ctxt)} as cont)) :: vs ->
+        let hs = List.map (fun (x, l) -> tag c.frame.inst x, l) xls in
+        let args, vs' = split n vs e.at in
+        cont := None;
+        vs', [Handle (Some hs, ctxt (args, [])) @@ e.at]
+
+      | ResumeThrow (x, y, xls), Ref (NullRef _) :: vs ->
+        vs, [Trapping "null continuation reference" @@ e.at]
+
+      | ResumeThrow (x, y, xls), Ref (ContRef {contents = None}) :: vs ->
+        vs, [Trapping "continuation already consumed" @@ e.at]
+
+      | ResumeThrow (x, y, xls), Ref (ContRef ({contents = Some (n, ctxt)} as cont)) :: vs ->
+        let tagt = tag c.frame.inst y in
+        let TagT x' = Tag.type_of tagt in
+        let FuncT (ts, _) = as_func_def_type (def_of (as_dyn_var x')) in
+        let hs = List.map (fun (x, l) -> tag c.frame.inst x, l) xls in
+        let args, vs' = split (Lib.List32.length ts) vs e.at in
+        cont := None;
+        vs', [Handle (Some hs, ctxt (args, [Plain (Throw x) @@ e.at])) @@ e.at]
+
+      | Barrier (bt, es'), vs ->
+        let InstrT (ts1, _, _xs) = block_type c.frame.inst bt e.at in
+        let args, vs' = split (Lib.List32.length ts1) vs e.at in
+        vs', [
+          Handle (None,
+            (args, [Plain (Block (bt, es')) @@ e.at])
+          ) @@ e.at
+        ]
+
       | ReturnCall x, vs ->
         (match (step {c with code = (vs, [Plain (Call x) @@ e.at])}).code with
         | vs', [{it = Invoke a; at}] -> vs', [ReturningInvoke (vs', a) @@ at]
@@ -387,11 +515,11 @@ let rec step (c : config) : config =
       | Load {offset; ty; pack; _}, Num (I32 i) :: vs' ->
         let mem = memory c.frame.inst (0l @@ e.at) in
         let a = I64_convert.extend_i32_u i in
-        let t = subst_num_type (subst_of c.frame.inst) ty in
+        let t = dyn_num_type [] ty in
         (try
           let n =
             match pack with
-            | None -> Memory.load_num mem a offset ty
+            | None -> Memory.load_num mem a offset t
             | Some (sz, ext) -> Memory.load_num_packed sz ext mem a offset t
           in Num n :: vs', []
         with exn -> vs', [Trapping (memory_error e.at exn) @@ e.at])
@@ -410,7 +538,7 @@ let rec step (c : config) : config =
       | VecLoad {offset; ty; pack; _}, Num (I32 i) :: vs' ->
         let mem = memory c.frame.inst (0l @@ e.at) in
         let a = I64_convert.extend_i32_u i in
-        let t = subst_vec_type (subst_of c.frame.inst) ty in
+        let t = dyn_vec_type [] ty in
         (try
           let v =
             match pack with
@@ -552,7 +680,7 @@ let rec step (c : config) : config =
         vs, []
 
       | RefNull t, vs' ->
-        Ref (NullRef (subst_heap_type (subst_of c.frame.inst) t)) :: vs', []
+        Ref (NullRef (dyn_heap_type c.frame.inst.types t)) :: vs', []
 
       | RefIsNull, Ref r :: vs' ->
         (match r with
@@ -666,19 +794,16 @@ let rec step (c : config) : config =
     | Refer r, vs ->
       Ref r :: vs, []
 
-    | Trapping _, vs ->
-      assert false
-
-    | Returning _, vs
-    | ReturningInvoke _, vs ->
-      Crash.error e.at "undefined frame"
-
-    | Breaking _, vs ->
-      Crash.error e.at "undefined label"
-
     | Label (n, es0, (vs', [])), vs ->
       vs' @ vs, []
 
+    | Label (n, es0, (vs', {it = Suspending (tagt, vs1, ctxt); at} :: es')), vs ->
+      let ctxt' code = [], [Label (n, es0, compose (ctxt code) (vs', es')) @@ e.at] in
+      vs, [Suspending (tagt, vs1, ctxt') @@ at]
+
+    | Label (n, es0, (vs', {it = ReturningInvoke (vs0, f); at} :: es')), vs ->
+      vs, [ReturningInvoke (vs0, f) @@ at]
+
     | Label (n, es0, (vs', {it = Breaking (0l, vs0); at} :: es')), vs ->
       take n vs0 e.at @ vs, List.map plain es0
 
@@ -698,30 +823,90 @@ let rec step (c : config) : config =
     | Frame (n, frame', (vs', {it = Trapping msg; at} :: es')), vs ->
       vs, [Trapping msg @@ at]
 
+    | Frame (n, frame', (vs', {it = Throwing (a, vs0); at} :: es')), vs ->
+      vs, [Throwing (a, vs0) @@ at]
+
+    | Frame (n, frame', (vs', {it = Suspending (tagt, vs1, ctxt); at} :: es')), vs ->
+      let ctxt' code = [], [Frame (n, frame', compose (ctxt code) (vs', es')) @@ e.at] in
+      vs, [Suspending (tagt, vs1, ctxt') @@ at]
+
     | Frame (n, frame', (vs', {it = Returning vs0; at} :: es')), vs ->
       take n vs0 e.at @ vs, []
 
     | Frame (n, frame', (vs', {it = ReturningInvoke (vs0, f); at} :: es')), vs ->
       let FuncT (ts1, _ts2) = Func.type_of f in
-      take (List.length ts1) vs0 e.at @ vs, [Invoke f @@ at]
+      take (Lib.List32.length ts1) vs0 e.at @ vs, [Invoke f @@ at]
 
     | Frame (n, frame', code'), vs ->
       let c' = step {frame = frame'; code = code'; budget = c.budget - 1} in
       vs, [Frame (n, frame', c'.code) @@ e.at]
 
+    | Catch (n, cts, ca, (vs', [])), vs ->
+      vs' @ vs, []
+
+    | Catch (n, cts, ca, (vs', ({it = Trapping _ | Breaking _ | Returning _ | Delegating _; at} as e) :: es')), vs ->
+      vs, [e]
+
+    | Catch (n, cts, ca, (vs', {it = Rethrowing (k, cont); at} :: es')), vs ->
+      vs, [Rethrowing (k, (fun e -> Catch (n, cts, ca, (vs', (cont e) :: es')) @@ e.at)) @@ at]
+
+    | Catch (n, (a', es'') :: cts, ca, (vs', {it = Throwing (a, vs0); at} :: es')), vs ->
+      if a == a' then
+        vs, [Caught (n, a, vs0, (vs0, List.map plain es'')) @@ at]
+      else
+        vs, [Catch (n, cts, ca, (vs', {it = Throwing (a, vs0); at} :: es')) @@ e.at]
+
+    | Catch (n, [], Some es'', (vs', {it = Throwing (a, vs0); at} :: es')), vs ->
+      vs, [Caught (n, a, vs0, (vs0, List.map plain es'')) @@ at]
+
+    | Catch (n, [], None, (vs', {it = Throwing (a, vs0); at} :: es')), vs ->
+      vs, [Throwing (a, vs0) @@ at]
+
+    | Catch (n, cts, ca, code'), vs ->
+      let c' = step {c with code = code'} in
+      vs, [Catch (n, cts, ca, c'.code) @@ e.at]
+
+    | Caught (n, a, vs0, (vs', [])), vs ->
+      vs' @ vs, []
+
+    | Caught (n, a, vs0, (vs', ({it = Trapping _ | Breaking _ | Returning _ | Throwing _ | Delegating _; at} as e) :: es')), vs ->
+      vs, [e]
+
+    | Caught (n, a, vs0, (vs', {it = Rethrowing (0l, cont); at} :: es')), vs ->
+      vs, [Caught (n, a, vs0, (vs', (cont (Throwing (a, vs0) @@ at)) :: es')) @@ e.at]
+
+    | Caught (n, a, vs0, (vs', {it = Rethrowing (k, cont); at} :: es')), vs ->
+      vs, [Rethrowing (k, (fun e -> Caught (n, a, vs0, (vs', (cont e) :: es')) @@ e.at)) @@ at]
+
+    | Caught (n, a, vs0, code'), vs ->
+      let c' = step {c with code = code'} in
+      vs, [Caught (n, a, vs0, c'.code) @@ e.at]
+
+    | Delegate (l, (vs', [])), vs ->
+      vs' @ vs, []
+
+    | Delegate (l, (vs', ({it = Trapping _ | Breaking _ | Returning _ | Rethrowing _ | Delegating _; at} as e) :: es')), vs ->
+      vs, [e]
+
+    | Delegate (l, (vs', {it = Throwing (a, vs0); at} :: es')), vs ->
+      vs, [Delegating (l, a, vs0) @@ e.at]
+
+    | Delegate (l, code'), vs ->
+      let c' = step {c with code = code'} in
+      vs, [Delegate (l, c'.code) @@ e.at]
+
     | Invoke f, vs when c.budget = 0 ->
       Exhaustion.error e.at "call stack exhausted"
 
     | Invoke f, vs ->
       let FuncT (ts1, ts2) = Func.type_of f in
-      let n1, n2 = List.length ts1, List.length ts2 in
+      let n1, n2 = Lib.List32.length ts1, Lib.List32.length ts2 in
       let args, vs' = split n1 vs e.at in
       (match f with
-      | Func.AstFunc (_, inst', func) ->
+       | Func.AstFunc (_, inst', func) ->
         let {locals; body; _} = func.it in
         let m = Lib.Promise.value inst' in
-        let s = subst_of m in
-        let ts = List.map (fun loc -> subst_val_type s loc.it.ltype) locals in
+        let ts = List.map (fun loc -> Types.dyn_val_type m.types loc.it.ltype) locals in
         let locs' = List.(rev (map Option.some args) @ map default_value ts) in
         let frame' = {inst = m; locals = List.map ref locs'} in
         let instr' = [Label (n2, [], ([], List.map plain body)) @@ func.at] in
@@ -731,6 +916,45 @@ let rec step (c : config) : config =
         (try List.rev (f (List.rev args)) @ vs', []
         with Crash (_, msg) -> Crash.error e.at msg)
       )
+
+    | Handle (hso, (vs', [])), vs ->
+      vs' @ vs, []
+
+    | Handle (None, (vs', {it = Suspending _; at} :: es')), vs ->
+      vs, [Trapping "barrier hit by suspension" @@ at]
+
+    | Handle (Some hs, (vs', {it = Suspending (tagt, vs1, ctxt); at} :: es')), vs
+      when List.mem_assq tagt hs ->
+      let TagT x' = Tag.type_of tagt in
+      let FuncT (_, ts) = as_func_def_type (def_of (as_dyn_var x')) in
+      let ctxt' code = compose (ctxt code) (vs', es') in
+      [Ref (ContRef (ref (Some (Lib.List32.length ts, ctxt'))))] @ vs1 @ vs,
+      [Plain (Br (List.assq tagt hs)) @@ e.at]
+
+    | Handle (hso, (vs', {it = Suspending (tagt, vs1, ctxt); at} :: es')), vs ->
+      let ctxt' code = [], [Handle (hso, compose (ctxt code) (vs', es')) @@ e.at] in
+      vs, [Suspending (tagt, vs1, ctxt') @@ at]
+
+    | Handle (hso, (vs', e' :: es')), vs when is_jumping e' ->
+      vs, [e']
+
+    | Handle (hso, code'), vs ->
+      let c' = step {c with code = code'} in
+      vs, [Handle (hso, c'.code) @@ e.at]
+
+    | Rethrowing _, _ ->
+      Crash.error e.at "undefined catch label"
+    | Delegating _, _ ->
+      Crash.error e.at "undefined delegate label"
+
+    | Trapping _, _
+    | Throwing _, _
+    | Suspending _, _
+    | Returning _, _
+    | ReturningInvoke _, _
+    | Breaking _, _ ->
+      assert false
+
   in {c with code = vs', es' @ List.tl es}
 
 
@@ -739,10 +963,17 @@ let rec eval (c : config) : value stack =
   | vs, [] ->
     vs
 
-  | vs, {it = Trapping msg; at} :: _ ->
-    Trap.error at msg
-
-  | vs, es ->
+  | vs, e::_ when is_jumping e ->
+    (match e.it with
+    | Trapping msg ->  Trap.error e.at msg
+    | Throwing _ -> Exception.error e.at "unhandled exception"
+    | Suspending _ -> Suspension.error e.at "unhandled tag"
+    | Returning _ | ReturningInvoke _ -> Crash.error e.at "undefined frame"
+    | Breaking _ -> Crash.error e.at "undefined label"
+    | _ -> assert false
+    )
+
+  | _ ->
     eval (step c)
 
 
@@ -757,7 +988,7 @@ let invoke (func : func_inst) (vs : value list) : value list =
   let FuncT (ts1, _ts2) = Func.type_of func in
   if List.length vs <> List.length ts1 then
     Crash.error at "wrong number of arguments";
-  if not (List.for_all2 (fun v -> Match.match_val_type (type_of_value v)) vs ts1) then
+  if not (List.for_all2 (fun v -> Match.match_val_type [] (type_of_value v)) vs ts1) then
     Crash.error at "wrong types of arguments";
   let c = config empty_module_inst (List.rev vs) [Invoke func @@ at] in
   try List.rev (eval c) with Stack_overflow ->
@@ -772,72 +1003,36 @@ let eval_const (inst : module_inst) (const : const) : value =
 
 (* Modules *)
 
-let init_type (inst : module_inst) (ty : type_) : module_inst =
-  let dt = subst_def_type (subst_of inst) ty.it in
-  {inst with types = inst.types @ [dt]}
-
-let init_import (inst : module_inst) (ex : extern) (im : import) : module_inst =
-  let {idesc; _} = im.it in
-  let it =
-    match idesc.it with
-    | FuncImport x -> ExternFuncT (func_type inst x)
-    | TableImport tt -> ExternTableT tt
-    | MemoryImport mt -> ExternMemoryT mt
-    | GlobalImport gt -> ExternGlobalT gt
-  in
-  let et = subst_extern_type (subst_of inst) it in
-  let et' = extern_type_of inst.types ex in
-  if not (Match.match_extern_type et' et) then
-    Link.error im.at ("incompatible import type for " ^
-      "\"" ^ Utf8.encode im.it.module_name ^ "\" " ^
-      "\"" ^ Utf8.encode im.it.item_name ^ "\": " ^
-      "expected " ^ Types.string_of_extern_type et ^
-      ", got " ^ Types.string_of_extern_type et');
-  match ex with
-  | ExternFunc func -> {inst with funcs = inst.funcs @ [func]}
-  | ExternTable tab -> {inst with tables = inst.tables @ [tab]}
-  | ExternMemory mem -> {inst with memories = inst.memories @ [mem]}
-  | ExternGlobal glob -> {inst with globals = inst.globals @ [glob]}
-
-let init_func (inst : module_inst) (f : func) : module_inst =
-  let func = Func.alloc (func_type inst f.it.ftype) (Lib.Promise.make ()) f in
-  {inst with funcs = inst.funcs @ [func]}
+let create_type (_ : type_) : type_inst =
+  Types.alloc_uninit ()
 
-let init_global (inst : module_inst) (glob : global) : module_inst =
-  let {gtype; ginit} = glob.it in
-  let gt = subst_global_type (subst_of inst) gtype in
-  let v = eval_const inst ginit in
-  let glob = Global.alloc gt v in
-  {inst with globals = inst.globals @ [glob]}
+let create_func (inst : module_inst) (f : func) : func_inst =
+  Func.alloc (type_ inst f.it.ftype) (Lib.Promise.make ()) f
 
-let init_table (inst : module_inst) (tab : table) : module_inst =
+let create_table (inst : module_inst) (tab : table) : table_inst =
   let {ttype; tinit} = tab.it in
-  let tt = subst_table_type (subst_of inst) ttype in
+  let tt = Types.dyn_table_type inst.types ttype in
   let r =
     match eval_const inst tinit with
     | Ref r -> r
     | _ -> Crash.error tinit.at "non-reference table initializer"
   in
-  let tab = Table.alloc tt r in
-  {inst with tables = inst.tables @ [tab]}
+  Table.alloc tt r
 
-let init_memory (inst : module_inst) (mem : memory) : module_inst =
+let create_memory (inst : module_inst) (mem : memory) : memory_inst =
   let {mtype} = mem.it in
-  let mt = subst_memory_type (subst_of inst) mtype in
-  let mem = Memory.alloc mt in
-  {inst with memories = inst.memories @ [mem]}
+  Memory.alloc (Types.dyn_memory_type inst.types mtype)
 
-let init_elem (inst : module_inst) (seg : elem_segment) : module_inst =
-  let {etype; einit; _} = seg.it in
-  let elem = Elem.alloc (List.map (fun c -> as_ref (eval_const inst c)) einit) in
-  {inst with elems = inst.elems @ [elem]}
+let create_global (inst : module_inst) (glob : global) : global_inst =
+  let {gtype; ginit} = glob.it in
+  let v = eval_const inst ginit in
+  Global.alloc (Types.dyn_global_type inst.types gtype) v
 
-let init_data (inst : module_inst) (seg : data_segment) : module_inst =
-  let {dinit; _} = seg.it in
-  let data = Data.alloc dinit in
-  {inst with datas = inst.datas @ [data]}
+let create_tag (inst : module_inst) (tag : tag) : tag_inst =
+  let {tagtype} = tag.it in
+  Tag.alloc (Types.dyn_tag_type inst.types tagtype)
 
-let init_export (inst : module_inst) (ex : export) : module_inst =
+let create_export (inst : module_inst) (ex : export) : export_inst =
   let {name; edesc} = ex.it in
   let ext =
     match edesc.it with
@@ -845,15 +1040,44 @@ let init_export (inst : module_inst) (ex : export) : module_inst =
     | TableExport x -> ExternTable (table inst x)
     | MemoryExport x -> ExternMemory (memory inst x)
     | GlobalExport x -> ExternGlobal (global inst x)
-  in
-  {inst with exports = inst.exports @ [(name, ext)]}
+    | TagExport x -> ExternTag (tag inst x)
+  in (name, ext)
+
+let create_elem (inst : module_inst) (seg : elem_segment) : elem_inst =
+  let {etype; einit; _} = seg.it in
+  Elem.alloc (List.map (fun c -> as_ref (eval_const inst c)) einit)
+
+let create_data (inst : module_inst) (seg : data_segment) : data_inst =
+  let {dinit; _} = seg.it in
+  Data.alloc dinit
 
 
-let init_func_inst (inst : module_inst) (func : func_inst) =
+let add_import (m : module_) (ext : extern) (im : import) (inst : module_inst)
+  : module_inst =
+  let it = Types.extern_type_of_import_type (import_type_of m im) in
+  let et = Types.dyn_extern_type inst.types it in
+  let et' = extern_type_of inst.types ext in
+  if not (Match.match_extern_type [] et' et) then
+    Link.error im.at ("incompatible import type for " ^
+      "\"" ^ Utf8.encode im.it.module_name ^ "\" " ^
+      "\"" ^ Utf8.encode im.it.item_name ^ "\": " ^
+      "expected " ^ Types.string_of_extern_type et ^
+      ", got " ^ Types.string_of_extern_type et');
+  match ext with
+  | ExternFunc func -> {inst with funcs = func :: inst.funcs}
+  | ExternTable tab -> {inst with tables = tab :: inst.tables}
+  | ExternMemory mem -> {inst with memories = mem :: inst.memories}
+  | ExternGlobal glob -> {inst with globals = glob :: inst.globals}
+  | ExternTag tag -> {inst with tags = tag :: inst.tags}
+
+
+let init_type (inst : module_inst) (type_ : type_) (x : type_inst) =
+  Types.init x (Types.dyn_def_type inst.types type_.it)
+
+let init_func (inst : module_inst) (func : func_inst) =
   match func with
-  | Func.AstFunc (_, prom, _) when Lib.Promise.value_opt prom = None ->
-    Lib.Promise.fulfill prom inst
-  | _ -> ()
+  | Func.AstFunc (_, inst_prom, _) -> Lib.Promise.fulfill inst_prom inst
+  | _ -> assert false
 
 let run_elem i elem =
   let at = elem.it.emode.at in
@@ -888,31 +1112,37 @@ let run_data i data =
 let run_start start =
   [Call start.it.sfunc @@ start.at]
 
-
-let init_list f xs (inst : module_inst) : module_inst =
-  List.fold_left f inst xs
-
-let init_list2 f xs ys (inst : module_inst) : module_inst =
-  List.fold_left2 f inst xs ys
-
 let init (m : module_) (exts : extern list) : module_inst =
-  if List.length exts <> List.length m.it.imports then
+  let
+    { types; imports; tables; memories; globals; funcs; tags;
+      exports; elems; datas; start
+    } = m.it
+  in
+  if List.length exts <> List.length imports then
     Link.error m.at "wrong number of imports provided for initialisation";
+  let inst0 = {empty_module_inst with types = List.map create_type types} in
+  List.iter2 (init_type inst0) types inst0.types;
+  let inst1 = List.fold_right2 (add_import m) exts imports inst0 in
+  let fs = List.map (create_func inst1) funcs in
+  let inst2 = {inst1 with funcs = inst1.funcs @ fs} in
+  let inst3 =
+    { inst2 with
+      tables = inst2.tables @ List.map (create_table inst2) tables;
+      memories = inst2.memories @ List.map (create_memory inst2) memories;
+      globals = inst2.globals @ List.map (create_global inst2) globals;
+      tags = inst2.tags @ List.map (create_tag inst2) tags;
+    }
+  in
   let inst =
-    empty_module_inst
-    |> init_list init_type m.it.types
-    |> init_list2 init_import exts m.it.imports
-    |> init_list init_func m.it.funcs
-    |> init_list init_global m.it.globals
-    |> init_list init_table m.it.tables
-    |> init_list init_memory m.it.memories
-    |> init_list init_elem m.it.elems
-    |> init_list init_data m.it.datas
-    |> init_list init_export m.it.exports
+    { inst3 with
+      exports = List.map (create_export inst3) exports;
+      elems = List.map (create_elem inst3) elems;
+      datas = List.map (create_data inst3) datas;
+    }
   in
-  List.iter (init_func_inst inst) inst.funcs;
-  let es_elem = List.concat (Lib.List32.mapi run_elem m.it.elems) in
-  let es_data = List.concat (Lib.List32.mapi run_data m.it.datas) in
-  let es_start = Lib.Option.get (Lib.Option.map run_start m.it.start) [] in
+  List.iter (init_func inst) fs;
+  let es_elem = List.concat (Lib.List32.mapi run_elem elems) in
+  let es_data = List.concat (Lib.List32.mapi run_data datas) in
+  let es_start = Lib.Option.get (Lib.Option.map run_start start) [] in
   ignore (eval (config inst [] (List.map plain (es_elem @ es_data @ es_start))));
   inst
diff --git a/interpreter/exec/eval.mli b/interpreter/exec/eval.mli
index 056fc05f..089aaeca 100644
--- a/interpreter/exec/eval.mli
+++ b/interpreter/exec/eval.mli
@@ -3,8 +3,10 @@ open Instance
 
 exception Link of Source.region * string
 exception Trap of Source.region * string
-exception Crash of Source.region * string
+exception Exception of Source.region * string
+exception Suspension of Source.region * string
 exception Exhaustion of Source.region * string
+exception Crash of Source.region * string
 
 val init : Ast.module_ -> extern list -> module_inst (* raises Link, Trap *)
 val invoke : func_inst -> value list -> value list (* raises Trap *)
diff --git a/interpreter/host/env.ml b/interpreter/host/env.ml
index 1bcd97c6..637b2f30 100644
--- a/interpreter/host/env.ml
+++ b/interpreter/host/env.ml
@@ -41,6 +41,8 @@ let exit vs =
 
 let lookup name et =
   match Utf8.encode name, et with
-  | "abort", ExternFuncT ft -> ExternFunc (Func.alloc_host ft abort)
-  | "exit", ExternFuncT ft -> ExternFunc (Func.alloc_host ft exit)
+  | "abort", ExternFuncT ft ->
+    ExternFunc (Func.alloc_host (Types.alloc (DefFuncT ft)) abort)
+  | "exit", ExternFuncT ft ->
+    ExternFunc (Func.alloc_host (Types.alloc (DefFuncT ft)) exit)
   | _ -> raise Not_found
diff --git a/interpreter/host/spectest.ml b/interpreter/host/spectest.ml
index 1568ffc2..598ec05e 100644
--- a/interpreter/host/spectest.ml
+++ b/interpreter/host/spectest.ml
@@ -19,9 +19,18 @@ let global (GlobalT (_, t) as gt) =
     | BotT -> assert false
   in Global.alloc gt v
 
-let table tt = Table.alloc tt (NullRef BotHT)
-let memory mt = Memory.alloc mt
-let func f ft = Func.alloc_host ft (f ft)
+let table =
+  Table.alloc (TableT ({min = 10l; max = Some 20l}, (Null, FuncHT)))
+    (NullRef FuncHT)
+let memory = Memory.alloc (MemoryT {min = 1l; max = Some 2l})
+let func f ft = Func.alloc_host (Types.alloc (DefFuncT ft)) (f ft)
+
+let tag =
+  let p = Types.alloc (DefFuncT (FuncT ([NumT I32T], [NumT I32T]))) in
+  Tag.alloc (TagT (Dyn p))
+let except =
+  let p = Types.alloc (DefFuncT (FuncT ([NumT I32T], []))) in
+  Tag.alloc (TagT (Dyn p))
 
 let print_value v =
   Printf.printf "%s : %s\n"
@@ -46,6 +55,8 @@ let lookup name t =
   | "global_i64", _ -> ExternGlobal (global (GlobalT (Cons, NumT I64T)))
   | "global_f32", _ -> ExternGlobal (global (GlobalT (Cons, NumT F32T)))
   | "global_f64", _ -> ExternGlobal (global (GlobalT (Cons, NumT F64T)))
-  | "table", _ -> ExternTable (table (TableT ({min = 10l; max = Some 20l}, (Null, FuncHT))))
-  | "memory", _ -> ExternMemory (memory (MemoryT {min = 1l; max = Some 2l}))
+  | "table", _ -> ExternTable table
+  | "memory", _ -> ExternMemory memory
+  | "tag", _ -> ExternTag tag
+  | "exception", _ -> ExternTag except
   | _ -> raise Not_found
diff --git a/interpreter/runtime/func.ml b/interpreter/runtime/func.ml
index 18c1b68c..e4828dd4 100644
--- a/interpreter/runtime/func.ml
+++ b/interpreter/runtime/func.ml
@@ -3,12 +3,14 @@ open Value
 
 type 'inst t = 'inst func
 and 'inst func =
-  | AstFunc of func_type * 'inst * Ast.func
-  | HostFunc of func_type * (value list -> value list)
+  | AstFunc of type_addr * 'inst * Ast.func
+  | HostFunc of type_addr * (value list -> value list)
 
-let alloc ft inst f = AstFunc (ft, inst, f)
-let alloc_host ft f = HostFunc (ft, f)
+let alloc x inst f = AstFunc (x, inst, f)
+let alloc_host x f = HostFunc (x, f)
 
-let type_of = function
-  | AstFunc (ft, _, _) -> ft
-  | HostFunc (ft, _) -> ft
+let type_inst_of = function
+  | AstFunc (x, _, _) -> x
+  | HostFunc (x, _) -> x
+
+let type_of f = as_func_def_type (def_of (type_inst_of f))
diff --git a/interpreter/runtime/func.mli b/interpreter/runtime/func.mli
index e072c735..880ddc5c 100644
--- a/interpreter/runtime/func.mli
+++ b/interpreter/runtime/func.mli
@@ -3,10 +3,11 @@ open Value
 
 type 'inst t = 'inst func
 and 'inst func =
-  | AstFunc of func_type * 'inst * Ast.func
-  | HostFunc of func_type * (value list -> value list)
+  | AstFunc of type_addr * 'inst * Ast.func
+  | HostFunc of type_addr * (value list -> value list)
 
-val alloc : func_type -> 'inst -> Ast.func -> 'inst func
-val alloc_host : func_type -> (value list -> value list) -> 'inst func
+val alloc : type_addr -> 'inst -> Ast.func -> 'inst func
+val alloc_host : type_addr -> (value list -> value list) -> 'inst func
 
 val type_of : 'inst func -> func_type
+val type_inst_of : 'inst func -> type_addr
diff --git a/interpreter/runtime/global.ml b/interpreter/runtime/global.ml
index fc76a9c1..a7df8e69 100644
--- a/interpreter/runtime/global.ml
+++ b/interpreter/runtime/global.ml
@@ -8,7 +8,7 @@ exception Type
 exception NotMutable
 
 let alloc (GlobalT (_mut, t) as ty) v =
-  if not (Match.match_val_type (type_of_value v) t) then raise Type;
+  if not (Match.match_val_type [] (type_of_value v) t) then raise Type;
   {ty; content = v}
 
 let type_of glob =
@@ -20,5 +20,5 @@ let load glob =
 let store glob v =
   let GlobalT (mut, t) = glob.ty in
   if mut <> Var then raise NotMutable;
-  if not (Match.match_val_type (type_of_value v) t) then raise Type;
+  if not (Match.match_val_type [] (type_of_value v) t) then raise Type;
   glob.content <- v
diff --git a/interpreter/runtime/instance.ml b/interpreter/runtime/instance.ml
index 41610689..8ab5fffc 100644
--- a/interpreter/runtime/instance.ml
+++ b/interpreter/runtime/instance.ml
@@ -7,16 +7,18 @@ type module_inst =
   tables : table_inst list;
   memories : memory_inst list;
   globals : global_inst list;
+  tags : tag_inst list;
   elems : elem_inst list;
   datas : data_inst list;
   exports : export_inst list;
 }
 
-and type_inst = def_type
+and type_inst = type_addr
 and func_inst = module_inst Lib.Promise.t Func.t
 and table_inst = Table.t
 and memory_inst = Memory.t
 and global_inst = Global.t
+and tag_inst = Tag.t
 and elem_inst = Elem.t
 and data_inst = Data.t
 and export_inst = Ast.name * extern
@@ -26,6 +28,7 @@ and extern =
   | ExternTable of table_inst
   | ExternMemory of memory_inst
   | ExternGlobal of global_inst
+  | ExternTag of tag_inst
 
 
 (* Reference types *)
@@ -35,7 +38,7 @@ type Value.ref_ += FuncRef of func_inst
 let () =
   let type_of_ref' = !Value.type_of_ref' in
   Value.type_of_ref' := function
-    | FuncRef f -> DefHT (DefFuncT (Func.type_of f))
+    | FuncRef f -> DefHT (Dyn (Func.type_inst_of f))
     | r -> type_of_ref' r
 
 let () =
@@ -52,18 +55,10 @@ let () =
     | _, _ -> eq_ref' r1 r2
 
 
-(* Projections *)
-
-let func_inst_of_extern = function ExternFunc f -> f | _ -> failwith "func_inst_of_extern"
-let table_inst_of_extern = function ExternTable f -> f | _ -> failwith "table_inst_of_extern"
-let memory_inst_of_extern = function ExternMemory f -> f | _ -> failwith "memory_inst_of_extern"
-let global_inst_of_extern = function ExternGlobal f -> f | _ -> failwith "global_inst_of_extern"
-
-
 (* Auxiliary functions *)
 
 let empty_module_inst =
-  { types = []; funcs = []; tables = []; memories = []; globals = [];
+  { types = []; funcs = []; tables = []; memories = []; globals = []; tags = [];
     elems = []; datas = []; exports = [] }
 
 let extern_type_of c = function
@@ -71,6 +66,7 @@ let extern_type_of c = function
   | ExternTable tab -> ExternTableT (Table.type_of tab)
   | ExternMemory mem -> ExternMemoryT (Memory.type_of mem)
   | ExternGlobal glob -> ExternGlobalT (Global.type_of glob)
+  | ExternTag tag -> ExternTagT (Tag.type_of tag)
 
 let export inst name =
   try Some (List.assoc name inst.exports) with Not_found -> None
diff --git a/interpreter/runtime/table.ml b/interpreter/runtime/table.ml
index 39ef7c4e..3d8a1c3f 100644
--- a/interpreter/runtime/table.ml
+++ b/interpreter/runtime/table.ml
@@ -51,7 +51,7 @@ let load tab i =
 
 let store tab i r =
   let TableT (lim, t) = tab.ty in
-  if not (Match.match_ref_type (type_of_ref r) t) then raise Type;
+  if not (Match.match_ref_type [] (type_of_ref r) t) then raise Type;
   try Lib.Array32.set tab.content i r with Invalid_argument _ -> raise Bounds
 
 let blit tab offset rs =
diff --git a/interpreter/runtime/tag.ml b/interpreter/runtime/tag.ml
new file mode 100644
index 00000000..cd6c9307
--- /dev/null
+++ b/interpreter/runtime/tag.ml
@@ -0,0 +1,10 @@
+open Types
+
+type tag = {ty : tag_type}
+type t = tag
+
+let alloc ty =
+  {ty}
+
+let type_of tag =
+  tag.ty
diff --git a/interpreter/runtime/tag.mli b/interpreter/runtime/tag.mli
new file mode 100644
index 00000000..c4730e29
--- /dev/null
+++ b/interpreter/runtime/tag.mli
@@ -0,0 +1,7 @@
+open Types
+
+type tag
+type t = tag
+
+val alloc : tag_type -> tag
+val type_of : tag -> tag_type
diff --git a/interpreter/script/import.ml b/interpreter/script/import.ml
index 1040aaa7..cac9a8d8 100644
--- a/interpreter/script/import.ml
+++ b/interpreter/script/import.ml
@@ -17,5 +17,5 @@ let lookup (ImportT (et, module_name, item_name)) at : Instance.extern =
         "\".\"" ^ Types.string_of_name item_name ^ "\"")
 
 let link m =
-  let ModuleT (its, _) = module_type_of m in
+  let ModuleT (_, its, _) = Types.dyn_module_type (module_type_of m) in
   List.map2 lookup its (List.map Source.at m.it.imports)
diff --git a/interpreter/script/js.ml b/interpreter/script/js.ml
index 2ca5eda2..7f660b74 100644
--- a/interpreter/script/js.ml
+++ b/interpreter/script/js.ml
@@ -138,6 +138,21 @@ function assert_trap(action) {
   throw new Error("Wasm trap expected");
 }
 
+function assert_exception(action) {
+  try { action() } catch (e) {
+    if (!(e instanceof WebAssembly.RuntimeError)) return;
+  }
+  throw new Error("Wasm exception expected");
+}
+
+function assert_suspension(action) {
+  try { action() } catch (e) {
+    /* TODO: Not clear how to observe form JS */
+    return;
+  }
+  throw new Error("Wasm exception expected");
+}
+
 let StackOverflow;
 try { (function f() { 1 + f() })() } catch (e) { StackOverflow = e.constructor }
 
@@ -203,7 +218,7 @@ type exports = extern_type NameMap.t
 type modules = {mutable env : exports Map.t; mutable current : int}
 
 let exports m : exports =
-  let ModuleT (_, ets) = module_type_of m in
+  let ets = List.map (export_type_of m) m.it.exports in
   List.fold_left (fun map (ExportT (et, name)) -> NameMap.add name et map)
     NameMap.empty ets
 
@@ -268,8 +283,12 @@ let abs_mask_of = function
 let null_heap_type_of = function
   | Types.FuncHT -> FuncHT
   | Types.ExternHT -> ExternHT
-  | Types.DefHT (Types.DefFuncT _) -> FuncHT
-  | Types.VarHT _ | Types.BotHT -> assert false
+  | Types.BotHT -> assert false
+  | Types.DefHT (Stat _) -> assert false
+  | Types.DefHT (Dyn a) ->
+    match Types.def_of a with
+    | Types.DefFuncT _ -> FuncHT
+    | Types.DefContT _ -> assert false
 
 let value v =
   match v.it with
@@ -379,7 +398,8 @@ let assert_return ress ts at =
         match t with
         | FuncHT -> is_funcref_idx
         | ExternHT -> is_externref_idx
-        | DefHT _ | VarHT _ | BotHT -> assert false
+        | DefHT _ -> is_funcref_idx
+        | BotHT -> assert false
       in
       [ Call (is_ref_idx @@ at) @@ at;
         Test (I32 I32Op.Eqz) @@ at;
@@ -604,6 +624,10 @@ let of_assertion mods ass =
       (Some (assert_return ress))
   | AssertTrap (act, _) ->
     of_assertion' mods act "assert_trap" [] None
+  | AssertException (act, _) ->
+    of_assertion' mods act "assert_exception" [] None
+  | AssertSuspension (act, _) ->
+    of_assertion' mods act "assert_suspension" [] None
   | AssertExhaustion (act, _) ->
     of_assertion' mods act "assert_exhaustion" [] None
 
diff --git a/interpreter/script/run.ml b/interpreter/script/run.ml
index 34c7ab6d..2c3f1989 100644
--- a/interpreter/script/run.ml
+++ b/interpreter/script/run.ml
@@ -110,6 +110,7 @@ let input_from get_script run =
   | Import.Unknown (at, msg) -> error at "link failure" msg
   | Eval.Link (at, msg) -> error at "link failure" msg
   | Eval.Trap (at, msg) -> error at "runtime trap" msg
+  | Eval.Exception (at, msg) -> error at "runtime exception" msg
   | Eval.Exhaustion (at, msg) -> error at "resource exhaustion" msg
   | Eval.Crash (at, msg) -> error at "runtime crash" msg
   | Encode.Code (at, msg) -> error at "encoding error" msg
@@ -233,7 +234,7 @@ let type_of_result r =
   | NumResult (NanPat n) -> NumT (Value.type_of_num n.it)
   | VecResult (VecPat v) -> VecT (Value.type_of_vec v)
   | RefResult (RefPat r) -> RefT (Value.type_of_ref r.it)
-  | RefResult (RefTypePat t) -> RefT (NoNull, t)  (* assume closed *)
+  | RefResult (RefTypePat t) -> RefT (NoNull, dyn_heap_type [] t)
   | RefResult (NullPat) -> RefT (Null, ExternHT)
 
 let string_of_num_pat (p : num_pat) =
@@ -329,7 +330,7 @@ let run_action act : Value.t list =
       if List.length vs <> List.length ts1 then
         Script.error act.at "wrong number of arguments";
       List.iter2 (fun v t ->
-        if not (Match.match_val_type (Value.type_of_value v.it) t) then
+        if not (Match.match_val_type [] (Value.type_of_value v.it) t) then
           Script.error v.at "wrong type of argument"
       ) vs ts1;
       Eval.invoke f (List.map (fun v -> v.it) vs)
@@ -475,6 +476,20 @@ let run_assertion ass =
     | _ -> Assert.error ass.at "expected runtime error"
     )
 
+  | AssertException (act, re) ->
+    trace ("Asserting exception...");
+    (match run_action act with
+    | exception Eval.Exception (_, msg) -> assert_message ass.at "runtime" msg re
+    | _ -> Assert.error ass.at "expected exception"
+    )
+
+  | AssertSuspension (act, re) ->
+    trace ("Asserting suspension...");
+    (match run_action act with
+    | exception Eval.Suspension (_, msg) -> assert_message ass.at "runtime" msg re
+    | _ -> Assert.error ass.at "expected suspension"
+    )
+
   | AssertExhaustion (act, re) ->
     trace ("Asserting exhaustion...");
     (match run_action act with
diff --git a/interpreter/script/script.ml b/interpreter/script/script.ml
index a822c30d..df489887 100644
--- a/interpreter/script/script.ml
+++ b/interpreter/script/script.ml
@@ -46,6 +46,8 @@ and assertion' =
   | AssertUninstantiable of definition * string
   | AssertReturn of action * result list
   | AssertTrap of action * string
+  | AssertException of action * string
+  | AssertSuspension of action * string
   | AssertExhaustion of action * string
 
 type command = command' Source.phrase
diff --git a/interpreter/syntax/ast.ml b/interpreter/syntax/ast.ml
index 84a0df86..4b605fa4 100644
--- a/interpreter/syntax/ast.ml
+++ b/interpreter/syntax/ast.ml
@@ -146,6 +146,13 @@ and instr' =
   | Block of block_type * instr list  (* execute in sequence *)
   | Loop of block_type * instr list   (* loop header *)
   | If of block_type * instr list * instr list   (* conditional *)
+  | TryCatch of block_type * instr list * (* try *)
+                (idx * instr list) list * (* catch exception with tag *)
+                instr list option     (* catch_all *)
+  | TryDelegate of block_type * instr list * (* try *)
+                   idx                (* delegate to outer handler *)
+  | Throw of idx                      (* throw exception *)
+  | Rethrow of idx                    (* rethrow exception *)
   | Br of idx                         (* break to n-th surrounding label *)
   | BrIf of idx                       (* conditional break *)
   | BrTable of idx list * idx         (* indexed break *)
@@ -158,6 +165,12 @@ and instr' =
   | ReturnCall of idx                 (* tail-call function *)
   | ReturnCallRef of idx              (* tail call through reference *)
   | ReturnCallIndirect of idx * idx   (* tail-call function through table *)
+  | ContNew of idx                    (* create continuation *)
+  | ContBind of idx * idx             (* bind continuation arguments *)
+  | Suspend of idx                    (* suspend continuation *)
+  | Resume of idx * (idx * idx) list  (* resume continuation *)
+  | ResumeThrow of idx * idx * (idx * idx) list (* abort continuation *)
+  | Barrier of block_type * instr list  (* guard against suspension *)
   | LocalGet of idx                   (* read local idxiable *)
   | LocalSet of idx                   (* write local idxiable *)
   | LocalTee of idx                   (* write local idxiable and keep value *)
@@ -236,6 +249,15 @@ and func' =
 }
 
 
+(* Tags *)
+
+type tag = tag' Source.phrase
+and tag' =
+{
+  tagtype : tag_type;
+}
+
+
 (* Tables & Memories *)
 
 type table = table' Source.phrase
@@ -283,6 +305,7 @@ and export_desc' =
   | TableExport of idx
   | MemoryExport of idx
   | GlobalExport of idx
+  | TagExport of idx
 
 type export = export' Source.phrase
 and export' =
@@ -297,6 +320,7 @@ and import_desc' =
   | TableImport of table_type
   | MemoryImport of memory_type
   | GlobalImport of global_type
+  | TagImport of tag_type
 
 type import = import' Source.phrase
 and import' =
@@ -319,6 +343,7 @@ and module_' =
   globals : global list;
   tables : table list;
   memories : memory list;
+  tags : tag list;
   funcs : func list;
   start : start option;
   elems : elem_segment list;
@@ -336,6 +361,7 @@ let empty_module =
   globals = [];
   tables = [];
   memories = [];
+  tags = [];
   funcs = [];
   start = None;
   elems = [];
@@ -346,43 +372,47 @@ let empty_module =
 
 open Source
 
-let ft (m : module_) (x : idx) : func_type =
+let func_type_of (m : module_) (x : idx) : func_type =
   as_func_def_type (Lib.List32.nth m.it.types x.it).it
 
 let import_type_of (m : module_) (im : import) : import_type =
   let {idesc; module_name; item_name} = im.it in
   let et =
     match idesc.it with
-    | FuncImport x -> ExternFuncT (ft m x)
-    | TableImport tt -> ExternTableT tt
-    | MemoryImport mt -> ExternMemoryT mt
-    | GlobalImport gt -> ExternGlobalT gt
+    | FuncImport x -> ExternFuncT (func_type_of m x)
+    | TableImport t -> ExternTableT t
+    | MemoryImport t -> ExternMemoryT t
+    | GlobalImport t -> ExternGlobalT t
+    | TagImport t -> ExternTagT t
   in ImportT (et, module_name, item_name)
 
 let export_type_of (m : module_) (ex : export) : export_type =
   let {edesc; name} = ex.it in
   let its = List.map (import_type_of m) m.it.imports in
   let ets = List.map extern_type_of_import_type its in
+  let open Lib.List32 in
   let et =
     match edesc.it with
     | FuncExport x ->
-      let fts = funcs ets @ List.map (fun f -> ft m f.it.ftype) m.it.funcs in
-      ExternFuncT (Lib.List32.nth fts x.it)
+      let fts =
+        funcs ets @ List.map (fun f -> func_type_of m f.it.ftype) m.it.funcs
+      in ExternFuncT (nth fts x.it)
     | TableExport x ->
       let tts = tables ets @ List.map (fun t -> t.it.ttype) m.it.tables in
-      ExternTableT (Lib.List32.nth tts x.it)
+      ExternTableT (nth tts x.it)
     | MemoryExport x ->
       let mts = memories ets @ List.map (fun m -> m.it.mtype) m.it.memories in
-      ExternMemoryT (Lib.List32.nth mts x.it)
+      ExternMemoryT (nth mts x.it)
     | GlobalExport x ->
       let gts = globals ets @ List.map (fun g -> g.it.gtype) m.it.globals in
-      ExternGlobalT (Lib.List32.nth gts x.it)
+      ExternGlobalT (nth gts x.it)
+    | TagExport x ->
+      let tagts = tags ets @ List.map (fun t -> t.it.tagtype) m.it.tags in
+      ExternTagT (nth tagts x.it)
   in ExportT (et, name)
 
 let module_type_of (m : module_) : module_type =
+  let dts = List.map Source.it m.it.types in
   let its = List.map (import_type_of m) m.it.imports in
   let ets = List.map (export_type_of m) m.it.exports in
-  let a = Array.make (List.length m.it.types) BotHT in
-  let s = fun (StatX x) -> a.(Int32.to_int x) in
-  List.iteri (fun i dt -> a.(i) <- DefHT (subst_def_type s dt.it)) m.it.types;
-  subst_module_type s (ModuleT (its, ets))
+  ModuleT (dts, its, ets)
diff --git a/interpreter/syntax/free.ml b/interpreter/syntax/free.ml
index 381f08b2..e797da6d 100644
--- a/interpreter/syntax/free.ml
+++ b/interpreter/syntax/free.ml
@@ -10,6 +10,7 @@ type t =
   globals : Set.t;
   tables : Set.t;
   memories : Set.t;
+  tags : Set.t;
   funcs : Set.t;
   elems : Set.t;
   datas : Set.t;
@@ -23,6 +24,7 @@ let empty : t =
   globals = Set.empty;
   tables = Set.empty;
   memories = Set.empty;
+  tags = Set.empty;
   funcs = Set.empty;
   elems = Set.empty;
   datas = Set.empty;
@@ -36,6 +38,7 @@ let union (s1 : t) (s2 : t) : t =
   globals = Set.union s1.globals s2.globals;
   tables = Set.union s1.tables s2.tables;
   memories = Set.union s1.memories s2.memories;
+  tags = Set.union s1.tags s2.tags;
   funcs = Set.union s1.funcs s2.funcs;
   elems = Set.union s1.elems s2.elems;
   datas = Set.union s1.datas s2.datas;
@@ -47,6 +50,7 @@ let types s = {empty with types = s}
 let globals s = {empty with globals = s}
 let tables s = {empty with tables = s}
 let memories s = {empty with memories = s}
+let tags s = {empty with tags = s}
 let funcs s = {empty with funcs = s}
 let elems s = {empty with elems = s}
 let datas s = {empty with datas = s}
@@ -63,7 +67,8 @@ let opt free xo = Lib.Option.get (Option.map free xo) empty
 let list free xs = List.fold_left union empty (List.map free xs)
 
 let var_type = function
-  | StatX x -> types (idx' x)
+  | Stat x -> types (idx' x)
+  | Dyn x -> empty
 
 let num_type = function
   | I32T | I64T | F32T | F64T -> empty
@@ -73,8 +78,7 @@ let vec_type = function
 
 let heap_type = function
   | FuncHT | ExternHT | BotHT -> empty
-  | VarHT x -> var_type x
-  | DefHT dt -> empty  (* assume closed *)
+  | DefHT x -> var_type x
 
 let ref_type = function
   | (_, t) -> heap_type t
@@ -86,12 +90,15 @@ let val_type = function
   | BotT -> empty
 
 let func_type (FuncT (ins, out)) = list val_type ins ++ list val_type out
+let cont_type (ContT x) = var_type x
 let global_type (GlobalT (_mut, t)) = val_type t
 let table_type (TableT (_lim, t)) = ref_type t
 let memory_type (MemoryT (_lim)) = empty
+let tag_type (TagT x) = var_type x
 
 let def_type = function
   | DefFuncT ft -> func_type ft
+  | DefContT ct -> cont_type ct
 
 let block_type = function
   | VarBlockType x -> types (idx x)
@@ -105,7 +112,7 @@ let rec instr (e : instr) =
   | RefNull t -> heap_type t
   | RefFunc x -> funcs (idx x)
   | Const _ | Test _ | Compare _ | Unary _ | Binary _ | Convert _ -> empty
-  | Block (bt, es) | Loop (bt, es) -> block_type bt ++ block es
+  | Block (bt, es) | Loop (bt, es) | Barrier (bt, es) -> block_type bt ++ block es
   | If (bt, es1, es2) -> block_type bt ++ block es1 ++ block es2
   | Br x | BrIf x | BrOnNull x | BrOnNonNull x -> labels (idx x)
   | BrTable (xs, x) -> list (fun x -> labels (idx x)) (x::xs)
@@ -113,7 +120,20 @@ let rec instr (e : instr) =
   | Call x | ReturnCall x -> funcs (idx x)
   | CallRef x | ReturnCallRef x -> types (idx x)
   | CallIndirect (x, y) | ReturnCallIndirect (x, y) ->
-    tables (idx x) ++ types (idx y)
+     tables (idx x) ++ types (idx y)
+  | ContNew x -> types (idx x)
+  | ContBind (x, y) -> types (idx x) ++ types (idx y)
+  | TryCatch (bt, es, ct, ca) ->
+    let catch (tag, es) = tags (idx tag) ++ block es in
+    let catch_all = function
+      | None -> empty
+      | Some es -> block es in
+    block es ++ (list catch ct) ++ catch_all ca
+  | TryDelegate (bt, es, x) -> block es ++ tags (idx x)
+  | Throw x | Suspend x -> tags (idx x)
+  | Rethrow x -> labels (idx x)
+  | ResumeThrow (x, y, xys) -> types (idx x) ++ tags (idx y) ++ list (fun (x, y) -> tags (idx x) ++ labels (idx y)) xys
+  | Resume (x, xys) -> types (idx x) ++ list (fun (x, y) -> tags (idx x) ++ labels (idx y)) xys
   | LocalGet x | LocalSet x | LocalTee x -> locals (idx x)
   | GlobalGet x | GlobalSet x -> globals (idx x)
   | TableGet x | TableSet x | TableSize x | TableGrow x | TableFill x ->
@@ -143,6 +163,7 @@ let func (f : func) =
   {(types (idx f.it.ftype) ++ block f.it.body) with locals = Set.empty}
 let table (t : table) = table_type t.it.ttype ++ const t.it.tinit
 let memory (m : memory) = memory_type m.it.mtype
+let tag (e : tag) = tag_type e.it.tagtype
 
 let segment_mode f (m : segment_mode) =
   match m.it with
@@ -163,6 +184,7 @@ let export_desc (d : export_desc) =
   | TableExport x -> tables (idx x)
   | MemoryExport x -> memories (idx x)
   | GlobalExport x -> globals (idx x)
+  | TagExport x -> tags (idx x)
 
 let import_desc (d : import_desc) =
   match d.it with
@@ -170,6 +192,7 @@ let import_desc (d : import_desc) =
   | TableImport tt -> table_type tt
   | MemoryImport mt -> memory_type mt
   | GlobalImport gt -> global_type gt
+  | TagImport et -> tag_type et
 
 let export (e : export) = export_desc e.it.edesc
 let import (i : import) = import_desc i.it.idesc
@@ -181,6 +204,7 @@ let module_ (m : module_) =
   list global m.it.globals ++
   list table m.it.tables ++
   list memory m.it.memories ++
+  list tag m.it.tags ++
   list func m.it.funcs ++
   opt start m.it.start ++
   list elem m.it.elems ++
diff --git a/interpreter/syntax/free.mli b/interpreter/syntax/free.mli
index 15c72dad..d668aabb 100644
--- a/interpreter/syntax/free.mli
+++ b/interpreter/syntax/free.mli
@@ -6,6 +6,7 @@ type t =
   globals : Set.t;
   tables : Set.t;
   memories : Set.t;
+  tags : Set.t;
   funcs : Set.t;
   elems : Set.t;
   datas : Set.t;
@@ -25,6 +26,7 @@ val global : Ast.global -> t
 val func : Ast.func -> t
 val table : Ast.table -> t
 val memory : Ast.memory -> t
+val tag : Ast.tag -> t
 val elem : Ast.elem_segment -> t
 val data : Ast.data_segment -> t
 val export : Ast.export -> t
diff --git a/interpreter/syntax/operators.ml b/interpreter/syntax/operators.ml
index c1db8cec..fc05f7e5 100644
--- a/interpreter/syntax/operators.ml
+++ b/interpreter/syntax/operators.ml
@@ -24,6 +24,11 @@ let block bt es = Block (bt, es)
 let loop bt es = Loop (bt, es)
 let if_ bt es1 es2 = If (bt, es1, es2)
 
+let try_catch bt es ct ca = TryCatch (bt, es, ct, ca)
+let try_delegate bt es x = TryDelegate (bt, es, x)
+let throw x = Throw x
+let rethrow x = Rethrow x
+
 let br x = Br x
 let br_if x = BrIf x
 let br_table xs x = BrTable (xs, x)
@@ -38,6 +43,13 @@ let return_call x = ReturnCall x
 let return_call_ref x = ReturnCallRef x
 let return_call_indirect x y = ReturnCallIndirect (x, y)
 
+let cont_new x = ContNew x
+let cont_bind x y = ContBind (x, y)
+let suspend x = Suspend x
+let resume x xys = Resume (x, xys)
+let resume_throw x y xys = ResumeThrow (x, y, xys)
+let barrier bt es = Barrier (bt, es)
+
 let local_get x = LocalGet x
 let local_set x = LocalSet x
 let local_tee x = LocalTee x
diff --git a/interpreter/syntax/types.ml b/interpreter/syntax/types.ml
index 6ad99334..c93089d1 100644
--- a/interpreter/syntax/types.ml
+++ b/interpreter/syntax/types.ml
@@ -9,72 +9,67 @@ type mut = Cons | Var
 type init = Set | Unset
 type 'a limits = {min : 'a; max : 'a option}
 
-type var = StatX of type_idx
+type type_addr = ..
+type var = Stat of type_idx | Dyn of type_addr
 
 type num_type = I32T | I64T | F32T | F64T
 type vec_type = V128T
-type heap_type = FuncHT | ExternHT | VarHT of var | DefHT of def_type | BotHT
-and ref_type = null * heap_type
-and val_type = NumT of num_type | VecT of vec_type | RefT of ref_type | BotT
+type heap_type = FuncHT | ExternHT | DefHT of var | BotHT
+type ref_type = null * heap_type
+type val_type = NumT of num_type | VecT of vec_type | RefT of ref_type | BotT
 
-and result_type = val_type list
-and instr_type = InstrT of result_type * result_type * local_idx list
-and func_type = FuncT of result_type * result_type
-and def_type = DefFuncT of func_type
+type result_type = val_type list
+type instr_type = InstrT of result_type * result_type * local_idx list
+type func_type = FuncT of result_type * result_type
+type cont_type = ContT of var
+type def_type = DefFuncT of func_type | DefContT of cont_type
 
 type table_type = TableT of Int32.t limits * ref_type
 type memory_type = MemoryT of Int32.t limits
 type global_type = GlobalT of mut * val_type
 type local_type = LocalT of init * val_type
+type tag_type = TagT of var
 type extern_type =
   | ExternFuncT of func_type
   | ExternTableT of table_type
   | ExternMemoryT of memory_type
   | ExternGlobalT of global_type
+  | ExternTagT of tag_type
 
 type export_type = ExportT of extern_type * name
 type import_type = ImportT of extern_type * name * name
-type module_type = ModuleT of import_type list * export_type list
+type module_type =
+  | ModuleT of def_type list * import_type list * export_type list
 
 
 (* Attributes *)
 
-let num_size = function
+let num_size : num_type -> int = function
   | I32T | F32T -> 4
   | I64T | F64T -> 8
 
-let vec_size = function
+let vec_size : vec_type -> int = function
   | V128T -> 16
 
-let is_num_type = function
+let is_num_type : val_type -> bool = function
   | NumT _ | BotT -> true
   | _ -> false
 
-let is_vec_type = function
+let is_vec_type : val_type -> bool = function
   | VecT _ | BotT -> true
   | _ -> false
 
-let is_ref_type = function
+let is_ref_type : val_type -> bool = function
   | RefT _ | BotT -> true
   | _ -> false
 
-let defaultable = function
+let defaultable : val_type -> bool = function
   | NumT _ -> true
   | VecT _ -> true
   | RefT (nul, _) -> nul = Null
   | BotT -> assert false
 
 
-(* Projections *)
-
-let as_func_def_type (dt : def_type) : func_type =
-  match dt with
-  | DefFuncT ft -> ft
-
-let extern_type_of_import_type (ImportT (et, _, _)) = et
-let extern_type_of_export_type (ExportT (et, _)) = et
-
-
 (* Filters *)
 
 let funcs (ets : extern_type list) : func_type list =
@@ -85,7 +80,8 @@ let memories (ets : extern_type list) : memory_type list =
   Lib.List.map_filter (function ExternMemoryT mt -> Some mt | _ -> None) ets
 let globals (ets : extern_type list) : global_type list =
   Lib.List.map_filter (function ExternGlobalT gt -> Some gt | _ -> None) ets
-
+let tags (ets : extern_type list) : tag_type list =
+  Lib.List.map_filter (function ExternTagT t -> Some t | _ -> None) ets
 
 (* String conversion *)
 
@@ -106,152 +102,222 @@ let string_of_name n =
   List.iter escape n;
   Buffer.contents b
 
-let string_of_var = function
-  | StatX x -> I32.to_string_u x
-
-let string_of_null = function
+let string_of_null : null -> string = function
   | NoNull -> ""
   | Null -> "null "
 
-let string_of_limits = function
-  | {min; max} ->
-    I32.to_string_u min ^
-    (match max with None -> "" | Some n -> " " ^ I32.to_string_u n)
+let string_of_addr' = ref (fun (a : type_addr) -> assert false)
+let string_of_addr a = !string_of_addr' a
 
+let string_of_var : var -> string = function
+  | Stat x -> I32.to_string_u x
+  | Dyn a -> string_of_addr a
 
-let string_of_num_type = function
+let string_of_num_type : num_type -> string = function
   | I32T -> "i32"
   | I64T -> "i64"
   | F32T -> "f32"
   | F64T -> "f64"
 
-let string_of_vec_type = function
+let string_of_vec_type : vec_type -> string = function
   | V128T -> "v128"
 
-let rec string_of_heap_type = function
+let string_of_heap_type : heap_type -> string = function
   | FuncHT -> "func"
   | ExternHT -> "extern"
-  | VarHT x -> string_of_var x
-  | DefHT dt -> string_of_def_type dt
-  | BotHT -> "none"
+  | DefHT x -> string_of_var x
+  | BotHT -> "something"
 
-and string_of_ref_type = function
+let string_of_ref_type : ref_type -> string = function
   | (nul, t) ->
     "(ref " ^ string_of_null nul ^ string_of_heap_type t ^ ")"
 
-and string_of_val_type = function
+let string_of_val_type : val_type -> string = function
   | NumT t -> string_of_num_type t
   | VecT t -> string_of_vec_type t
   | RefT t -> string_of_ref_type t
-  | BotT -> "bot"
+  | BotT -> "(something)"
 
-and string_of_result_type = function
+let string_of_result_type : result_type -> string = function
   | ts -> "[" ^ String.concat " " (List.map string_of_val_type ts) ^ "]"
 
-and string_of_func_type = function
+let string_of_func_type : func_type -> string = function
   | FuncT (ts1, ts2) ->
     string_of_result_type ts1 ^ " -> " ^ string_of_result_type ts2
 
-and string_of_def_type = function
+let string_of_cont_type = function
+  | ContT x -> string_of_var x
+
+let string_of_def_type : def_type -> string = function
   | DefFuncT ft -> "func " ^ string_of_func_type ft
+  | DefContT ct -> "cont " ^ string_of_cont_type ct
 
+let string_of_tag_type (TagT x) = string_of_var x
 
-let string_of_memory_type = function
+let string_of_limits : I32.t limits -> string = function
+  | {min; max} ->
+    I32.to_string_u min ^
+    (match max with None -> "" | Some n -> " " ^ I32.to_string_u n)
+
+let string_of_memory_type : memory_type -> string = function
   | MemoryT lim -> string_of_limits lim
 
-let string_of_table_type = function
+let string_of_table_type : table_type -> string = function
   | TableT (lim, t) -> string_of_limits lim ^ " " ^ string_of_ref_type t
 
-let string_of_global_type = function
+let string_of_global_type : global_type -> string = function
   | GlobalT (Cons, t) -> string_of_val_type t
   | GlobalT (Var, t) -> "(mut " ^ string_of_val_type t ^ ")"
 
-let string_of_local_type = function
+let string_of_local_type : local_type -> string = function
   | LocalT (Set, t) -> string_of_val_type t
   | LocalT (Unset, t) -> "(unset " ^ string_of_val_type t ^ ")"
 
-let string_of_extern_type = function
+let string_of_extern_type : extern_type -> string = function
   | ExternFuncT ft -> "func " ^ string_of_func_type ft
   | ExternTableT tt -> "table " ^ string_of_table_type tt
   | ExternMemoryT mt -> "memory " ^ string_of_memory_type mt
   | ExternGlobalT gt -> "global " ^ string_of_global_type gt
+  | ExternTagT t -> "tag " ^ string_of_tag_type t
 
 
-let string_of_export_type = function
+let string_of_export_type : export_type -> string = function
   | ExportT (et, name) ->
     "\"" ^ string_of_name name ^ "\" : " ^ string_of_extern_type et
 
-let string_of_import_type = function
+let string_of_import_type : import_type -> string = function
   | ImportT (et, module_name, name) ->
     "\"" ^ string_of_name module_name ^ "\" \"" ^
       string_of_name name ^ "\" : " ^ string_of_extern_type et
 
-let string_of_module_type = function
-  | ModuleT (its, ets) ->
+let string_of_module_type : module_type -> string = function
+  | ModuleT (dts, its, ets) ->
     String.concat "" (
+      List.mapi (fun i dt -> "type " ^ string_of_int i ^ " = " ^ string_of_def_type dt ^ "\n") dts @
       List.map (fun it -> "import " ^ string_of_import_type it ^ "\n") its @
       List.map (fun et -> "export " ^ string_of_export_type et ^ "\n") ets
     )
 
+(* Dynamic Types *)
+
+type type_addr += Addr of def_type Lib.Promise.t
+
+let unwrap = function
+  | Addr p -> p
+  | _ -> assert false
+
+let alloc_uninit () = Addr (Lib.Promise.make ())
+let init x dt = Lib.Promise.fulfill (unwrap x) dt
+let alloc dt = let x = alloc_uninit () in init x dt; x
+let def_of x = Lib.Promise.value (unwrap x)
+
+let () = string_of_addr' :=
+  let inner = ref false in
+  fun x ->
+    if !inner then "..." else
+    ( inner := true;
+      try
+        let s = string_of_def_type (def_of x) in
+        inner := false; "(" ^ s ^ ")"
+      with exn -> inner := false; raise exn
+    )
+
 
-(* Substitution *)
+(* Instantiation *)
 
-type subst = var -> heap_type
+let dyn_var_type c = function
+  | Stat x -> Dyn (Lib.List32.nth c x)
+  | Dyn a -> assert false
 
-let subst_num_type s t = t
+let dyn_num_type c = function
+  | t -> t
 
-let subst_vec_type s t = t
+let dyn_vec_type c = function
+  | t -> t
 
-let subst_heap_type s = function
+let dyn_heap_type c = function
   | FuncHT -> FuncHT
   | ExternHT -> ExternHT
-  | VarHT x -> s x
-  | DefHT ht -> DefHT ht  (* assume closed *)
+  | DefHT x -> DefHT (dyn_var_type c x)
   | BotHT -> BotHT
 
-let subst_ref_type s = function
-  | (nul, t) -> (nul, subst_heap_type s t)
+let dyn_ref_type c = function
+  | (nul, t) -> (nul, dyn_heap_type c t)
 
-let subst_val_type s = function
-  | NumT t -> NumT (subst_num_type s t)
-  | VecT t -> VecT (subst_vec_type s t)
-  | RefT t -> RefT (subst_ref_type s t)
+let dyn_val_type c = function
+  | NumT t -> NumT (dyn_num_type c t)
+  | VecT t -> VecT (dyn_vec_type c t)
+  | RefT t -> RefT (dyn_ref_type c t)
   | BotT -> BotT
 
-let subst_result_type s = function
-  | ts -> List.map (subst_val_type s) ts
+let dyn_result_type c = function
+  | ts -> List.map (dyn_val_type c) ts
+
+let dyn_func_type c = function
+  | FuncT (ts1, ts2) -> FuncT (dyn_result_type c ts1, dyn_result_type c ts2)
 
-let subst_func_type s = function
-  | FuncT (ts1, ts2) -> FuncT (subst_result_type s ts1, subst_result_type s ts2)
+let dyn_cont_type c = function
+  | ContT x -> ContT (dyn_var_type c x)
 
-let subst_def_type s = function
-  | DefFuncT ft -> DefFuncT (subst_func_type s ft)
+let dyn_def_type c = function
+  | DefFuncT ft -> DefFuncT (dyn_func_type c ft)
+  | DefContT x  -> DefContT (dyn_cont_type c x)
 
-let subst_memory_type s = function
+let dyn_local_type c = function
+  | LocalT (init, t) -> LocalT (init, dyn_val_type c t)
+
+let dyn_memory_type c = function
   | MemoryT lim -> MemoryT lim
 
-let subst_table_type s = function
-  | TableT (lim, t) -> TableT (lim, subst_ref_type s t)
+let dyn_table_type c = function
+  | TableT (lim, t) -> TableT (lim, dyn_ref_type c t)
+
+let dyn_global_type c = function
+  | GlobalT (mut, t) -> GlobalT (mut, dyn_val_type c t)
 
-let subst_global_type s = function
-  | GlobalT (mut, t) ->  GlobalT (mut, subst_val_type s t)
+let dyn_tag_type c = function
+  | TagT t -> TagT (dyn_var_type c t)
 
-let subst_extern_type s = function
-  | ExternFuncT ft -> ExternFuncT (subst_func_type s ft)
-  | ExternTableT tt -> ExternTableT (subst_table_type s tt)
-  | ExternMemoryT mt -> ExternMemoryT (subst_memory_type s mt)
-  | ExternGlobalT gt -> ExternGlobalT (subst_global_type s gt)
+let dyn_extern_type c = function
+  | ExternFuncT ft -> ExternFuncT (dyn_func_type c ft)
+  | ExternTableT tt -> ExternTableT (dyn_table_type c tt)
+  | ExternMemoryT mt -> ExternMemoryT (dyn_memory_type c mt)
+  | ExternGlobalT gt -> ExternGlobalT (dyn_global_type c gt)
+  | ExternTagT t -> ExternTagT (dyn_tag_type c t)
 
-let subst_export_type s = function
-  | ExportT (et, name) -> ExportT (subst_extern_type s et, name)
+let dyn_export_type c = function
+  | ExportT (et, name) -> ExportT (dyn_extern_type c et, name)
 
-let subst_import_type s = function
+let dyn_import_type c = function
   | ImportT (et, module_name, name) ->
-    ImportT (subst_extern_type s et, module_name, name)
+    ImportT (dyn_extern_type c et, module_name, name)
 
-let subst_module_type s = function
-  | ModuleT (its, ets) ->
-    ModuleT (
-      List.map (subst_import_type s) its,
-      List.map (subst_export_type s) ets
-    )
+let dyn_module_type = function
+  | ModuleT (dts, its, ets) ->
+    let c = List.map (fun _ -> alloc_uninit ()) dts in
+    List.iter2 (fun a dt -> init a (dyn_def_type c dt)) c dts;
+    let its = List.map (dyn_import_type c) its in
+    let ets = List.map (dyn_export_type c) ets in
+    ModuleT ([], its, ets)
+
+(* Projections *)
+let as_stat_var = function
+  | Stat x -> x
+  | Dyn _ -> assert false
+
+let as_dyn_var = function
+  | Dyn a -> a
+  | Stat _ -> assert false
+
+let as_func_def_type (dt : def_type) : func_type =
+  match dt with
+  | DefFuncT ft -> ft
+  | _ -> assert false
+
+let as_cont_def_type (dt : def_type) : cont_type =
+  match dt with
+  | DefContT ct -> ct
+  | _ -> assert false
+
+let extern_type_of_import_type (ImportT (et, _, _)) = et
+let extern_type_of_export_type (ExportT (et, _)) = et
diff --git a/interpreter/text/arrange.ml b/interpreter/text/arrange.ml
index 4e2ce1bf..78c54e27 100644
--- a/interpreter/text/arrange.ml
+++ b/interpreter/text/arrange.ml
@@ -56,6 +56,7 @@ let break_string s =
 
 (* Types *)
 
+let var_type t = string_of_var t
 let num_type t = string_of_num_type t
 let vec_type t = string_of_vec_type t
 let ref_type t = string_of_ref_type t
@@ -67,9 +68,13 @@ let decls kind ts = tab kind (atom val_type) ts
 let func_type (FuncT (ts1, ts2)) =
   Node ("func", decls "param" ts1 @ decls "result" ts2)
 
+let cont_type (ContT x) =
+  Node ("cont", [Atom (var_type x)])
+
 let def_type dt =
   match dt with
   | DefFuncT ft -> func_type ft
+  | DefContT ct -> cont_type ct
 
 let limits nat {min; max} =
   String.concat " " (nat min :: opt nat max)
@@ -448,6 +453,18 @@ let rec instr e =
     | If (bt, es1, es2) ->
       "if", block_type bt @
         [Node ("then", list instr es1); Node ("else", list instr es2)]
+    | TryCatch (bt, es, ct, ca) ->
+      let catch (tag, es) = Node ("catch " ^ var tag, list instr es) in
+      let catch_all = match ca with
+        | Some es -> [Node ("catch_all", list instr es)]
+        | None -> [] in
+      let handler = list catch ct @ catch_all in
+      "try", block_type bt @ [Node ("do", list instr es)] @ handler
+    | TryDelegate (bt, es, x) ->
+      let delegate = [Node ("delegate " ^ var x, [])] in
+      "try", block_type bt @ [Node ("do", list instr es)] @ delegate
+    | Throw x -> "throw " ^ var x, []
+    | Rethrow x -> "rethrow " ^ var x, []
     | Br x -> "br " ^ var x, []
     | BrIf x -> "br_if " ^ var x, []
     | BrTable (xs, x) ->
@@ -463,6 +480,16 @@ let rec instr e =
     | ReturnCallRef x -> "return_call_ref " ^ var x, []
     | ReturnCallIndirect (x, y) ->
       "return_call_indirect " ^ var x, [Node ("type " ^ var y, [])]
+    | ContNew x -> "cont.new " ^ var x, []
+    | ContBind (x, y) -> "cont.bind " ^ var x ^ " " ^ var y, []
+    | Suspend x -> "suspend " ^ var x, []
+    | Resume (x, xys) ->
+      "resume " ^ var x,
+      List.map (fun (x, y) -> Node ("tag " ^ var x ^ " " ^ var y, [])) xys
+    | ResumeThrow (x, y, xys) ->
+      "resume_throw " ^ var x ^ " " ^ var y,
+      List.map (fun (x, y) -> Node ("tag " ^ var x ^ " " ^ var y, [])) xys
+    | Barrier (bt, es) -> "barrier", block_type bt @ list instr es
     | LocalGet x -> "local.get " ^ var x, []
     | LocalSet x -> "local.set " ^ var x, []
     | LocalTee x -> "local.tee " ^ var x, []
@@ -550,6 +577,12 @@ let memory off i mem =
   let {mtype = MemoryT lim} = mem.it in
   Node ("memory $" ^ nat (off + i) ^ " " ^ limits nat32 lim, [])
 
+let tag off i tag =
+  let {tagtype = TagT x} = tag.it in
+  Node ("tag $" ^ nat (off + i),
+    [Node ("type", [atom var_type x])]
+  )
+
 let is_elem_kind = function
   | (NoNull, FuncHT) -> true
   | _ -> false
@@ -596,7 +629,7 @@ let data i seg =
 let type_ i ty =
   Node ("type $" ^ nat i, [def_type ty.it])
 
-let import_desc fx tx mx gx d =
+let import_desc fx tx mx ex gx d =
   match d.it with
   | FuncImport x ->
     incr fx; Node ("func $" ^ nat (!fx - 1), [Node ("type", [atom var x])])
@@ -604,13 +637,15 @@ let import_desc fx tx mx gx d =
     incr tx; table 0 (!tx - 1) ({ttype = t; tinit = [] @@ d.at} @@ d.at)
   | MemoryImport t ->
     incr mx; memory 0 (!mx - 1) ({mtype = t} @@ d.at)
+  | TagImport t ->
+    incr ex; tag 0 (!ex - 1) ({tagtype = t} @@ d.at)
   | GlobalImport t ->
     incr gx; Node ("global $" ^ nat (!gx - 1), [global_type t])
 
-let import fx tx mx gx im =
+let import fx tx mx ex gx im =
   let {module_name; item_name; idesc} = im.it in
   Node ("import",
-    [atom name module_name; atom name item_name; import_desc fx tx mx gx idesc]
+    [atom name module_name; atom name item_name; import_desc fx tx mx ex gx idesc]
   )
 
 let export_desc d =
@@ -619,6 +654,7 @@ let export_desc d =
   | TableExport x -> Node ("table", [atom var x])
   | MemoryExport x -> Node ("memory", [atom var x])
   | GlobalExport x -> Node ("global", [atom var x])
+  | TagExport x -> Node ("tag", [atom var x])
 
 let export ex =
   let {name = n; edesc} = ex.it in
@@ -642,13 +678,15 @@ let module_with_var_opt x_opt m =
   let fx = ref 0 in
   let tx = ref 0 in
   let mx = ref 0 in
+  let ex = ref 0 in
   let gx = ref 0 in
-  let imports = list (import fx tx mx gx) m.it.imports in
+  let imports = list (import fx tx mx ex gx) m.it.imports in
   Node ("module" ^ var_opt x_opt,
     listi type_ m.it.types @
     imports @
     listi (table !tx) m.it.tables @
     listi (memory !mx) m.it.memories @
+    listi (tag !ex) m.it.tags @
     listi (global !gx) m.it.globals @
     listi (func_with_index !fx) m.it.funcs @
     list export m.it.exports @
@@ -774,6 +812,10 @@ let assertion mode ass =
     [Node ("assert_return", action mode act :: List.map (result mode) results)]
   | AssertTrap (act, re) ->
     [Node ("assert_trap", [action mode act; Atom (string re)])]
+  | AssertException (act, re) ->
+    [Node ("assert_exception", [action mode act; Atom (string re)])]
+  | AssertSuspension (act, re) ->
+    [Node ("assert_suspension", [action mode act; Atom (string re)])]
   | AssertExhaustion (act, re) ->
     [Node ("assert_exhaustion", [action mode act; Atom (string re)])]
 
diff --git a/interpreter/text/lexer.mll b/interpreter/text/lexer.mll
index 0ca338d2..def5aeb9 100644
--- a/interpreter/text/lexer.mll
+++ b/interpreter/text/lexer.mll
@@ -154,6 +154,8 @@ rule token = parse
       | "ref" -> REF
       | "null" -> NULL
       | "mut" -> MUT
+      | "tag" -> TAG
+      | "cont" -> CONT
 
       | "nop" -> NOP
       | "unreachable" -> UNREACHABLE
@@ -178,6 +180,22 @@ rule token = parse
       | "return_call_ref" -> RETURN_CALL_REF
       | "return_call_indirect" -> RETURN_CALL_INDIRECT
 
+      | "try" -> TRY
+      | "do" -> DO
+      | "catch" -> CATCH
+      | "catch_all" -> CATCH_ALL
+      | "delegate" -> DELEGATE
+      | "throw" -> THROW
+      | "rethrow" -> RETHROW
+
+      | "cont.new" -> CONT_NEW
+      | "cont.bind" -> CONT_BIND
+      | "suspend" -> SUSPEND
+      | "resume" -> RESUME
+      | "resume_throw" -> RESUME_THROW
+      | "barrier" -> BARRIER
+
+
       | "local.get" -> LOCAL_GET
       | "local.set" -> LOCAL_SET
       | "local.tee" -> LOCAL_TEE
@@ -694,6 +712,8 @@ rule token = parse
       | "assert_return" -> ASSERT_RETURN
       | "assert_trap" -> ASSERT_TRAP
       | "assert_exhaustion" -> ASSERT_EXHAUSTION
+      | "assert_exception" -> ASSERT_EXCEPTION
+      | "assert_suspension" -> ASSERT_SUSPENSION
       | "nan:canonical" -> NAN Script.CanonicalNan
       | "nan:arithmetic" -> NAN Script.ArithmeticNan
       | "input" -> INPUT
diff --git a/interpreter/text/parser.mly b/interpreter/text/parser.mly
index c8bc44c6..6f458cfe 100644
--- a/interpreter/text/parser.mly
+++ b/interpreter/text/parser.mly
@@ -118,14 +118,16 @@ type types = {space : space; mutable list : type_ list}
 let empty_types () = {space = empty (); list = []}
 
 type context =
-  { types : types; tables : space; memories : space;
+  { types : types;
+    tables : space; memories : space; tags : space;
     funcs : space; locals : space; globals : space;
     datas : space; elems : space; labels : space;
     deferred_locals : (unit -> unit) list ref
   }
 
 let empty_context () =
-  { types = empty_types (); tables = empty (); memories = empty ();
+  { types = empty_types ();
+    tables = empty (); memories = empty (); tags = empty ();
     funcs = empty (); locals = empty (); globals = empty ();
     datas = empty (); elems = empty (); labels = empty ();
     deferred_locals = ref []
@@ -153,6 +155,7 @@ let local (c : context) x = lookup "local" c.locals x
 let global (c : context) x = lookup "global" c.globals x
 let table (c : context) x = lookup "table" c.tables x
 let memory (c : context) x = lookup "memory" c.memories x
+let tag (c : context) x = lookup "tag" c.tags x
 let elem (c : context) x = lookup "elem segment" c.elems x
 let data (c : context) x = lookup "data segment" c.datas x
 let label (c : context) x = lookup "label " c.labels x
@@ -160,8 +163,11 @@ let label (c : context) x = lookup "label " c.labels x
 let func_type (c : context) x =
   match (Lib.List32.nth c.types.list x.it).it with
   | DefFuncT ft -> ft
+  | _ -> error x.at ("non-function type " ^ Int32.to_string x.it)
   | exception Failure _ -> error x.at ("unknown type " ^ Int32.to_string x.it)
 
+let handlers (c : context) h =
+  List.map (fun (l, i) -> (l c tag, i c)) h
 
 let bind_abs category space x =
   if VarMap.mem x.it space.map then
@@ -181,6 +187,7 @@ let bind_local (c : context) x = force_locals c; bind_abs "local" c.locals x
 let bind_global (c : context) x = bind_abs "global" c.globals x
 let bind_table (c : context) x = bind_abs "table" c.tables x
 let bind_memory (c : context) x = bind_abs "memory" c.memories x
+let bind_tag (c : context) x = bind_abs "tag" c.tags x
 let bind_elem (c : context) x = bind_abs "elem segment" c.elems x
 let bind_data (c : context) x = bind_abs "data segment" c.datas x
 let bind_label (c : context) x = bind_rel "label" c.labels x
@@ -197,6 +204,7 @@ let anon_locals (c : context) n at =
 let anon_global (c : context) at = bind "global" c.globals 1l at
 let anon_table (c : context) at = bind "table" c.tables 1l at
 let anon_memory (c : context) at = bind "memory" c.memories 1l at
+let anon_tag (c : context) at = bind "tag" c.tags 1l at
 let anon_elem (c : context) at = bind "elem segment" c.elems 1l at
 let anon_data (c : context) at = bind "data segment" c.datas 1l at
 let anon_label (c : context) at = bind "label" c.labels 1l at
@@ -222,6 +230,7 @@ let inline_func_type_explicit (c : context) x ft at =
     error at "inline function type does not match explicit type";
   x
 
+
 %}
 
 %token LPAR RPAR
@@ -231,7 +240,9 @@ let inline_func_type_explicit (c : context) x ft at =
 %token<V128.shape> VEC_SHAPE
 %token FUNCREF EXTERNREF REF EXTERN NULL MUT
 %token UNREACHABLE NOP DROP SELECT
-%token BLOCK END IF THEN ELSE LOOP
+%token BLOCK END IF THEN ELSE LOOP TRY DO CATCH CATCH_ALL
+%token DELEGATE
+%token CONT_NEW CONT_BIND SUSPEND RESUME RESUME_THROW BARRIER
 %token BR BR_IF BR_TABLE BR_ON_NULL BR_ON_NON_NULL
 %token CALL CALL_REF CALL_INDIRECT
 %token RETURN RETURN_CALL RETURN_CALL_REF RETURN_CALL_INDIRECT
@@ -244,6 +255,7 @@ let inline_func_type_explicit (c : context) x ft at =
 %token<string Source.phrase -> Ast.instr' * Value.num> CONST
 %token<Ast.instr'> UNARY BINARY TEST COMPARE CONVERT
 %token REF_NULL REF_FUNC REF_EXTERN REF_IS_NULL REF_AS_NON_NULL
+%token THROW RETHROW
 %token<int option -> Memory.offset -> Ast.instr'> VEC_LOAD VEC_STORE
 %token<int option -> Memory.offset -> int -> Ast.instr'> VEC_LOAD_LANE VEC_STORE_LANE
 %token<V128.shape -> string Source.phrase list -> Source.region -> Ast.instr' * Value.vec> VEC_CONST
@@ -251,12 +263,12 @@ let inline_func_type_explicit (c : context) x ft at =
 %token<Ast.instr'> VEC_SHIFT VEC_BITMASK VEC_SPLAT
 %token VEC_SHUFFLE
 %token<int -> Ast.instr'> VEC_EXTRACT VEC_REPLACE
-%token FUNC START TYPE PARAM RESULT LOCAL GLOBAL
+%token FUNC START TYPE PARAM RESULT LOCAL GLOBAL TAG CONT
 %token TABLE ELEM MEMORY DATA DECLARE OFFSET ITEM IMPORT EXPORT
 %token MODULE BIN QUOTE
 %token SCRIPT REGISTER INVOKE GET
 %token ASSERT_MALFORMED ASSERT_INVALID ASSERT_UNLINKABLE
-%token ASSERT_RETURN ASSERT_TRAP ASSERT_EXHAUSTION
+%token ASSERT_RETURN ASSERT_TRAP ASSERT_EXHAUSTION ASSERT_EXCEPTION ASSERT_SUSPENSION
 %token<Script.nan> NAN
 %token INPUT OUTPUT
 %token EOF
@@ -287,7 +299,7 @@ null_opt :
 heap_type :
   | FUNC { fun c -> FuncHT }
   | EXTERN { fun c -> ExternHT }
-  | var { fun c -> VarHT (StatX ($1 c type_).it) }
+  | var { fun c -> DefHT (Stat ($1 c type_).it) }
 
 ref_type :
   | LPAR REF null_opt heap_type RPAR { fun c -> ($3, $4 c) }
@@ -309,6 +321,33 @@ global_type :
 
 def_type :
   | LPAR FUNC func_type RPAR { fun c -> DefFuncT ($3 c) }
+  | LPAR CONT cont_type RPAR { fun c -> DefContT (ContT (Stat ($3 c).it)) }
+
+cont_type :
+  | type_use cont_type_params
+    { let at1 = ati 1 in
+      fun c ->
+      match $2 c with
+      | FuncT ([], []) -> $1 c
+      | ft -> inline_func_type_explicit c ($1 c) ft at1 }
+  | cont_type_params
+    /* TODO: the inline type is broken for now */
+    { let at = at () in fun c -> inline_func_type c ($1 c) at }
+  | var  /* Sugar */
+    { fun c -> $1 c type_ }
+
+cont_type_params :
+  | LPAR PARAM val_type_list RPAR cont_type_params
+    { fun c -> let FuncT (ts1, ts2) = $5 c in
+      FuncT (snd $3 c @ ts1, ts2) }
+  | cont_type_results
+    { fun c -> FuncT ([], $1 c) }
+
+cont_type_results :
+  | LPAR RESULT val_type_list RPAR cont_type_results
+    { fun c -> snd $3 c @ $5 c }
+  | /* empty */
+    { fun c -> [] }
 
 func_type :
   | func_type_result
@@ -326,6 +365,12 @@ func_type_result :
   | LPAR RESULT val_type_list RPAR func_type_result
     { fun c -> snd $3 c @ $5 c }
 
+tag_type :
+  | type_use
+    { fun c -> TagT (Stat ($1 c).it) }
+  | func_type
+    { let at = at () in fun c -> TagT (Stat (inline_func_type c ($1 c) at).it) }
+
 table_type :
   | limits ref_type { fun c -> TableT ($1, $2 c) }
 
@@ -403,6 +448,7 @@ instr_list :
   | instr1 instr_list { fun c -> $1 c @ $2 c }
   | select_instr_instr_list { $1 }
   | call_instr_instr_list { $1 }
+  | resume_instr_instr { fun c -> let e, es = $1 c in e :: es }
 
 instr1 :
   | plain_instr { let at = at () in fun c -> [$1 c @@ at] }
@@ -413,6 +459,8 @@ plain_instr :
   | UNREACHABLE { fun c -> unreachable }
   | NOP { fun c -> nop }
   | DROP { fun c -> drop }
+  | THROW var { fun c -> throw ($2 c tag) }
+  | RETHROW var { fun c -> rethrow ($2 c label)  }
   | BR var { fun c -> br ($2 c label) }
   | BR_IF var { fun c -> br_if ($2 c label) }
   | BR_TABLE var var_list
@@ -425,6 +473,9 @@ plain_instr :
   | CALL_REF var { fun c -> call_ref ($2 c type_) }
   | RETURN_CALL var { fun c -> return_call ($2 c func) }
   | RETURN_CALL_REF var { fun c -> return_call_ref ($2 c type_) }
+  | CONT_NEW var { fun c -> cont_new ($2 c type_) }
+  | CONT_BIND var var { fun c -> cont_bind ($2 c type_) ($3 c type_) }
+  | SUSPEND var { fun c -> suspend ($2 c tag) }
   | LOCAL_GET var { fun c -> local_get ($2 c local) }
   | LOCAL_SET var { fun c -> local_set ($2 c local) }
   | LOCAL_TEE var { fun c -> local_tee ($2 c local) }
@@ -539,6 +590,63 @@ call_instr_results_instr_list :
   | instr_list
     { fun c -> [], $1 c }
 
+handler_instr :
+  | catch_list_instr END
+    { fun bt es c -> try_catch bt es (handlers c $1) None }
+  | catch_list_instr catch_all END
+    { fun bt es c -> try_catch bt es (handlers c $1) (Some ($2 c)) }
+  | catch_all END
+    { fun bt es c -> try_catch bt es [] (Some ($1 c)) }
+  | END { fun bt es c -> try_catch bt es [] None }
+
+
+catch_list_instr :
+  | catch catch_list_instr { $1 :: $2 }
+  | catch { [$1] }
+
+handler :
+  | catch_list
+      { fun bt es _ c' ->
+        let cs = (List.map (fun (l, i) -> (l c' tag, i c')) $1) in
+        try_catch bt es cs None }
+  | catch_list LPAR catch_all RPAR
+    { fun bt es _ c' ->
+      let cs = (List.map (fun (l, i) -> (l c' tag, i c')) $1) in
+      try_catch bt es cs (Some ($3 c')) }
+  | LPAR catch_all RPAR
+    { fun bt es _ c' -> try_catch bt es [] (Some ($2 c')) }
+  | LPAR DELEGATE var RPAR
+    { fun bt es c _ -> try_delegate bt es ($3 c label) }
+  | /* empty */ { fun bt es c _ -> try_catch bt es [] None }
+
+catch_list :
+  | catch_list LPAR catch RPAR { $1 @ [$3] }
+  | LPAR catch RPAR { [$2] }
+
+catch :
+  | CATCH var instr_list { ($2, $3) }
+
+catch_all :
+  | CATCH_ALL instr_list { $2 }
+
+resume_instr_instr :
+  | RESUME var resume_instr_handler_instr
+    { let at1 = ati 1 in
+      fun c ->
+      let x = $2 c type_ in
+      let hs, es = $3 c in resume x hs @@ at1, es }
+  | RESUME_THROW var var resume_instr_handler_instr
+    { let at1 = ati 1 in
+      fun c ->
+      let x  = $2 c type_ in
+      let tag = $3 c tag in
+      let hs, es = $4 c in resume_throw x tag hs @@ at1, es }
+
+resume_instr_handler_instr :
+  | LPAR TAG var var RPAR resume_instr_handler_instr
+    { fun c -> let hs, es = $6 c in ($3 c tag, $4 c label) :: hs, es }
+  | instr1
+    { fun c -> [], $1 c }
 
 block_instr :
   | BLOCK labeling_opt block END labeling_end_opt
@@ -550,6 +658,14 @@ block_instr :
   | IF labeling_opt block ELSE labeling_end_opt instr_list END labeling_end_opt
     { fun c -> let c' = $2 c ($5 @ $8) in
       let ts, es1 = $3 c' in if_ ts es1 ($6 c') }
+  | TRY labeling_opt block handler_instr
+    { fun c -> let c' = $2 c [] in
+      let ts, es = $3 c' in  $4 ts es c' }
+  | TRY labeling_opt block DELEGATE var
+    { fun c -> let c' = $2 c [] in
+      let ts, es = $3 c' in try_delegate ts es ($5 c label) }
+  | BARRIER labeling_opt block END labeling_end_opt
+    { fun c -> let c' = $2 c $5 in let bt, es = $3 c' in barrier bt es }
 
 block :
   | type_use block_param_body
@@ -598,6 +714,16 @@ expr1 :  /* Sugar */
   | RETURN_CALL_INDIRECT call_expr_type  /* Sugar */
     { let at1 = ati 1 in
       fun c -> let x, es = $2 c in es, return_call_indirect (0l @@ at1) x }
+  | RESUME var resume_expr_handler
+    { fun c ->
+      let x = $2 c type_ in
+      let hs, es = $3 c in es, resume x hs }
+  | RESUME_THROW var var resume_expr_handler
+    { fun c ->
+      let x = $2 c type_ in
+      let tag = $3 c tag in
+      let hs, es = $4 c in
+      es, resume_throw x tag hs }
   | BLOCK labeling_opt block
     { fun c -> let c' = $2 c [] in let bt, es = $3 c' in [], block bt es }
   | LOOP labeling_opt block
@@ -605,6 +731,10 @@ expr1 :  /* Sugar */
   | IF labeling_opt if_block
     { fun c -> let c' = $2 c [] in
       let bt, (es, es1, es2) = $3 c c' in es, if_ bt es1 es2 }
+  | TRY labeling_opt try_block
+    { fun c -> let c' = $2 c [] in [], $3 c c' }
+  | BARRIER labeling_opt block
+    { fun c -> let c' = $2 c [] in let bt, es = $3 c' in [], barrier bt es }
 
 select_expr_results :
   | LPAR RESULT val_type_list RPAR select_expr_results
@@ -636,6 +766,11 @@ call_expr_results :
   | expr_list
     { fun c -> [], $1 c }
 
+resume_expr_handler :
+  | LPAR TAG var var RPAR resume_expr_handler
+    { fun c -> let hs, es = $6 c in ($3 c tag, $4 c label) :: hs, es }
+  | expr_list
+    { fun c -> [], $1 c }
 
 if_block :
   | type_use if_block_param_body
@@ -674,6 +809,43 @@ if_ :
   | LPAR THEN instr_list RPAR  /* Sugar */
     { fun c c' -> [], $3 c', [] }
 
+try_block :
+  | type_use try_block_param_body
+    { let at = at () in
+      fun c c' ->
+      let body = $2 c in
+      let bt = VarBlockType (inline_func_type_explicit c' ($1 c') (fst body) at) in
+      snd body bt c c' }
+  | try_block_param_body  /* Sugar */
+    { let at = at () in
+      fun c c' ->
+      let body = $1 c in
+      let bt =
+        match fst body with
+        | FuncT ([], []) -> ValBlockType None
+        | FuncT ([], [t]) -> ValBlockType (Some t)
+        | ft ->  VarBlockType (inline_func_type c' ft at)
+      in snd body bt c c' }
+
+try_block_param_body :
+  | try_block_result_body { $1 }
+  | LPAR PARAM val_type_list RPAR try_block_param_body
+    { fun c ->
+      let FuncT (ins, out) = fst ($5 c) in
+      FuncT ((snd $3) c @ ins, out), snd ($5 c) }
+
+try_block_result_body :
+  | try_ { fun _c -> FuncT ([], []), $1 }
+  | LPAR RESULT val_type_list RPAR try_block_result_body
+    { fun c ->
+      let FuncT (ins, out) = fst ($5 c) in
+      let vs = (snd $3) c in
+      FuncT (ins, vs @ out), snd ($5 c) }
+
+try_ :
+  | LPAR DO instr_list RPAR handler
+    { fun bt c c' -> $5 bt ($3 c') c c' }
+
 expr_list :
   | /* empty */ { fun c -> [] }
   | expr expr_list { fun c -> $1 c @ $2 c }
@@ -771,7 +943,7 @@ local_type_list :
   | local_type local_type_list { I32.add (fst $2) 1l, fun c -> $1 c :: snd $2 c }
 
 
-/* Tables, Memories & Globals */
+/* Tables, Memories, Globals, Tags */
 
 table_use :
   | LPAR TABLE var RPAR { fun c -> $3 c }
@@ -938,6 +1110,23 @@ global_fields :
     { fun c x at -> let globs, ims, exs = $2 c x at in
       globs, ims, $1 (GlobalExport x) c :: exs }
 
+tag :
+  | LPAR TAG bind_var_opt tag_fields RPAR
+    { let at = at () in
+      fun c -> let x = $3 c anon_tag bind_tag @@ at in
+      fun () -> $4 c x at }
+
+tag_fields :
+  | tag_type
+    { fun c x at -> [{tagtype = $1 c} @@ at], [], [] }
+  | inline_import tag_type  /* Sugar */
+    { fun c x at ->
+      [],
+      [{ module_name = fst $1; item_name = snd $1;
+         idesc = TagImport ($2 c) @@ at } @@ at], [] }
+  | inline_export tag_fields  /* Sugar */
+    { fun c x at -> let evts, ims, exs = $2 c x at in
+      evts, ims, $1 (TagExport x) c :: exs }
 
 /* Imports & Exports */
 
@@ -958,6 +1147,9 @@ import_desc :
   | LPAR GLOBAL bind_var_opt global_type RPAR
     { fun c -> ignore ($3 c anon_global bind_global);
       fun () -> GlobalImport ($4 c) }
+  | LPAR TAG bind_var_opt tag_type RPAR
+    { fun c -> ignore ($3 c anon_tag bind_tag);
+      fun () -> TagImport ($4 c) }
 
 import :
   | LPAR IMPORT name name import_desc RPAR
@@ -973,6 +1165,7 @@ export_desc :
   | LPAR TABLE var RPAR { fun c -> TableExport ($3 c table) }
   | LPAR MEMORY var RPAR { fun c -> MemoryExport ($3 c memory) }
   | LPAR GLOBAL var RPAR { fun c -> GlobalExport ($3 c global) }
+  | LPAR TAG var RPAR { fun c -> TagExport ($3 c tag) }
 
 export :
   | LPAR EXPORT name export_desc RPAR
@@ -1033,6 +1226,14 @@ module_fields1 :
         error (List.hd m.imports).at "import after memory definition";
       { m with memories = mems @ m.memories; datas = data @ m.datas;
         imports = ims @ m.imports; exports = exs @ m.exports } }
+  | tag module_fields
+    { fun c -> let ef = $1 c in let mff = $2 c in
+      fun () -> let mf = mff () in
+      fun () -> let evts, ims, exs = ef () in let m = mf () in
+      if evts <> [] && m.imports <> [] then
+        error (List.hd m.imports).at "import after tag definition";
+      { m with tags = evts @ m.tags;
+        imports = ims @ m.imports; exports = exs @ m.exports } }
   | func module_fields
     { fun c -> let ff = $1 c in let mff = $2 c in
       fun () -> let mf = mff () in
@@ -1115,6 +1316,8 @@ assertion :
     { AssertUninstantiable (snd $3, $4) @@ at () }
   | LPAR ASSERT_RETURN action result_list RPAR { AssertReturn ($3, $4) @@ at () }
   | LPAR ASSERT_TRAP action STRING RPAR { AssertTrap ($3, $4) @@ at () }
+  | LPAR ASSERT_EXCEPTION action STRING RPAR { AssertException ($3, $4) @@ at () }
+  | LPAR ASSERT_SUSPENSION action STRING RPAR { AssertSuspension ($3, $4) @@ at () }
   | LPAR ASSERT_EXHAUSTION action STRING RPAR { AssertExhaustion ($3, $4) @@ at () }
 
 cmd :
@@ -1141,7 +1344,8 @@ literal_vec :
   | LPAR VEC_CONST VEC_SHAPE num_list RPAR { snd (vec $2 $3 $4 (at ())) }
 
 literal_ref :
-  | LPAR REF_NULL heap_type RPAR { Value.NullRef ($3 (empty_context ())) }
+  | LPAR REF_NULL heap_type RPAR
+    { Value.NullRef (Types.dyn_heap_type [] ($3 (empty_context ()))) }
   | LPAR REF_EXTERN NAT RPAR { Script.ExternRef (nat32 $3 (ati 3)) }
 
 literal :
diff --git a/interpreter/util/lib.ml b/interpreter/util/lib.ml
index 22018b04..e8913d1e 100644
--- a/interpreter/util/lib.ml
+++ b/interpreter/util/lib.ml
@@ -64,6 +64,10 @@ struct
   and make' n x xs =
     if n = 0 then xs else make' (n - 1) x (x::xs)
 
+  let rec table n f = table' n f []
+  and table' n f xs =
+    if n = 0 then xs else table' (n - 1) f (f (n - 1) :: xs)
+
   let rec take n xs =
     match n, xs with
     | 0, _ -> []
@@ -83,6 +87,11 @@ struct
     | n, y::ys' when n > 0 -> split' (n - 1) (y::xs) ys'
     | _ -> failwith "split"
 
+  let rec last_opt = function
+    | x::[] -> Some x
+    | _::xs -> last_opt xs
+    | [] -> None
+
   let rec last = function
     | x::[] -> x
     | _::xs -> last xs
diff --git a/interpreter/util/lib.mli b/interpreter/util/lib.mli
index 87603df5..ebad2f3e 100644
--- a/interpreter/util/lib.mli
+++ b/interpreter/util/lib.mli
@@ -15,10 +15,12 @@ end
 module List :
 sig
   val make : int -> 'a -> 'a list
+  val table : int -> (int -> 'a) -> 'a list
   val take : int -> 'a list -> 'a list (* raises Failure *)
   val drop : int -> 'a list -> 'a list (* raises Failure *)
   val split : int -> 'a list -> 'a list * 'a list (* raises Failure *)
 
+  val last_opt : 'a list -> 'a option
   val last : 'a list -> 'a (* raises Failure *)
   val split_last : 'a list -> 'a list * 'a (* raises Failure *)
 
diff --git a/interpreter/valid/match.ml b/interpreter/valid/match.ml
index 36760544..7bc1a0f5 100644
--- a/interpreter/valid/match.ml
+++ b/interpreter/valid/match.ml
@@ -1,138 +1,183 @@
 open Types
 
 
+(* Context *)
+
+type context = def_type list
+
+let lookup c = function
+  | Stat x -> Lib.List32.nth c x
+  | Dyn a -> def_of a
+
+
 (* Equivalence *)
 
-let eq_nullability nul1 nul2 =
+let eq_var x1 x2 =
+  match x1, x2 with
+  | Stat x1, Stat x2 -> x1 = x2
+  | Dyn a1, Dyn a2 -> a1 == a2
+  | _, _ -> false
+
+let eq_nullability c nul1 nul2 =
   nul1 = nul2
 
-let eq_mutability mut1 mut2 =
+let eq_mutability c mut1 mut2 =
   mut1 = mut2
 
-let eq_limits lim1 lim2 =
+let eq_limits c lim1 lim2 =
   lim1.min = lim2.min && lim1.max = lim2.max
 
-let eq_num_type t1 t2 =
+let eq_num_type c t1 t2 =
   t1 = t2
 
-let eq_vec_type t1 t2 =
+let eq_vec_type c t1 t2 =
   t1 = t2
 
-let rec eq_heap_type t1 t2 =
+let rec eq_heap_type c t1 t2 =
   match t1, t2 with
-  | DefHT dt1, DefHT dt2 -> eq_def_type dt1 dt2
+  | DefHT x1, DefHT x2 -> eq_var_type c x1 x2
   | _, _ -> t1 = t2
 
-and eq_ref_type t1 t2 =
+and eq_ref_type c t1 t2 =
   match t1, t2 with
   | (nul1, t1'), (nul2, t2') ->
-    eq_nullability nul1 nul2 && eq_heap_type t1' t2'
+    eq_nullability c nul1 nul2 && eq_heap_type c t1' t2'
 
-and eq_val_type t1 t2 =
+and eq_val_type c t1 t2 =
   match t1, t2 with
-  | NumT t1', NumT t2' -> eq_num_type t1' t2'
-  | VecT t1', VecT t2' -> eq_vec_type t1' t2'
-  | RefT t1', RefT t2' -> eq_ref_type t1' t2'
+  | NumT t1', NumT t2' -> eq_num_type c t1' t2'
+  | VecT t1', VecT t2' -> eq_vec_type c t1' t2'
+  | RefT t1', RefT t2' -> eq_ref_type c t1' t2'
   | BotT, BotT -> true
   | _, _ -> false
 
-and eq_result_type ts1 ts2 =
+and eq_result_type c ts1 ts2 =
   List.length ts1 = List.length ts2 &&
-  List.for_all2 eq_val_type ts1 ts2
+  List.for_all2 (eq_val_type c) ts1 ts2
+
+and eq_func_type c (FuncT (ts11, ts12)) (FuncT (ts21, ts22)) =
+  eq_result_type c ts11 ts21 && eq_result_type c ts12 ts22
 
-and eq_func_type (FuncT (ts11, ts12)) (FuncT (ts21, ts22)) =
-  eq_result_type ts11 ts21 && eq_result_type ts12 ts22
+and eq_cont_type c (ContT x1) (ContT x2) =
+  eq_var_type c x1 x2
 
-and eq_def_type dt1 dt2 =
+and eq_def_type c dt1 dt2 =
   match dt1, dt2 with
-  | DefFuncT ft1, DefFuncT ft2 -> eq_func_type ft1 ft2
+  | DefFuncT ft1, DefFuncT ft2 -> eq_func_type c ft1 ft2
+  | DefContT ct1, DefContT ct2 -> eq_cont_type c ct1 ct2
+  | _, _ -> false
+
+and eq_var_type c x1 x2 =
+  eq_var x1 x2 ||
+  eq_def_type c (lookup c x1) (lookup c x2)
 
 
-let eq_table_type (TableT (lim1, t1)) (TableT (lim2, t2)) =
-  eq_limits lim1 lim2 && eq_ref_type t1 t2
+let eq_table_type c (TableT (lim1, t1)) (TableT (lim2, t2)) =
+  eq_limits c lim1 lim2 && eq_ref_type c t1 t2
 
-let eq_memory_type (MemoryT lim1) (MemoryT lim2) =
-  eq_limits lim1 lim2
+let eq_memory_type c (MemoryT lim1) (MemoryT lim2) =
+  eq_limits c lim1 lim2
 
-let eq_global_type (GlobalT (mut1, t1)) (GlobalT (mut2, t2)) =
-  eq_mutability mut1 mut2 && eq_val_type t1 t2
+let eq_global_type c (GlobalT (mut1, t1)) (GlobalT (mut2, t2)) =
+  eq_mutability c mut1 mut2 && eq_val_type c t1 t2
 
-let eq_extern_type et1 et2 =
+let eq_tag_type c (TagT x1) (TagT x2) =
+  eq_var_type c x1 x2
+
+let eq_extern_type c et1 et2 =
   match et1, et2 with
-  | ExternFuncT ft1, ExternFuncT ft2 -> eq_func_type ft1 ft2
-  | ExternTableT tt1, ExternTableT tt2 -> eq_table_type tt1 tt2
-  | ExternMemoryT mt1, ExternMemoryT mt2 -> eq_memory_type mt1 mt2
-  | ExternGlobalT gt1, ExternGlobalT gt2 -> eq_global_type gt1 gt2
+  | ExternFuncT ft1, ExternFuncT ft2 -> eq_func_type c ft1 ft2
+  | ExternTableT tt1, ExternTableT tt2 -> eq_table_type c tt1 tt2
+  | ExternMemoryT mt1, ExternMemoryT mt2 -> eq_memory_type c mt1 mt2
+  | ExternGlobalT gt1, ExternGlobalT gt2 -> eq_global_type c gt1 gt2
+  | ExternTagT t1, ExternTagT t2 -> eq_tag_type c t1 t2
   | _, _ -> false
 
 
 (* Subtyping *)
 
-let match_nullability nul1 nul2 =
+let match_nullability c nul1 nul2 =
   match nul1, nul2 with
   | NoNull, Null -> true
   | _, _ -> nul1 = nul2
 
-let match_limits lim1 lim2 =
+let match_limits c lim1 lim2 =
   I32.ge_u lim1.min lim2.min &&
   match lim1.max, lim2.max with
   | _, None -> true
   | None, Some _ -> false
   | Some i, Some j -> I32.le_u i j
 
-let match_num_type t1 t2 =
+let match_num_type c t1 t2 =
   t1 = t2
 
-let match_vec_type t1 t2 =
+let match_vec_type c t1 t2 =
   t1 = t2
 
-let rec match_heap_type t1 t2 =
+let rec match_heap_type c t1 t2 =
   match t1, t2 with
-  | DefHT (DefFuncT _), FuncHT -> true
-  | DefHT dt1, DefHT dt2 -> match_def_type dt1 dt2
+  | DefHT x1, FuncHT ->
+    (match lookup c x1 with
+    | DefFuncT _ -> true
+    | _ -> false
+    )
+  | DefHT x1, DefHT x2 -> match_var_type c x1 x2
   | BotHT, _ -> true
-  | _, _ -> eq_heap_type t1 t2
+  | _, _ -> eq_heap_type c t1 t2
 
-and match_ref_type t1 t2 =
+and match_ref_type c t1 t2 =
   match t1, t2 with
   | (nul1, t1'), (nul2, t2') ->
-    match_nullability nul1 nul2 && match_heap_type t1' t2'
+    match_nullability c nul1 nul2 && match_heap_type c t1' t2'
 
-and match_val_type t1 t2 =
+and match_val_type c t1 t2 =
   match t1, t2 with
-  | NumT t1', NumT t2' -> match_num_type t1' t2'
-  | VecT t1', VecT t2' -> match_vec_type t1' t2'
-  | RefT t1', RefT t2' -> match_ref_type t1' t2'
+  | NumT t1', NumT t2' -> match_num_type c t1' t2'
+  | VecT t1', VecT t2' -> match_vec_type c t1' t2'
+  | RefT t1', RefT t2' -> match_ref_type c t1' t2'
   | BotT, _ -> true
   | _, _ -> false
 
-and match_result_type ts1 ts2 =
+and match_result_type c ts1 ts2 =
   List.length ts1 = List.length ts2 &&
-  List.for_all2 match_val_type ts1 ts2
+  List.for_all2 (match_val_type c) ts1 ts2
 
-and match_func_type ft1 ft2 =
-  eq_func_type ft1 ft2
+and match_func_type c ft1 ft2 =
+  eq_func_type c ft1 ft2
 
-and match_def_type dt1 dt2 =
+and match_def_type c dt1 dt2 =
   match dt1, dt2 with
-  | DefFuncT ft1, DefFuncT ft2 -> match_func_type ft1 ft2
+  | DefFuncT ft1, DefFuncT ft2 -> match_func_type c ft1 ft2
+  | DefContT ct1, DefContT ct2 -> match_cont_type c ct1 ct2
+  | _, _ -> false
 
-let match_table_type (TableT (lim1, t1)) (TableT (lim2, t2)) =
-  match_limits lim1 lim2 && eq_ref_type t1 t2
+and match_var_type c x1 x2 =
+  eq_var x1 x2 ||
+  match_def_type c (lookup c x1) (lookup c x2)
 
-let match_memory_type (MemoryT lim1) (MemoryT lim2) =
-  match_limits lim1 lim2
+and match_cont_type c (ContT x1) (ContT x2) =
+  match_var_type c x1 x2
 
-let match_global_type (GlobalT (mut1, t1)) (GlobalT (mut2, t2)) =
-  eq_mutability mut1 mut2 &&
+let match_table_type c (TableT (lim1, t1)) (TableT (lim2, t2)) =
+  match_limits c lim1 lim2 && eq_ref_type c t1 t2
+
+let match_memory_type c (MemoryT lim1) (MemoryT lim2) =
+  match_limits c lim1 lim2
+
+let match_global_type c (GlobalT (mut1, t1)) (GlobalT (mut2, t2)) =
+  eq_mutability c mut1 mut2 &&
   match mut1 with
-  | Cons -> match_val_type t1 t2
-  | Var -> eq_val_type t1 t2
+  | Cons -> match_val_type c t1 t2
+  | Var -> eq_val_type c t1 t2
+
+let match_tag_type c tt1 tt2 =
+  eq_tag_type c tt1 tt2
 
-let match_extern_type et1 et2 =
+let match_extern_type c et1 et2 =
   match et1, et2 with
-  | ExternFuncT ft1, ExternFuncT ft2 -> match_func_type ft1 ft2
-  | ExternTableT tt1, ExternTableT tt2 -> match_table_type tt1 tt2
-  | ExternMemoryT mt1, ExternMemoryT mt2 -> match_memory_type mt1 mt2
-  | ExternGlobalT gt1, ExternGlobalT gt2 -> match_global_type gt1 gt2
+  | ExternFuncT ft1, ExternFuncT ft2 -> match_func_type c ft1 ft2
+  | ExternTableT tt1, ExternTableT tt2 -> match_table_type c tt1 tt2
+  | ExternMemoryT mt1, ExternMemoryT mt2 -> match_memory_type c mt1 mt2
+  | ExternGlobalT gt1, ExternGlobalT gt2 -> match_global_type c gt1 gt2
+  | ExternTagT t1, ExternTagT t2 -> match_tag_type c t1 t2
   | _, _ -> false
diff --git a/interpreter/valid/match.mli b/interpreter/valid/match.mli
index 91aa572f..201709fb 100644
--- a/interpreter/valid/match.mli
+++ b/interpreter/valid/match.mli
@@ -1,35 +1,39 @@
 open Types
 
+(* Context *)
+
+type context = def_type list
+
 (* Equivalence *)
 
-val eq_num_type : num_type -> num_type -> bool
-val eq_ref_type : ref_type -> ref_type -> bool
-val eq_val_type : val_type -> val_type -> bool
+val eq_num_type : context -> num_type -> num_type -> bool
+val eq_ref_type : context -> ref_type -> ref_type -> bool
+val eq_val_type : context -> val_type -> val_type -> bool
 
-val eq_result_type : result_type -> result_type -> bool
+val eq_result_type : context -> result_type -> result_type -> bool
 
-val eq_func_type : func_type -> func_type -> bool
-val eq_table_type : table_type -> table_type -> bool
-val eq_memory_type : memory_type -> memory_type -> bool
-val eq_global_type : global_type -> global_type -> bool
+val eq_func_type : context -> func_type -> func_type -> bool
+val eq_table_type : context -> table_type -> table_type -> bool
+val eq_memory_type : context -> memory_type -> memory_type -> bool
+val eq_global_type : context -> global_type -> global_type -> bool
 
-val eq_extern_type : extern_type -> extern_type -> bool
+val eq_extern_type : context -> extern_type -> extern_type -> bool
 
-val eq_def_type : def_type -> def_type -> bool
+val eq_def_type : context -> def_type -> def_type -> bool
 
 (* Subtyping *)
 
-val match_num_type : num_type -> num_type -> bool
-val match_ref_type : ref_type -> ref_type -> bool
-val match_val_type : val_type -> val_type -> bool
+val match_num_type : context -> num_type -> num_type -> bool
+val match_ref_type : context -> ref_type -> ref_type -> bool
+val match_val_type : context -> val_type -> val_type -> bool
 
-val match_result_type : result_type -> result_type -> bool
+val match_result_type : context -> result_type -> result_type -> bool
 
-val match_func_type : func_type -> func_type -> bool
-val match_table_type : table_type -> table_type -> bool
-val match_memory_type : memory_type -> memory_type -> bool
-val match_global_type : global_type -> global_type -> bool
+val match_func_type : context -> func_type -> func_type -> bool
+val match_table_type : context -> table_type -> table_type -> bool
+val match_memory_type : context -> memory_type -> memory_type -> bool
+val match_global_type : context -> global_type -> global_type -> bool
 
-val match_extern_type : extern_type -> extern_type -> bool
+val match_extern_type : context -> extern_type -> extern_type -> bool
 
-val match_def_type : def_type -> def_type -> bool
+val match_def_type : context -> def_type -> def_type -> bool
diff --git a/interpreter/valid/valid.ml b/interpreter/valid/valid.ml
index 9c7437da..aae28d03 100644
--- a/interpreter/valid/valid.ml
+++ b/interpreter/valid/valid.ml
@@ -15,6 +15,8 @@ let require b at s = if not b then error at s
 
 (* Context *)
 
+type label_kind = BlockLabel | CatchLabel
+
 type context =
 {
   types : def_type list;
@@ -22,17 +24,18 @@ type context =
   tables : table_type list;
   memories : memory_type list;
   globals : global_type list;
+  tags : tag_type list;
   elems : ref_type list;
   datas : unit list;
   locals : local_type list;
   results : val_type list;
-  labels : result_type list;
+  labels : (label_kind * result_type) list;
   refs : Free.t;
 }
 
 let empty_context =
   { types = []; funcs = []; tables = []; memories = [];
-    globals = []; elems = []; datas = [];
+    globals = []; tags = []; elems = []; datas = [];
     locals = []; results = []; labels = [];
     refs = Free.empty
   }
@@ -46,6 +49,7 @@ let func (c : context) x = lookup "function" c.funcs x
 let table (c : context) x = lookup "table" c.tables x
 let memory (c : context) x = lookup "memory" c.memories x
 let global (c : context) x = lookup "global" c.globals x
+let tag (c : context) x = lookup "tag" c.tags x
 let elem (c : context) x = lookup "elem segment" c.elems x
 let data (c : context) x = lookup "data segment" c.datas x
 let local (c : context) x = lookup "local" c.locals x
@@ -65,6 +69,12 @@ let init_locals (c : context) xs =
 let func_type (c : context) x =
   match type_ c x with
   | DefFuncT ft -> ft
+  | _ -> error x.at ("non-function type " ^ Int32.to_string x.it)
+
+let cont_type (c : context) x =
+  match type_ c x with
+  | DefContT ct -> ct
+  | _ -> error x.at ("non-continuation type " ^ Int32.to_string x.it)
 
 let refer category (s : Free.Set.t) x =
   if not (Free.Set.mem x.it s) then
@@ -86,59 +96,64 @@ let check_limits {min; max} range at msg =
       "size minimum must not be greater than maximum"
 
 let check_num_type (c : context) (t : num_type) at =
-  t
+  ()
 
 let check_vec_type (c : context) (t : vec_type) at =
-  t
+  ()
 
 let check_heap_type (c : context) (t : heap_type) at =
   match t with
-  | FuncHT -> FuncHT
-  | ExternHT -> ExternHT
-  | VarHT (StatX x) -> DefHT (type_ c (x @@ at))
-  | DefHT _ | BotHT -> assert false
+  | FuncHT -> ()
+  | ExternHT -> ()
+  | DefHT (Stat x) -> ignore (type_ c (x @@ at))
+  | DefHT (Dyn _) -> assert false
+  | BotHT -> assert false
 
 let check_ref_type (c : context) (t : ref_type) at =
   match t with
-  | (nul, ht) -> (nul, check_heap_type c ht at)
+  | (_nul, ht) -> check_heap_type c ht at
 
 let check_val_type (c : context) (t : val_type) at =
   match t with
-  | NumT t' -> NumT (check_num_type c t' at)
-  | VecT t' -> VecT (check_vec_type c t' at)
-  | RefT t' -> RefT (check_ref_type c t' at)
+  | NumT t' -> check_num_type c t' at
+  | VecT t' -> check_vec_type c t' at
+  | RefT t' -> check_ref_type c t' at
   | BotT -> assert false
 
 let check_result_type (c : context) (ts : result_type) at =
-  List.map (fun t -> check_val_type c t at) ts
+  List.iter (fun t -> check_val_type c t at) ts
 
 let check_func_type (c : context) (ft : func_type) at =
   let FuncT (ts1, ts2) = ft in
-  let ts1' = check_result_type c ts1 at in
-  let ts2' = check_result_type c ts2 at in
-  FuncT (ts1', ts2')
+  check_result_type c ts1 at;
+  check_result_type c ts2 at
+
+let check_cont_type (c : context) (ct : cont_type) at =
+  let ContT x = ct in
+  ignore (func_type c (as_stat_var x @@ at))
 
 let check_table_type (c : context) (tt : table_type) at =
   let TableT (lim, t) = tt in
   check_limits lim 0xffff_ffffl at "table size must be at most 2^32-1";
-  let t' = check_ref_type c t at in
-  TableT (lim, t')
+  check_ref_type c t at
 
 let check_memory_type (c : context) (mt : memory_type) at =
   let MemoryT lim = mt in
   check_limits lim 0x1_0000l at
-    "memory size must be at most 65536 pages (4GiB)";
-  MemoryT lim
+    "memory size must be at most 65536 pages (4GiB)"
+
+let check_tag_type (c : context) (et : tag_type) at =
+  let TagT x = et in
+  ignore (func_type c (as_stat_var x @@ at))
 
 let check_global_type (c : context) (gt : global_type) at =
-  let GlobalT (mut, t) = gt in
-  let t' = check_val_type c t at in
-  GlobalT (mut, t')
+  let GlobalT (_mut, t) = gt in
+  check_val_type c t at
 
 let check_def_type (c : context) (dt : def_type) at =
   match dt with
-  | DefFuncT ft -> DefFuncT (check_func_type c ft at)
-
+  | DefFuncT ft -> check_func_type c ft at
+  | DefContT ct -> check_cont_type c ct at
 
 
 (* Stack typing *)
@@ -163,8 +178,8 @@ let (-->...) ts1 ts2 = {ins = Ellipses, ts1; outs = Ellipses, ts2}
 
 let check_stack (c : context) ts1 ts2 at =
   require
-    ( List.length ts1 = List.length ts2 &&
-      List.for_all2 match_val_type ts1 ts2 ) at
+    (List.length ts1 = List.length ts2 &&
+      List.for_all2 (match_val_type c.types) ts1 ts2) at
     ("type mismatch: instruction requires " ^ string_of_result_type ts2 ^
      " but stack has " ^ string_of_result_type ts1)
 
@@ -285,8 +300,7 @@ let check_memop (c : context) (memop : ('t, 's) memop) ty_size get_sz at =
       Pack.packed_size sz
   in
   require (1 lsl memop.align <= size) at
-    "alignment must not be larger than natural";
-  memop.ty
+    "alignment must not be larger than natural"
 
 
 (*
@@ -309,10 +323,28 @@ let check_memop (c : context) (memop : ('t, 's) memop) ty_size get_sz at =
  * declarative typing rules.
  *)
 
+let check_resume_table (c : context) ts2 (xys : (idx * idx) list) at =
+  List.iter (fun (x1, x2) ->
+    let TagT x1' = tag c x1 in
+    let FuncT (ts3, ts4) = func_type c (as_stat_var x1' @@ x1.at) in
+    let (_, ts') = label c x2 in
+    match Lib.List.last_opt ts'  with
+    | Some (RefT (nul', DefHT (Stat y'))) ->
+      let ContT z' = cont_type c (y' @@ x2.at) in
+      let ft' = func_type c (as_stat_var z' @@ x2.at) in
+      require (match_func_type c.types (FuncT (ts4, ts2)) ft') x2.at
+        "type mismatch in continuation type";
+      check_stack c (ts3 @ [RefT (nul', DefHT (Stat y'))]) ts' x2.at
+    | _ ->
+      error at
+        ("type mismatch: instruction requires continuation reference type" ^
+          " but label has " ^ string_of_result_type ts')
+  ) xys
+
 let check_block_type (c : context) (bt : block_type) at : instr_type =
   match bt with
   | ValBlockType None -> InstrT ([], [], [])
-  | ValBlockType (Some t) -> InstrT ([], [check_val_type c t at], [])
+  | ValBlockType (Some t) -> check_val_type c t at; InstrT ([], [t], [])
   | VarBlockType x ->
     let FuncT (ts1, ts2) = func_type c x in InstrT (ts1, ts2, [])
 
@@ -337,52 +369,81 @@ let rec check_instr (c : context) (e : instr) (s : infer_result_type) : infer_in
   | Select (Some ts) ->
     require (List.length ts = 1) e.at
       "invalid result arity other than 1 is not (yet) allowed";
-    let ts' = check_result_type c ts e.at in
-    (ts' @ ts' @ [NumT I32T]) --> ts', []
+    check_result_type c ts e.at;
+    (ts @ ts @ [NumT I32T]) --> ts, []
 
   | Block (bt, es) ->
     let InstrT (ts1, ts2, xs) as it = check_block_type c bt e.at in
-    check_block {c with labels = ts2 :: c.labels} es it e.at;
+    check_block {c with labels = (BlockLabel, ts2) :: c.labels} es it e.at;
     ts1 --> ts2, List.map (fun x -> x @@ e.at) xs
 
   | Loop (bt, es) ->
     let InstrT (ts1, ts2, xs) as it = check_block_type c bt e.at in
-    check_block {c with labels = ts1 :: c.labels} es it e.at;
+    check_block {c with labels = (BlockLabel, ts1) :: c.labels} es it e.at;
     ts1 --> ts2, List.map (fun x -> x @@ e.at) xs
 
   | If (bt, es1, es2) ->
     let InstrT (ts1, ts2, xs) as it = check_block_type c bt e.at in
-    check_block {c with labels = ts2 :: c.labels} es1 it e.at;
-    check_block {c with labels = ts2 :: c.labels} es2 it e.at;
+    check_block {c with labels = (BlockLabel, ts2) :: c.labels} es1 it e.at;
+    check_block {c with labels = (BlockLabel, ts2) :: c.labels} es2 it e.at;
     (ts1 @ [NumT I32T]) --> ts2, List.map (fun x -> x @@ e.at) xs
 
+  | Throw x ->
+    let TagT y = tag c x in
+    let FuncT (ts1, _) = func_type c (as_stat_var y @@ e.at) in
+    ts1 -->... [], []
+
+  | Rethrow x ->
+    let (kind, _) = label c x in
+    require (kind = CatchLabel) e.at "invalid rethrow label";
+    [] -->... [], []
+
+  | TryCatch (bt, es, cts, ca) ->
+    let InstrT (ts1, ts2, xs) as ft = check_block_type c bt e.at in
+    let c_try = {c with labels = (BlockLabel, ts2) :: c.labels} in
+    let c_catch = {c with labels = (CatchLabel, ts2) :: c.labels} in
+    check_block c_try es ft e.at;
+    List.iter (fun ct -> check_catch ct c_catch ft e.at) cts;
+    Lib.Option.app (fun es -> check_block c_catch es ft e.at) ca;
+    ts1 --> ts2, List.map (fun x -> x @@ e.at) xs
+
+  | TryDelegate (bt, es, x) ->
+    let InstrT (ts1, ts2, xs) as ft = check_block_type c bt e.at in
+    ignore (label c x);
+    check_block {c with labels = (BlockLabel, ts2) :: c.labels} es ft e.at;
+    ts1 --> ts2, List.map (fun x -> x @@ e.at) xs
+
   | Br x ->
-    label c x -->... [], []
+    let (_, ts) = label c x in
+    ts -->... [], []
 
   | BrIf x ->
-    (label c x @ [NumT I32T]) --> label c x, []
+    let (_, ts) = label c x in
+    (ts @ [NumT I32T]) --> ts, []
 
   | BrTable (xs, x) ->
-    let n = List.length (label c x) in
-    let ts = List.init n (fun i -> peek (n - i) s) in
-    check_stack c ts (label c x) x.at;
-    List.iter (fun x' -> check_stack c ts (label c x') x'.at) xs;
+    let n = List.length (snd (label c x)) in
+    let ts = Lib.List.table n (fun i -> peek (n - i) s) in
+    check_stack c ts (snd (label c x)) x.at;
+    List.iter (fun x' -> check_stack c ts (snd (label c x')) x'.at) xs;
     (ts @ [NumT I32T]) -->... [], []
 
   | BrOnNull x ->
     let (_, ht) = peek_ref 0 s e.at in
-    (label c x @ [RefT (Null, ht)]) --> (label c x @ [RefT (NoNull, ht)]), []
+    let (_, ts) = label c x in
+    (ts @ [RefT (Null, ht)]) --> (ts @ [RefT (NoNull, ht)]), []
 
   | BrOnNonNull x ->
     let (_, ht) = peek_ref 0 s e.at in
     let t' = RefT (NoNull, ht) in
-    require (label c x <> []) e.at
+    let (_, ts) = label c x in
+    require (ts <> []) e.at
       ("type mismatch: instruction requires type " ^ string_of_val_type t' ^
-       " but label has " ^ string_of_result_type (label c x));
-    let ts0, t1 = Lib.List.split_last (label c x) in
-    require (match_val_type t' t1) e.at
+       " but label has " ^ string_of_result_type ts);
+    let ts0, t1 = Lib.List.split_last ts in
+    require (match_val_type c.types t' t1) e.at
       ("type mismatch: instruction requires type " ^ string_of_val_type t' ^
-       " but label has " ^ string_of_result_type (label c x));
+       " but label has " ^ string_of_result_type ts);
     (ts0 @ [RefT (Null, ht)]) --> ts0, []
 
   | Return ->
@@ -393,42 +454,84 @@ let rec check_instr (c : context) (e : instr) (s : infer_result_type) : infer_in
     ts1 --> ts2, []
 
   | CallRef x ->
-    let FuncT (ts1, ts2) as ft = func_type c x in
-    (ts1 @ [RefT (Null, DefHT (DefFuncT ft))]) --> ts2, []
+    let FuncT (ts1, ts2) = func_type c x in
+    (ts1 @ [RefT (Null, DefHT (Stat x.it))]) --> ts2, []
 
   | CallIndirect (x, y) ->
     let TableT (_lim, t) = table c x in
     let FuncT (ts1, ts2) = func_type c y in
-    require (match_ref_type t (Null, FuncHT)) x.at
+    require (match_ref_type c.types t (Null, FuncHT)) x.at
       ("type mismatch: instruction requires table of function type" ^
        " but table has element type " ^ string_of_ref_type t);
     (ts1 @ [NumT I32T]) --> ts2, []
 
   | ReturnCall x ->
     let FuncT (ts1, ts2) = func c x in
-    require (match_result_type ts2 c.results) e.at
+    require (match_result_type c.types ts2 c.results) e.at
       ("type mismatch: current function requires result type " ^
        string_of_result_type c.results ^
        " but callee returns " ^ string_of_result_type ts2);
     ts1 -->... [], []
 
   | ReturnCallRef x ->
-    let FuncT (ts1, ts2) as ft = func_type c x in
-    require (match_result_type ts2 c.results) e.at
+    let FuncT (ts1, ts2) = func_type c x in
+    require (match_result_type c.types ts2 c.results) e.at
       ("type mismatch: current function requires result type " ^
        string_of_result_type c.results ^
        " but callee returns " ^ string_of_result_type ts2);
-    (ts1 @ [RefT (Null, DefHT (DefFuncT ft))]) -->... [], []
+    (ts1 @ [RefT (Null, DefHT (Stat x.it))]) -->... [], []
 
   | ReturnCallIndirect (x, y) ->
     let TableT (_lim, t) = table c x in
     let FuncT (ts1, ts2) = func_type c y in
-    require (match_result_type ts2 c.results) e.at
+    require (match_result_type c.types ts2 c.results) e.at
       ("type mismatch: current function requires result type " ^
        string_of_result_type c.results ^
        " but callee returns " ^ string_of_result_type ts2);
     (ts1 @ [NumT I32T]) -->... [], []
 
+  | ContNew x ->
+    let ContT y = cont_type c x in
+    [RefT (NoNull, DefHT y)] -->
+    [RefT (NoNull, DefHT (Stat x.it))], []
+
+  | ContBind (x, y) ->
+    let ContT z = cont_type c x in
+    let FuncT (ts1, ts2) = func_type c (as_stat_var z @@ e.at) in
+    let ContT z' = cont_type c y in
+    let FuncT (ts1', _) as ft' = func_type c (as_stat_var z' @@ e.at) in
+    require (List.length ts1 >= List.length ts1') x.at
+      "type mismatch in continuation arguments";
+    let ts11, ts12 = Lib.List.split (List.length ts1 - List.length ts1') ts1 in
+    require (match_func_type c.types (FuncT (ts12, ts2)) ft') e.at
+      "type mismatch in continuation types";
+    (ts11 @ [RefT (Null, DefHT (Stat x.it))]) -->
+      [RefT (NoNull, DefHT (Stat y.it))], []
+
+  | Suspend x ->
+    let TagT x' = tag c x in
+    let FuncT (ts1, ts2) = func_type c (as_stat_var x' @@ x.at) in
+    ts1 --> ts2, []
+
+  | Resume (x, xys) ->
+    let ContT z = cont_type c x in
+    let FuncT (ts1, ts2) = func_type c (as_stat_var z @@ e.at) in
+    check_resume_table c ts2 xys e.at;
+    (ts1 @ [RefT (Null, DefHT (Stat x.it))]) --> ts2, []
+
+  | ResumeThrow (x, y, xys) ->
+    let ContT z = cont_type c x in
+    let FuncT (ts1, ts2) = func_type c (as_stat_var z @@ e.at) in
+    let TagT y' = tag c y in
+    let FuncT (ts0, _) = func_type c (as_stat_var y' @@ x.at) in
+    check_resume_table c ts2 xys e.at;
+    (ts0 @ [RefT (Null, DefHT (Stat x.it))]) --> ts2, []
+
+  | Barrier (bt, es) ->
+    let InstrT (ts1, ts2, xs) as ft = check_block_type c bt e.at in
+    check_block {c with labels = (BlockLabel, ts2) :: c.labels} es ft e.at;
+    ts1 --> ts2, List.map (fun x -> x @@ e.at) xs
+
   | LocalGet x ->
     let LocalT (init, t) = local c x in
     require (init = Set) x.at "uninitialized local";
@@ -474,7 +577,7 @@ let rec check_instr (c : context) (e : instr) (s : infer_result_type) : infer_in
   | TableCopy (x, y) ->
     let TableT (_lim1, t1) = table c x in
     let TableT (_lim2, t2) = table c y in
-    require (match_ref_type t2 t1) x.at
+    require (match_ref_type c.types t2 t1) x.at
       ("type mismatch: source element type " ^ string_of_ref_type t1 ^
        " does not match destination element type " ^ string_of_ref_type t2);
     [NumT I32T; NumT I32T; NumT I32T] --> [], []
@@ -482,7 +585,7 @@ let rec check_instr (c : context) (e : instr) (s : infer_result_type) : infer_in
   | TableInit (x, y) ->
     let TableT (_lim1, t1) = table c x in
     let t2 = elem c y in
-    require (match_ref_type t2 t1) x.at
+    require (match_ref_type c.types t2 t1) x.at
       ("type mismatch: element segment's type " ^ string_of_ref_type t1 ^
        " does not match table's element type " ^ string_of_ref_type t2);
     [NumT I32T; NumT I32T; NumT I32T] --> [], []
@@ -492,32 +595,32 @@ let rec check_instr (c : context) (e : instr) (s : infer_result_type) : infer_in
     [] --> [], []
 
   | Load memop ->
-    let t = check_memop c memop num_size (Lib.Option.map fst) e.at in
-    [NumT I32T] --> [NumT t], []
+    check_memop c memop num_size (Lib.Option.map fst) e.at;
+    [NumT I32T] --> [NumT memop.ty], []
 
   | Store memop ->
-    let t = check_memop c memop num_size (fun sz -> sz) e.at in
-    [NumT I32T; NumT t] --> [], []
+    check_memop c memop num_size (fun sz -> sz) e.at;
+    [NumT I32T; NumT memop.ty] --> [], []
 
   | VecLoad memop ->
-    let t = check_memop c memop vec_size (Lib.Option.map fst) e.at in
-    [NumT I32T] --> [VecT t], []
+    check_memop c memop vec_size (Lib.Option.map fst) e.at;
+    [NumT I32T] --> [VecT memop.ty], []
 
   | VecStore memop ->
-    let t = check_memop c memop vec_size (fun _ -> None) e.at in
-    [NumT I32T; VecT t] --> [], []
+    check_memop c memop vec_size (fun _ -> None) e.at;
+    [NumT I32T; VecT memop.ty] --> [], []
 
   | VecLoadLane (memop, i) ->
-    let t = check_memop c memop vec_size (fun sz -> Some sz) e.at in
-    require (i < vec_size t / Pack.packed_size memop.pack) e.at
+    check_memop c memop vec_size (fun sz -> Some sz) e.at;
+    require (i < vec_size memop.ty / Pack.packed_size memop.pack) e.at
       "invalid lane index";
-    [NumT I32T; VecT t] -->  [VecT t], []
+    [NumT I32T; VecT memop.ty] -->  [VecT memop.ty], []
 
   | VecStoreLane (memop, i) ->
-    let t = check_memop c memop vec_size (fun sz -> Some sz) e.at in
-    require (i < vec_size t / Pack.packed_size memop.pack) e.at
+    check_memop c memop vec_size (fun sz -> Some sz) e.at;
+    require (i < vec_size memop.ty / Pack.packed_size memop.pack) e.at
       "invalid lane index";
-    [NumT I32T; VecT t] -->  [], []
+    [NumT I32T; VecT memop.ty] -->  [], []
 
   | MemorySize ->
     let _mt = memory c (0l @@ e.at) in
@@ -545,8 +648,8 @@ let rec check_instr (c : context) (e : instr) (s : infer_result_type) : infer_in
     [] --> [], []
 
   | RefNull ht ->
-    let ht' = check_heap_type c ht e.at in
-    [] --> [RefT (Null, ht')], []
+    check_heap_type c ht e.at;
+    [] --> [RefT (Null, ht)], []
 
   | RefIsNull ->
     let (_, ht) = peek_ref 0 s e.at in
@@ -558,8 +661,9 @@ let rec check_instr (c : context) (e : instr) (s : infer_result_type) : infer_in
 
   | RefFunc x ->
     let ft = func c x in
+    let y = Lib.Option.force (Lib.List32.index_of (DefFuncT ft) c.types) in
     refer_func c x;
-    [] --> [RefT (NoNull, DefHT (DefFuncT ft))], []
+    [] --> [RefT (NoNull, DefHT (Stat y))], []
 
   | Const v ->
     let t = NumT (type_num v.it) in
@@ -672,6 +776,12 @@ and check_block (c : context) (es : instr list) (it : instr_type) at =
     ("type mismatch: block requires " ^ string_of_result_type ts2 ^
      " but stack has " ^ string_of_result_type (snd s))
 
+and check_catch (ct : idx * instr list) (c : context) (ft : instr_type) at =
+  let (x, es) = ct in
+  let TagT y = tag c x in
+  let FuncT (ts1, _) = func_type c (as_stat_var y @@ at) in
+  let InstrT (_, ts2, xs) = ft in
+  check_block c es (InstrT (ts1, ts2, xs)) at
 
 (* Functions & Constants *)
 
@@ -688,16 +798,11 @@ and check_block (c : context) (es : instr list) (it : instr_type) at =
  *)
 
 let check_local (c : context) (loc : local) : local_type =
-  let t = check_val_type c loc.it.ltype loc.at in
-  let init = if defaultable t then Set else Unset in
-  LocalT (init, t)
-
-let check_func (c : context) (f : func) : context =
-  let {ftype; locals; body} = f.it in
-  let ft = func_type c ftype in
-  {c with funcs = c.funcs @ [ft]}
+  check_val_type c loc.it.ltype loc.at;
+  let init = if defaultable loc.it.ltype then Set else Unset in
+  LocalT (init, loc.it.ltype)
 
-let check_func_body (c : context) (f : func) =
+let check_func (c : context) (f : func) =
   let {ftype; locals; body} = f.it in
   let FuncT (ts1, ts2) = func_type c ftype in
   let lts = List.map (check_local c) locals in
@@ -705,7 +810,7 @@ let check_func_body (c : context) (f : func) =
     { c with
       locals = List.map (fun t -> LocalT (Set, t)) ts1 @ lts;
       results = ts2;
-      labels = [ts2]
+      labels = [(BlockLabel, ts2)]
     }
   in check_block c' body (InstrT ([], ts2, [])) f.at
 
@@ -725,42 +830,34 @@ let check_const (c : context) (const : const) (t : val_type) =
   check_block c const.it (InstrT ([], [t], [])) const.at
 
 
-(* Globals, Tables, Memories *)
-
-let check_global (c : context) (glob : global) : context =
-  let {gtype; ginit} = glob.it in
-  let GlobalT (_mut, t) as gt = check_global_type c gtype glob.at in
-  check_const c ginit t;
-  {c with globals = c.globals @ [gt]}
+(* Tables, Memories, Globals, Tags *)
 
-let check_table (c : context) (tab : table) : context =
+let check_table (c : context) (tab : table) =
   let {ttype; tinit} = tab.it in
-  let TableT (_lim, rt) as tt = check_table_type c ttype tab.at in
-  check_const c tinit (RefT rt);
-  {c with tables = c.tables @ [tt]}
+  check_table_type c ttype tab.at;
+  let TableT (_lim, rt) = ttype in
+  check_const c tinit (RefT rt)
 
-let check_memory (c : context) (mem : memory) : context =
+let check_memory (c : context) (mem : memory) =
   let {mtype} = mem.it in
-  let mt = check_memory_type c mtype mem.at in
-  {c with memories = c.memories @ [mt]}
+  check_memory_type c mtype mem.at
 
 let check_elem_mode (c : context) (t : ref_type) (mode : segment_mode) =
   match mode.it with
   | Passive -> ()
   | Active {index; offset} ->
     let TableT (_lim, et) = table c index in
-    require (match_ref_type t et) mode.at
+    require (match_ref_type c.types t et) mode.at
       ("type mismatch: element segment's type " ^ string_of_ref_type t ^
        " does not match table's element type " ^ string_of_ref_type et);
     check_const c offset (NumT I32T)
   | Declarative -> ()
 
-let check_elem (c : context) (seg : elem_segment) : context =
+let check_elem (c : context) (seg : elem_segment) =
   let {etype; einit; emode} = seg.it in
-  let rt = check_ref_type c etype seg.at in
-  List.iter (fun const -> check_const c const (RefT rt)) einit;
-  check_elem_mode c rt emode;
-  {c with elems = c.elems @ [rt]}
+  check_ref_type c etype seg.at;
+  List.iter (fun const -> check_const c const (RefT etype)) einit;
+  check_elem_mode c etype emode
 
 let check_data_mode (c : context) (mode : segment_mode) =
   match mode.it with
@@ -770,17 +867,31 @@ let check_data_mode (c : context) (mode : segment_mode) =
     check_const c offset (NumT I32T)
   | Declarative -> assert false
 
-let check_data (c : context) (seg : data_segment) : context =
+let check_data (c : context) (seg : data_segment) =
   let {dinit; dmode} = seg.it in
-  check_data_mode c dmode;
-  {c with datas = c.datas @ [()]}
+  check_data_mode c dmode
+
+let check_global (c : context) (glob : global) =
+  let {gtype; ginit} = glob.it in
+  check_global_type c gtype glob.at;
+  let GlobalT (_mut, t) = gtype in
+  check_const c ginit t
+
+let check_tag (c : context) (tag : tag) =
+  let {tagtype} = tag.it in
+  check_tag_type c tagtype tag.at
 
 
 (* Modules *)
 
+let check_start (c : context) (start : start) =
+  let {sfunc} = start.it in
+  require (func c sfunc = FuncT ([], [])) start.at
+    "start function must not have parameters or results"
+
 let check_type (c : context) (ty : type_) : context =
-  let dt = check_def_type c ty.it ty.at in
-  {c with types = c.types @ [dt]}
+  check_def_type c ty.it ty.at;
+  {c with types = c.types @ [ty.it]}
 
 let check_import (c : context) (im : import) : context =
   let {module_name = _; item_name = _; idesc} = im.it in
@@ -789,14 +900,17 @@ let check_import (c : context) (im : import) : context =
     let ft = func_type c x in
     {c with funcs = c.funcs @ [ft]}
   | TableImport tt ->
-    let tt' = check_table_type c tt idesc.at in
-    {c with tables = c.tables @ [tt']}
+    check_table_type c tt idesc.at;
+    {c with tables = c.tables @ [tt]}
   | MemoryImport mt ->
-    let mt' = check_memory_type c mt idesc.at in
-    {c with memories = c.memories @ [mt']}
+    check_memory_type c mt idesc.at;
+    {c with memories = c.memories @ [mt]}
   | GlobalImport gt ->
-    let gt' = check_global_type c gt idesc.at in
-    {c with globals = c.globals @ [gt']}
+    check_global_type c gt idesc.at;
+    {c with globals = c.globals @ [gt]}
+  | TagImport et ->
+    check_tag_type c et idesc.at;
+    {c with tags = c.tags @ [et]}
 
 module NameSet = Set.Make(struct type t = Ast.name let compare = compare end)
 
@@ -807,34 +921,41 @@ let check_export (c : context) (set : NameSet.t) (ex : export) : NameSet.t =
   | TableExport x -> ignore (table c x)
   | MemoryExport x -> ignore (memory c x)
   | GlobalExport x -> ignore (global c x)
+  | TagExport x -> ignore (tag c x)
   );
   require (not (NameSet.mem name set)) ex.at "duplicate export name";
   NameSet.add name set
 
-let check_start (c : context) (start : start) =
-  let {sfunc} = start.it in
-  require (func c sfunc = FuncT ([], [])) start.at
-    "start function must not have parameters or results"
-
-
-let check_list f xs (c : context) : context =
-  List.fold_left f c xs
 
 let check_module (m : module_) =
-  let refs = Free.module_ ({m.it with funcs = []; start = None} @@ m.at) in
+  let
+    { types; imports; tables; memories; globals; tags; funcs;
+      start; elems; datas; exports } = m.it
+  in
+  let c0 = List.fold_left check_type empty_context types in
+  let c1 = List.fold_left check_import c0 imports in
+  let c2 =
+    { c1 with
+      funcs = c1.funcs @ List.map (fun f -> func_type c1 f.it.ftype) funcs;
+      tables = c1.tables @ List.map (fun tab -> tab.it.ttype) tables;
+      memories = c1.memories @ List.map (fun mem -> mem.it.mtype) memories;
+      tags = c1.tags @ List.map (fun tag -> tag.it.tagtype) tags;
+      elems = List.map (fun elem -> elem.it.etype) elems;
+      datas = List.map (fun _data -> ()) datas;
+      refs = Free.module_ ({m.it with funcs = []; start = None} @@ m.at);
+    }
+  in
   let c =
-    {empty_context with refs}
-    |> check_list check_type m.it.types
-    |> check_list check_import m.it.imports
-    |> check_list check_func m.it.funcs
-    |> check_list check_global m.it.globals
-    |> check_list check_table m.it.tables
-    |> check_list check_memory m.it.memories
-    |> check_list check_elem m.it.elems
-    |> check_list check_data m.it.datas
+    { c2 with globals = c1.globals @ List.map (fun g -> g.it.gtype) globals }
   in
+  List.iter (check_global c2) globals;
+  List.iter (check_table c2) tables;
+  List.iter (check_memory c2) memories;
+  List.iter (check_tag c2) tags;
+  List.iter (check_elem c2) elems;
+  List.iter (check_data c2) datas;
+  List.iter (check_func c) funcs;
+  Lib.Option.app (check_start c) start;
+  ignore (List.fold_left (check_export c) NameSet.empty exports);
   require (List.length c.memories <= 1) m.at
-    "multiple memories are not allowed (yet)";
-  List.iter (check_func_body c) m.it.funcs;
-  Option.iter (check_start c) m.it.start;
-  ignore (List.fold_left (check_export c) NameSet.empty m.it.exports)
+    "multiple memories are not allowed (yet)"
diff --git a/proposals/continuations/Explainer.md b/proposals/continuations/Explainer.md
new file mode 100644
index 00000000..43fe1245
--- /dev/null
+++ b/proposals/continuations/Explainer.md
@@ -0,0 +1,1679 @@
+# Typed continuations
+
+This document provides an informal presentation of the *typed
+continuations* proposal, a minimal and compatible extension to Wasm
+for structured non-local control flow. The proposal is minimal in the
+sense that it leverages Wasm's existing instruction set and type
+system. It extends the instruction set with instructions to suspend,
+resume, and abort computations, and extends the type system with a
+single new reference type for *continuations*.
+
+## Table of contents
+
+1. [Motivation](#motivation)
+2. [Additional requirements](#additional-requirements)
+3. [Instruction set](#instruction-set)
+   1. [Declaring control tags](#declaring-control-tags)
+   2. [Creating continuations](#creating-continuations)
+   3. [Resuming continuations](#resuming-continuations)
+   4. [Suspending continuations](#suspending-continuations)
+   5. [Binding continuations](#binding-continuations)
+   6. [Trapping continuations](#trapping-continuations)
+4. [Examples](#examples)
+   1. [Lightweight threads (static)](#lightweight-threads-static)
+   2. [Lightweight threads (dynamic)](#lightweight-threads-dynamic)
+   3. [Actors](#actors)
+   4. [Async/await](#asyncawait)
+   5. [Delimited continuations](#delimited-continuations)
+5. [Implementation strategies](#implementation-strategies)
+6. [Design considerations and extensions](#design-considerations-and-extensions)
+   1.  [Memory management](#memory-management)
+   2.  [Linear versus constant time dispatch](#linear-versus-constant-time-dispatch)
+   3.  [Named handlers](#named-handlers)
+   4.  [Direct switching](#direct-switching)
+   5.  [Control/prompt as an alternative basis](#controlprompt-as-an-alternative-basis)
+   6.  [Coupling of continuation capture and dispatch](#coupling-of-continuation-capture-and-dispatch)
+   7.  [Tail-resumptive handlers](#tail-resumptive-handlers)
+   8.  [Multi-shot continuations](#multi-shot-continuations)
+   9.  [Interoperability, legacy code, and the barrier instruction](#interoperability-legacy-code-and-the-barrier-instruction)
+   10. [First-class tags](#first-class-tags)
+   11. [Shallow versus deep handlers](#shallow-versus-deep-handlers)
+
+## Motivation
+
+Non-local control flow features provide the ability to suspend the
+current execution context and later resume it. Many
+industrial-strength programming languages feature a wealth of
+non-local control flow features such as async/await, coroutines,
+generators/iterators, effect handlers, call/cc, and so forth. For some
+programming languages non-local control flow is central to their
+identity, meaning that they rely on non-local control flow for
+efficiency, e.g. to support massively scalable concurrency.
+
+Currently, Wasm lacks support for implementing such features directly
+and efficiently without a circuitous global transformation of source
+programs on the producer side. One possible strategy is to add special
+support for each individual non-local control flow feature to Wasm,
+but strategy does not scale to the next 700 non-local control flow
+features. Instead, the goal of this proposal is to introduce a unifed
+structured mechanism that is sufficiently general to cover present
+use-cases as well as being forwards compatible with future use-cases,
+while admitting efficient implementations.
+
+The proposed mechanism is based on proven technology: *delimited
+continuations*. An undelimited continuation represents the rest of a
+computation from a certain point in its execution. A delimited
+continuation is a more modular form of continuation, representing the
+rest of a computation from a particular point in its execution up to a
+*delimiter* or *prompt*. Operationally, one may think of undelimited
+continuations as stacks and delimited continuations as segmented
+stacks.
+
+In their raw form delimited continuations do not readily fit into the
+Wasm ecosystem, as the Wasm type system is not powerful enough to type
+them. The gist of the problem is that the classic treatment of
+delimited continuations provides only one universal control tag
+(i.e. the mechanism which transforms a runtime stack into a
+programmatic data object). In order to use Wasm's simple type system
+to type delimited continuations, we use the idea of multiple *named*
+control tags from Plotkin and Pretnar's effect handlers. Each control
+tag is declared module-wide along its payload type and return
+type. This declaration can be used to readily type points of non-local
+transfer of control. From an operational perspective we may view
+control tags as a means for writing an interface for the possible
+kinds of non-local transfers (or stack switches) that a computation
+may perform.
+
+### Typed continuation primer
+
+A *continuation* is a first-class program object that represents the
+remainder of computation from a certain point in the execution of a
+program --- intuitively, its current stack. The typed continuations
+proposal is based on a structured notion of delimited continuations. A
+*delimited continuation* is a continuation whose extent is delimited
+by some *control delimiter*, meaning it represents the remainder of
+computation from a certain point up to (and possibly including) its
+control delimiter -- intuitively, a segment of the stack. An
+alternative to delimited continuations is undelimited continuations
+which represent the remainder of the *entire* program. Delimited
+continuations are preferable as they are more modular and more
+fine-grained in the sense that they provide a means for suspending
+local execution contexts rather than the entire global execution
+context. In particular, delimited continuations are more expressive,
+as an undelimited continuation is merely a delimited continuation
+whose control delimiter is placed at the start of the program.
+
+The crucial feature of the typed continuations proposal that makes it
+more structured than conventional delimited continuations is *control
+tags*. A control tag is a typed symbolic entity that suspends the
+current execution context and reifies it as a *continuation object*
+(henceforth, just *continuation*) up to its control delimiter. The
+type of a control tag communicates the type of its payload as well as
+its expected return type, i.e. the type of data that must be supplied
+to its associated continuation upon resumption. In other words,
+control tags define an *interface* for constructing continuations.
+
+A second aspect of the design that aids modularity by separating
+concerns is that the construction of continuations is distinct from
+*handling* of continuations. A continuation is handled at the
+delimiter of a control tag rather than at the invocation site of the
+control tag. Control tags are a mild extension of exception tags as in
+the exception handling proposal. The key difference is that in
+addition to a payload type, a control tag also declares a return
+type. Roughly, control tags can be thought of as resumable exceptions.
+
+Typed continuations may be efficiently implemented using segmented
+stacks, but other implementations are also possible.
+
+## Additional requirements
+
+ * **No GC dependency**: We intend every language to be able to use
+   typed continuations to implement non-local flow abstractions
+   irrespective of whether its memory is managed by a GC. Thus this
+   proposal must not depend on the presence of a full-blown GC as in
+   the GC proposal, rather, reference counting or a similar technique
+   must be sufficient in cases where some form of memory management is
+   necessary.
+
+ * **Debugging friendliness**: The addition of continuations must
+   preserve compatibility with standard debugging formats such as
+   DWARF, meaning it must be possible to obtain a sequential
+   unobstructed stack trace in the presence of continuations.
+
+ * **Exception handling compatibility**: [The exception handling
+   proposal](https://github.com/WebAssembly/exception-handling) adds
+   special support for one kind of non-local control flow abstraction,
+   namely, exception handlers. Exceptions must continue to work in the
+   presence of typed continuations and vice versa.
+
+ * **Preserve Wasm invariants of legacy code**: The proposal must
+   provide a means to protect the invariants of existing Wasm
+   code. For instance, this means that in the presence of code that
+   uses typed continuations it should be possible to ensure that other
+   legacy code cannot suspend. The mechanism for protecting invariants
+   need not be automatic (in the same vein as explicit synchronisation
+   might be needed when adding threads and shared memory).
+
+## Instruction set
+
+The proposal adds a new reference type for continuations.
+
+```wasm
+  (cont $t)
+```
+
+A continuation type is given in terms of a function type `$t`, whose parameters `tp*`
+describes the expected stack shape prior to resuming/starting the
+continuation, and whose return types `tr*` describes the stack
+shape after the continuation has run to completion.
+
+As a shorthand, we will often write the function type inline and write a continuation type as
+```wasm
+  (cont [tp*] -> [tr*])
+```
+
+### Declaring control tags
+
+A control tag is similar to an exception extended with a result type
+(or list thereof). Operationally, a control tag may be thought of as a
+*resumable* exception. A tag declaration provides the type signature
+of a control tag.
+
+```wasm
+  (tag $e (param tp*) (result tr*))
+```
+
+The `$e` is the symbolic index of the control tag in the index space
+of tags. The parameter types `tp*` describe the expected stack layout
+prior to invoking the tag, and the result types `tr*` describe the
+stack layout following an invocation of the operation. In this
+document we will sometimes write `$e : [tp*] -> [tr*]` as shorthand
+for indicating that such a declaration is in scope.
+
+### Creating continuations
+
+The following instruction creates a continuation in *suspended state*
+from a function.
+
+```wasm
+  cont.new $ct : [(ref $ft)] -> [(ref $ct)]
+  where:
+  - $ft = func [t1*] -> [t2*]
+  - $ct = cont $ft
+```
+
+The instruction takes as operand a reference to
+a function of type `[t1*] -> [t2*]`. The body of this function is a
+computation that may perform non-local control flow.
+
+
+### Invoking continuations
+
+There are two ways to invoke (or run) a continuation.
+
+The first way to invoke a continuation resumes the continuation under
+a *handler*, which handles subsequent control suspensions within the
+continuation.
+
+```wasm
+  resume (tag $e $l)* : [tp* (ref $ct)] -> [tr*]
+  where:
+  - $ct = cont [tp*] -> [tr*]
+```
+
+The `resume` instruction is parameterised by a handler defined by a
+collection of pairs of control tags and labels. Each pair maps a
+control tag to a label pointing to its corresponding handler code. The
+`resume` instruction consumes its continuation argument, meaning a
+continuation may be resumed only once.
+
+The second way to invoke a continuation is to raise an exception at
+the control tag invocation site. This amounts to performing "an
+abortive action" which causes the stack to be unwound.
+
+
+```wasm
+  resume_throw $exn : [tp* (ref $ct)])] -> [tr*]
+  where:
+  - $ct = cont [ta*] -> [tr*]
+  - $exn : [tp*] -> []
+```
+
+The instruction `resume_throw` is parameterised by the exception to be
+raised at the control tag invocation site. As with `resume`, this
+instruction also fully consumes its continuation
+argument. Operationally, this instruction raises the exception `$exn`
+with parameters of type `tp*` at the control tag invocation point in
+the context of the supplied continuation. As an exception is being
+raised (the continuation is not actually being supplied a value) the
+parameter types for the continuation `ta*` are unconstrained.
+
+### Suspending continuations
+
+A computation running inside a continuation can suspend itself by
+invoking one of the declared control tags.
+
+
+```wasm
+  suspend $e : [tp*] -> [tr*]
+  where:
+  - $e : [tp*] -> [tr*]
+```
+
+The instruction `suspend` invokes the control tag named `$e` with
+arguments of types `tp*`. Operationally, the instruction transfers
+control out of the continuation to the nearest enclosing handler for
+`$e`. This behaviour is similar to how raising an exception transfers
+control to the nearest exception handler that handles the
+exception. The key difference is that the continuation at the
+suspension point expects to be resumed later with arguments of types
+`tr*`.
+
+### Binding continuations
+
+The parameter list of a continuation may be shrunk via `cont.bind`. This
+instruction provides a way to partially apply a given
+continuation. This facility turns out to be important in practice due
+to the block and type structure of Wasm as in order to return a
+continuation from a block, all branches within the block must agree on
+the type of continuation. By using `cont.bind`, one can
+programmatically ensure that the branches within a block each return a
+continuation with compatible type (the [Examples](#examples) section
+provides several example usages of `cont.bind`).
+
+
+```wasm
+  cont.bind $ct2 : [tp1* (ref $ct1)] -> [(ref $ct2)]
+  where:
+  $ct1 = cont [tp1* tp2*] -> [tr*]
+  $ct2 = cont [tp2*] -> [tr*]
+```
+
+The instruction `cont.bind` binds the arguments of type `tp1*` to a
+continuation of type `$ct1`, yielding a modified continuation of type
+`$ct2` which expects fewer arguments. This instruction also consumes
+its continuation argument, and yields a new continuation that can be
+supplied to either `resume`,`resume_throw`, or `cont.bind`.
+
+### Trapping continuations
+
+In order to allow ensuring that control cannot be captured across
+certain abstraction or language boundaries, we provide an instruction
+for explicitly trapping attempts at reifying stacks across a certain
+point.
+
+```wasm
+  barrier $l bt instr* end : [t1*] -> [t2*]
+  where:
+  - bt = [t1*] -> [t2*]
+  - instr* : [t1*] -> [t2*]
+```
+
+The `barrier` instruction is a block with label `$l`, block type
+`bt = [t1*] -> [t2*]`, whose body is the instruction sequence given
+by `instr*`. Operationally, `barrier` may be viewed as a "catch-all"
+handler, that handles any control tag by invoking a trap.
+
+## Continuation lifetime
+
+### Producing continuations
+
+There are three different ways in which continuations are produced
+(`cont.new,suspend,cont.bind`). A fresh continuation object is
+allocated with `cont.new` and the current continuation is reused with
+`suspend` and `cont.bind`.
+
+The `cont.bind` instruction is directly analogous to the mildly
+controversial `func.bind` instruction from the function references
+proposal. However, whereas the latter necessitates the allocation of a
+new closure, as continuations are single-shot no allocation is
+necessary: all allocation happens when the original continuation is
+created by preallocating one slot for each continuation argument.
+
+### Consuming continuations
+
+There are three different ways in which continuations are consumed
+(`resume,resume_throw,cont.bind`). A continuation is resumed with a
+particular handler with `resume`. A continuation is aborted with
+`resume_throw`. A continuation is partially applied with `cont.bind`.
+
+In order to ensure that continuations are one-shot, `resume`,
+`resume_throw`, and `cont.bind` destructively modify the continuation
+object such that any subsequent use of the same continuation object
+will result in a trap.
+
+## Examples
+
+### Lightweight threads (static)
+
+(The full code for this example is [here](examples/static-lwt.wast).)
+
+Lightweight threads are one of the primary use-cases for typed
+continuations. In their most basic *static* form we assume a fixed
+collection of cooperative threads with a single tag that allows a
+thread to signal that it is willing to yield.
+
+```wasm
+(module $lwt
+  (tag $yield (export "yield"))
+)
+(register "lwt")
+```
+
+The `$yield` tag takes no parameter and has no result. Having
+declared it, we can now write some cooperative threads as functions.
+
+```wasm
+(module $example
+  (tag $yield (import "lwt" "yield"))
+  (func $log (import "spectest" "print_i32") (param i32))
+
+  (func $thread1 (export "thread1")
+    (call $log (i32.const 10))
+    (suspend $yield)
+    (call $log (i32.const 11))
+    (suspend $yield)
+    (call $log (i32.const 12))
+  )
+
+  (func $thread2 (export "thread2")
+    (call $log (i32.const 20))
+    (suspend $yield)
+    (call $log (i32.const 21))
+    (suspend $yield)
+    (call $log (i32.const 22))
+  )
+
+  (func $thread3 (export "thread3")
+    (call $log (i32.const 30))
+    (suspend $yield)
+    (call $log (i32.const 31))
+    (suspend $yield)
+    (call $log (i32.const 32))
+  )
+)
+(register "example")
+```
+
+Our intention is to interleave the execution of `$thread1`,
+`$thread2`, and `$thread3`, using `(suspend $yield)` to suspend
+execution to a scheduler which will perform a context switch.
+
+If we were to try to run any of these functions at the top-level then
+they would trap as soon as they try to suspend with the `$yield$`
+tag, because we have not yet specified how to handle it.
+
+We now define a scheduler.
+
+```wasm
+(module $scheduler
+  (type $func (func))
+  (type $cont (cont $func))
+
+  (tag $yield (import "lwt" "yield"))
+
+  ;; queue interface
+  (func $queue-empty (import "queue" "queue-empty") (result i32))
+  (func $dequeue (import "queue" "dequeue") (result (ref null $cont)))
+  (func $enqueue (import "queue" "enqueue") (param $k (ref $cont)))
+
+  (func $run (export "run")
+    (loop $l
+      (if (call $queue-empty) (then (return)))
+      (block $on_yield (result (ref $cont))
+        (resume (tag $yield $on_yield)
+                (call $dequeue)
+        )
+        (br $l)  ;; thread terminated
+      ) ;;   $on_yield (result (ref $cont))
+      (call $enqueue)  ;; continuation of current thread
+      (br $l)
+    )
+  )
+)
+(register "scheduler")
+```
+
+We assume a suitable interface to a queue of active threads
+represented as continuations. The scheduler is a loop which repeatedly
+runs the continuation (thread) at the head of the queue. It does so by
+resuming the continuation with a handler for the `$yield` tag. The
+handler `(tag $yield $on_yield)` specifies that the `$yield` tag
+is handled by running the code immediately following the block
+labelled with `$on_yield`, the `$on_yield` clause. The result of the
+block `(result (ref $cont))` declares that there will be a
+continuation on the stack when suspending with the `$yield` tag,
+which is the continuation of the currently executing thread. The
+`$on_yield` clause enqueues this continuation and proceeds to the next
+iteration of the loop.
+
+In order to interleave our three test threads together, we create a
+new continuation for each, enqueue the continuations, and invoke the
+scheduler. The `cont.new` operation turns a function reference into a
+corresponding continuation reference.
+
+```wasm
+(module
+  (type $func (func))
+  (type $cont (cont $func))
+
+  (func $scheduler (import "scheduler" "run"))
+  (func $enqueue (import "queue" "enqueue") (param (ref $cont)))
+
+  (func $log (import "spectest" "print_i32") (param i32))
+
+  (func $thread1 (import "example" "thread1"))
+  (func $thread2 (import "example" "thread2"))
+  (func $thread3 (import "example" "thread3"))
+
+  (elem declare func $thread1 $thread2 $thread3)
+
+  (func (export "run")
+    (call $enqueue (cont.new (type $cont) (ref.func $thread1)))
+    (call $enqueue (cont.new (type $cont) (ref.func $thread2)))
+    (call $enqueue (cont.new (type $cont) (ref.func $thread3)))
+
+    (call $log (i32.const -1))
+    (call $scheduler)
+    (call $log (i32.const -2))
+  )
+)
+
+(invoke "run")
+```
+
+The output is as follows.
+```
+-1 : i32
+10 : i32
+20 : i32
+30 : i32
+11 : i32
+21 : i32
+31 : i32
+12 : i32
+22 : i32
+32 : i32
+-2 : i32
+```
+The threads are interleaved as expected.
+
+### Lightweight threads (dynamic)
+
+(The full code for this example is [here](examples/lwt.wast).)
+
+We can make our lightweight threads functionality considerably more
+expressive by allowing new threads to be forked dynamically.
+
+```wasm
+(module $lwt
+  (type $func (func))
+  (type $cont (cont $func))
+
+  (tag $yield (export "yield"))
+  (tag $fork (export "fork") (param (ref $cont)))
+)
+(register "lwt")
+```
+
+We declare a new `$fork` tag that takes a continuation as a
+parameter and (like `$yield`) returns no result. Now we modify our
+example to fork each of the three threads from a single main thread.
+
+```wasm
+(module $example
+  (type $func (func))
+  (type $cont (cont $func))
+
+  (tag $yield (import "lwt" "yield"))
+  (tag $fork (import "lwt" "fork") (param (ref $cont)))
+
+  (func $log (import "spectest" "print_i32") (param i32))
+
+  (elem declare func $thread1 $thread2 $thread3)
+
+  (func $main (export "main")
+    (call $log (i32.const 0))
+    (suspend $fork (cont.new (type $cont) (ref.func $thread1)))
+    (call $log (i32.const 1))
+    (suspend $fork (cont.new (type $cont) (ref.func $thread2)))
+    (call $log (i32.const 2))
+    (suspend $fork (cont.new (type $cont) (ref.func $thread3)))
+    (call $log (i32.const 3))
+  )
+
+  (func $thread1
+    (call $log (i32.const 10))
+    (suspend $yield)
+    (call $log (i32.const 11))
+    (suspend $yield)
+    (call $log (i32.const 12))
+  )
+
+  (func $thread2
+    (call $log (i32.const 20))
+    (suspend $yield)
+    (call $log (i32.const 21))
+    (suspend $yield)
+    (call $log (i32.const 22))
+  )
+
+  (func $thread3
+    (call $log (i32.const 30))
+    (suspend $yield)
+    (call $log (i32.const 31))
+    (suspend $yield)
+    (call $log (i32.const 32))
+  )
+)
+(register "example")
+```
+
+As with the static example we define a scheduler module.
+```wasm
+(module $scheduler
+  (type $func (func))
+  (type $cont (cont $func))
+
+  (tag $yield (import "lwt" "yield"))
+  (tag $fork (import "lwt" "fork") (param (ref $cont)))
+
+  (func $queue-empty (import "queue" "queue-empty") (result i32))
+  (func $dequeue (import "queue" "dequeue") (result (ref null $cont)))
+  (func $enqueue (import "queue" "enqueue") (param $k (ref null $cont)))
+  ...
+)
+(register "scheduler")
+```
+
+In this example we illustrate five different schedulers. First, we
+write a baseline synchronous scheduler which simply runs the current
+thread to completion without actually yielding.
+
+```wasm
+  (func $sync (export "sync") (param $nextk (ref null $cont))
+    (loop $l
+      (if (ref.is_null (local.get $nextk)) (then (return)))
+      (block $on_yield (result (ref $cont))
+        (block $on_fork (result (ref $cont) (ref $cont))
+          (resume (tag $yield $on_yield)
+                  (tag $fork $on_fork)
+                  (local.get $nextk)
+          )
+          (local.set $nextk (call $dequeue))
+          (br $l)  ;; thread terminated
+        ) ;;   $on_fork (result (ref $cont) (ref $cont))
+        (local.set $nextk)                      ;; current thread
+        (call $enqueue) ;; new thread
+        (br $l)
+      )
+      ;;     $on_yield (result (ref $cont))
+      (local.set $nextk)  ;; carry on with current thread
+      (br $l)
+    )
+  )
+```
+
+The `$nextk` parameter represents the continuation of the next
+thread. The loop is repeatedly executed until `$nextk` is null
+(meaning that all threads have finished). The body of the loop is the
+code inside the two nested blocks. It resumes the next continuation,
+dequeues the next continuation, and then continues to the next
+iteration of the loop. The handler passed to `resume` specifies how to
+handle both `$yield` and `$fork` tags. Yielding carries on executing
+the current thread (this scheduler is synchronous). Forking enqueues
+the new thread and continues executing the current thread.
+
+As with the static example, the result of the `$on_yield` block
+`(result (ref $cont))` declares that there will be a continuation on
+the stack when suspending with the `$yield` tag, which is the
+continuation of the currently executing thread. The result of the
+`$on_fork` block `(result (ref $cont) (ref $cont))` declares that
+there will be two continuations on the stack when suspending with the
+`$fork` tag: the first is the parameter passed to fork (the new
+thread) and the second is the continuation of the currently executing
+thread.
+
+Running the synchronous scheduler on the example produces the following output.
+```
+0 : i32
+1 : i32
+2 : i32
+3 : i32
+10 : i32
+11 : i32
+12 : i32
+20 : i32
+21 : i32
+22 : i32
+30 : i32
+31 : i32
+32 : i32
+```
+First the main thread runs to completion, then each of the forked
+threads in sequence.
+
+Following a similar pattern, we define four different asynchronous
+schedulers.
+
+```wasm
+  ;; four asynchronous schedulers:
+  ;;   * kt and tk don't yield on encountering a fork
+  ;;     1) kt runs the continuation, queuing up the new thread for later
+  ;;     2) tk runs the new thread first, queuing up the continuation for later
+  ;;   * ykt and ytk do yield on encountering a fork
+  ;;     3) ykt runs the continuation, queuing up the new thread for later
+  ;;     4) ytk runs the new thread first, queuing up the continuation for later
+
+  ;; no yield on fork, continuation first
+  (func $kt (export "kt") (param $nextk (ref null $cont))
+    (loop $l
+      (if (ref.is_null (local.get $nextk)) (then (return)))
+      (block $on_yield (result (ref $cont))
+        (block $on_fork (result (ref $cont) (ref $cont))
+          (resume (tag $yield $on_yield)
+                  (tag $fork $on_fork)
+                  (local.get $nextk)
+          )
+          (local.set $nextk (call $dequeue))
+          (br $l)  ;; thread terminated
+        ) ;;   $on_fork (result (ref $cont) (ref $cont))
+        (local.set $nextk)                      ;; current thread
+        (call $enqueue) ;; new thread
+        (br $l)
+      )
+      ;;     $on_yield (result (ref $cont))
+      (call $enqueue)                    ;; current thread
+      (local.set $nextk (call $dequeue)) ;; next thread
+      (br $l)
+    )
+  )
+
+  ;; no yield on fork, new thread first
+  (func $tk (export "tk") (param $nextk (ref null $cont))
+    (loop $l
+      (if (ref.is_null (local.get $nextk)) (then (return)))
+      (block $on_yield (result (ref $cont))
+        (block $on_fork (result (ref $cont) (ref $cont))
+          (resume (tag $yield $on_yield)
+                  (tag $fork $on_fork)
+                  (local.get $nextk)
+          )
+          (local.set $nextk (call $dequeue))
+          (br $l)  ;; thread terminated
+        ) ;;   $on_fork (result (ref $cont) (ref $cont))
+        (call $enqueue)                            ;; current thread
+        (local.set $nextk) ;; new thread
+        (br $l)
+      )
+      ;;     $on_yield (result (ref $cont))
+      (call $enqueue)                    ;; current thread
+      (local.set $nextk (call $dequeue)) ;; next thread
+      (br $l)
+    )
+  )
+
+  ;; yield on fork, continuation first
+  (func $ykt (export "ykt") (param $nextk (ref null $cont))
+    (loop $l
+      (if (ref.is_null (local.get $nextk)) (then (return)))
+      (block $on_yield (result (ref $cont))
+        (block $on_fork (result (ref $cont) (ref $cont))
+          (resume (tag $yield $on_yield)
+                  (tag $fork $on_fork)
+                  (local.get $nextk)
+          )
+          (local.set $nextk (call $dequeue))
+          (br $l)  ;; thread terminated
+        ) ;;   $on_fork (result (ref $cont) (ref $cont))
+        (call $enqueue)                         ;; current thread
+        (call $enqueue) ;; new thread
+        (local.set $nextk (call $dequeue))      ;; next thread
+        (br $l)
+      )
+      ;;     $on_yield (result (ref $cont))
+      (call $enqueue)                    ;; current thread
+      (local.set $nextk (call $dequeue)) ;; next thread
+      (br $l)
+    )
+  )
+
+  ;; yield on fork, new thread first
+  (func $ytk (export "ytk") (param $nextk (ref null $cont))
+    (loop $l
+      (if (ref.is_null (local.get $nextk)) (then (return)))
+      (block $on_yield (result (ref $cont))
+        (block $on_fork (result (ref $cont) (ref $cont))
+          (resume (tag $yield $on_yield)
+                  (tag $fork $on_fork)
+                  (local.get $nextk)
+          )
+          (local.set $nextk (call $dequeue))
+          (br $l)  ;; thread terminated
+        ) ;;   $on_fork (result (ref $cont) (ref $cont))
+        (local.set $nextk)
+        (call $enqueue) ;; new thread
+        (call $enqueue (local.get $nextk))      ;; current thread
+        (local.set $nextk (call $dequeue))      ;; next thread
+        (br $l)
+      )
+      ;;     $on_yield (result (ref $cont))
+      (call $enqueue)                    ;; current thread
+      (local.set $nextk (call $dequeue)) ;; next thread
+      (br $l)
+    )
+  )
+```
+
+Each `$on_yield` clause is identical, enqueing the continuation of the
+current thread and dequeing the next continuation for the thread. The
+`$on_fork` clauses implement different behaviours for scheduling the
+current and newly forked threads.
+
+We run our example using each of the five schedulers.
+
+```wasm
+(module
+  (type $func (func))
+  (type $cont (cont $func))
+
+  (func $scheduler1 (import "scheduler" "sync") (param $nextk (ref null $cont)))
+  (func $scheduler2 (import "scheduler" "kt") (param $nextk (ref null $cont)))
+  (func $scheduler3 (import "scheduler" "tk") (param $nextk (ref null $cont)))
+  (func $scheduler4 (import "scheduler" "ykt") (param $nextk (ref null $cont)))
+  (func $scheduler5 (import "scheduler" "ytk") (param $nextk (ref null $cont)))
+
+  (func $log (import "spectest" "print_i32") (param i32))
+
+  (func $main (import "example" "main"))
+
+  (elem declare func $main)
+
+  (func (export "run")
+    (call $log (i32.const -1))
+    (call $scheduler1 (cont.new (type $cont) (ref.func $main)))
+    (call $log (i32.const -2))
+    (call $scheduler2 (cont.new (type $cont) (ref.func $main)))
+    (call $log (i32.const -3))
+    (call $scheduler3 (cont.new (type $cont) (ref.func $main)))
+    (call $log (i32.const -4))
+    (call $scheduler4 (cont.new (type $cont) (ref.func $main)))
+    (call $log (i32.const -5))
+    (call $scheduler5 (cont.new (type $cont) (ref.func $main)))
+    (call $log (i32.const -6))
+  )
+)
+
+(invoke "run")
+```
+
+The output is as follows, demonstrating the various different scheduling behaviours.
+```
+-1 : i32
+0 : i32
+1 : i32
+2 : i32
+3 : i32
+10 : i32
+11 : i32
+12 : i32
+20 : i32
+21 : i32
+22 : i32
+30 : i32
+31 : i32
+32 : i32
+-2 : i32
+0 : i32
+1 : i32
+2 : i32
+3 : i32
+10 : i32
+20 : i32
+30 : i32
+11 : i32
+21 : i32
+31 : i32
+12 : i32
+22 : i32
+32 : i32
+-3 : i32
+0 : i32
+10 : i32
+1 : i32
+20 : i32
+11 : i32
+2 : i32
+30 : i32
+21 : i32
+12 : i32
+3 : i32
+31 : i32
+22 : i32
+32 : i32
+-4 : i32
+0 : i32
+1 : i32
+10 : i32
+2 : i32
+20 : i32
+11 : i32
+3 : i32
+30 : i32
+21 : i32
+12 : i32
+31 : i32
+22 : i32
+32 : i32
+-5 : i32
+0 : i32
+10 : i32
+1 : i32
+11 : i32
+20 : i32
+2 : i32
+12 : i32
+21 : i32
+30 : i32
+3 : i32
+22 : i32
+31 : i32
+32 : i32
+-6 : i32
+```
+
+### Actors
+
+TODO
+
+### Async/await
+
+TODO
+
+### Delimited continuations
+
+(The full code for this example is [here](examples/control-lwt.wast).)
+
+Conventional unstructured delimited continuations can be directly
+implemented using our typed continuations design. Here we illustrate
+how to implement lightweight threads on top of the control/prompt
+delimited control operators.
+
+First we implement control/prompt.
+
+```wasm
+;; interface to control/prompt
+(module $control
+  (type $func (func))       ;; [] -> []
+  (type $cont (cont $func)) ;; cont ([] -> [])
+
+  ;; we sometimes write contref as shorthand for a reference to a continuation
+
+  (type $cont-func (func (param (ref $cont)))) ;; [contref ([] -> [])] -> []
+  (type $cont-cont (cont $cont-func))          ;; cont ([contref ([] -> [])] -> [])
+
+  ;; Implementation of a generic delimited control operator using
+  ;; effect handlers.
+  ;;
+  ;; For lightweight threads we have no payload. More general types
+  ;; for control and prompt are:
+  ;;
+  ;;   control : [([contref ([ta*] -> [tr*])] -> [tr*])] -> [ta*]
+  ;;   prompt : [contref ([] -> [tr*])] -> [tr*]
+  ;;
+  ;; (We can also give more refined types if we want to support
+  ;; answer-type modification and various flavours of answer-type
+  ;; polymorphism - but these are well outside the scope of a Wasm
+  ;; proposal!)
+  ;;
+  ;; (Technically this is control0/prompt0 rather than
+  ;; control/prompt.)
+  (tag $control (export "control") (param (ref $cont-func)))    ;; control : [([contref ([] -> [])] -> [])] -> []
+  (func $prompt (export "prompt") (param $nextk (ref null $cont)) ;; prompt : [(contref ([] -> []))] -> []
+    (block $on_control (result (ref $cont-func) (ref $cont))
+       (resume (tag $control $on_control)
+               (local.get $nextk))
+       (return)
+    ) ;;   $on_control (param (ref $cont-func) (ref $cont))
+    (let (local $h (ref $cont-func)) (local $k (ref $cont))
+      (call_ref (local.get $k) (local.get $h))
+    )
+  )
+)
+(register "control")
+```
+
+The `$control` tag amounts to a universal control tag, which takes a
+second-order function `$h` as an argument (it's second-order in that
+it's a function that itself takes a function, wrapped in a
+continuation, as an argument). The implementation of prompt is the
+universal handler for `$control`, which simply applies the second
+order function `$h` to the captured continuation.
+
+In the above code we have specialised `$control` and `$prompt` to the
+case where the continuation has no parameters and no results, as this
+suffices for implementing lightweight threads. A continuation
+parameter corresponds to the result of a control tag, so in the
+absence of parametric polymorphism, in order to simulate standard
+control tags in general we would need one copy of `$control` for each
+type of result we wanted to support.
+
+The following example is just like the one we implemented for dynamic
+lightweight threads using `$yield` and `$fork` tags decoupled from
+handlers for defining different schedulers. Here instead we
+parameterise the whole example by the behaviour of yielding and
+forking as `$yield` and `$fork` functions.
+
+```wasm
+(module $example
+  (type $func (func))       ;; [] -> []
+  (type $cont (cont $func)) ;; cont ([] -> [])
+
+  (type $cont-func (func (param (ref $cont)))) ;; [cont ([] -> [])] -> []
+  (type $cont-cont (cont $cont-func))          ;; cont ([cont ([] -> [])] -> [])
+
+  (type $func-cont-func-func (func (param (ref $func)) (param (ref $cont-func)))) ;; ([] -> []) -> ([contref ([] -> [])] -> []) -> []
+  (type $func-cont-func-cont (cont $func-cont-func-func))                         ;; cont (([] -> []) -> ([contref ([] -> [])] -> []) -> [])
+
+  (func $log (import "spectest" "print_i32") (param i32))
+
+  (elem declare func $main $thread1 $thread2 $thread3)
+
+  (func $main (export "main") (param $yield (ref $func)) (param $fork (ref $cont-func))
+    (call $log (i32.const 0))
+    (call_ref
+      (cont.bind (type $cont) (local.get $yield) (local.get $fork)
+        (cont.new (type $func-cont-func-cont) (ref.func $thread1)))
+      (local.get $fork))
+    (call $log (i32.const 1))
+    (call_ref
+      (cont.bind (type $cont) (local.get $yield) (local.get $fork)
+        (cont.new (type $func-cont-func-cont) (ref.func $thread2)))
+      (local.get $fork))
+    (call $log (i32.const 2))
+    (call_ref
+      (cont.bind (type $cont) (local.get $yield) (local.get $fork)
+        (cont.new (type $func-cont-func-cont) (ref.func $thread3)))
+      (local.get $fork))
+    (call $log (i32.const 3))
+  )
+
+  (func $thread1 (param $yield (ref $func)) (param $fork (ref $cont-func))
+    (call $log (i32.const 10))
+    (call_ref (local.get $yield))
+    (call $log (i32.const 11))
+    (call_ref (local.get $yield))
+    (call $log (i32.const 12))
+  )
+
+  (func $thread2 (param $yield (ref $func)) (param $fork (ref $cont-func))
+    (call $log (i32.const 20))
+    (call_ref (local.get $yield))
+    (call $log (i32.const 21))
+    (call_ref (local.get $yield))
+    (call $log (i32.const 22))
+  )
+
+  (func $thread3 (param $yield (ref $func)) (param $fork (ref $cont-func))
+    (call $log (i32.const 30))
+    (call_ref (local.get $yield))
+    (call $log (i32.const 31))
+    (call_ref (local.get $yield))
+    (call $log (i32.const 32))
+  )
+)
+(register "example")
+```
+
+The function type `$func-cont-func-fun` is the type of a function that
+takes an implementation of a `$yield` function and the implementation
+as a `$fork` function as pararameters; the continuation type
+`$func-cont-func-cont` is the same thing as a continuation.
+
+We now define a scheduler module analogous to that of the previous
+dynamic lightweight thread example. As before, we will implement five
+different schedulers.
+
+```wasm
+(module
+  (type $func (func))       ;; [] -> []
+  (type $cont (cont $func)) ;; cont ([] -> [])
+
+  (type $cont-func (func (param (ref $cont)))) ;; [contref ([] -> [])] -> []
+  (type $cont-cont (cont $cont-func))          ;; [(contref ([contref ([] -> [])]))] -> []
+
+  (type $func-cont-func-func (func (param (ref $func)) (param (ref $cont-func)))) ;; ([] -> []) -> ([cont ([] -> [])] -> []) -> []
+  (type $func-cont-func-cont (cont $func-cont-func-func))                         ;; cont (([] -> []) -> ([cont ([] -> [])] -> []) -> [])
+
+  (elem declare func
+     $handle-yield-sync $handle-yield
+     $handle-fork-sync $handle-fork-kt $handle-fork-tk $handle-fork-ykt $handle-fork-ytk
+     $yield
+     $fork-sync $fork-kt $fork-tk $fork-ykt $fork-ytk)
+
+  ;; control/prompt interface
+  (tag $control (import "control" "control") (param (ref $cont-func)))     ;; control : ([cont ([] -> [])] -> []) -> []
+  (func $prompt (import "control" "prompt") (param $nextk (ref null $cont))) ;; prompt : cont ([] -> []) -> []
+
+  ;; queue interface
+  (func $queue-empty (import "queue" "queue-empty") (result i32))
+  (func $dequeue (import "queue" "dequeue") (result (ref null $cont)))
+  (func $enqueue (import "queue" "enqueue") (param $k (ref $cont)))
+  ...
+(register "scheduler")
+```
+
+Unlike before, with control/prompt a generic scheduler loop must be
+decoupled from the implementations of each operation (yield / fork) as
+the latter are passed in as arguments to user code
+
+```wasm
+  ;; generic boilerplate scheduler
+  (func $scheduler (param $nextk (ref null $cont))
+    (loop $loop
+      (if (ref.is_null (local.get $nextk)) (then (return)))
+      (call $prompt (local.get $nextk))
+      (local.set $nextk (call $dequeue))
+      (br $loop)
+    )
+  )
+```
+
+The scheduler loop simply keeps on calling prompt with the next thread
+in the queue until the queue of threads is exhausted.
+
+For each scheduler, we invoke the generic scheduler using a
+continuation parameterised by suitable implementations of yield and
+fork.
+
+First, we do the baseline synchronous scheduler.
+
+```wasm
+  ;; synchronous scheduler
+  (func $handle-yield-sync (param $k (ref $cont))
+    (call $scheduler (local.get $k))
+  )
+  (func $yield-sync
+    (suspend $control (ref.func $handle-yield))
+  )
+  (func $handle-fork-sync (param $t (ref $cont)) (param $k (ref $cont))
+    (call $enqueue (local.get $t))
+    (call $scheduler (local.get $k))
+  )
+  (func $fork-sync (param $t (ref $cont))
+    (suspend $control (func.bind (type $cont-func) (local.get $t) (ref.func $handle-fork-sync)))
+  )
+  (func $sync (export "sync") (param $k (ref $func-cont-func-cont))
+    (call $scheduler
+      (cont.bind (type $cont) (ref.func $yield) (ref.func $fork-sync) (local.get $k)))
+  )
+```
+
+The `func.bind` instruction is needed in the implementations of fork
+More generally `func.bind` is needed for any operation that takes
+arguments. One could use another continuation here instead, but
+constructing a new continuation every time an operation is invoked
+seems unnecessarily wasteful.
+
+All of the asynchronous schedulers make use of the same implementation
+of yield, which enqueues the continuation of the current thread and
+dequeues the next available thread.
+
+```wasm
+  ;; asynchronous yield (used by all asynchronous schedulers)
+  (func $handle-yield (param $k (ref $cont))
+    (call $enqueue (local.get $k))
+    (call $scheduler (call $dequeue))
+  )
+  (func $yield
+    (suspend $control (ref.func $handle-yield))
+  )
+```
+
+Each asynchronous scheduler uses its own implementation of fork.
+
+```wasm
+  ;; four asynchronous implementations of fork:
+  ;;   * kt and tk don't yield on encountering a fork
+  ;;     1) kt runs the continuation, queuing up the new thread for later
+  ;;     2) tk runs the new thread first, queuing up the continuation for later
+  ;;   * ykt and ytk do yield on encountering a fork
+  ;;     3) ykt runs the continuation, queuing up the new thread for later
+  ;;     4) ytk runs the new thread first, queuing up the continuation for later
+
+  ;; no yield on fork, continuation first
+  (func $handle-fork-kt (param $t (ref $cont)) (param $k (ref $cont))
+    (call $enqueue (local.get $t))
+    (call $scheduler (local.get $k))
+  )
+  (func $fork-kt (param $t (ref $cont))
+    (suspend $control (func.bind (type $cont-func) (local.get $t) (ref.func $handle-fork-kt)))
+  )
+  (func $kt (export "kt") (param $k (ref $func-cont-func-cont))
+    (call $scheduler
+      (cont.bind (type $cont) (ref.func $yield) (ref.func $fork-kt) (local.get $k)))
+  )
+
+  ;; no yield on fork, new thread first
+  (func $handle-fork-tk (param $t (ref $cont)) (param $k (ref $cont))
+    (call $enqueue (local.get $k))
+    (call $scheduler (local.get $t))
+  )
+  (func $fork-tk (param $t (ref $cont))
+    (suspend $control (func.bind (type $cont-func) (local.get $t) (ref.func $handle-fork-tk)))
+  )
+  (func $tk (export "tk") (param $k (ref $func-cont-func-cont))
+    (call $scheduler
+      (cont.bind (type $cont) (ref.func $yield) (ref.func $fork-tk) (local.get $k)))
+  )
+
+  ;; yield on fork, continuation first
+  (func $handle-fork-ykt (param $t (ref $cont)) (param $k (ref $cont))
+    (call $enqueue (local.get $k))
+    (call $enqueue (local.get $t))
+    (call $scheduler (call $dequeue))
+  )
+  (func $fork-ykt (param $t (ref $cont))
+    (suspend $control (func.bind (type $cont-func) (local.get $t) (ref.func $handle-fork-ykt)))
+  )
+  (func $ykt (export "ykt") (param $k (ref $func-cont-func-cont))
+    (call $scheduler
+      (cont.bind (type $cont) (ref.func $yield) (ref.func $fork-ykt) (local.get $k)))
+  )
+
+  ;; yield on fork, new thread first
+  (func $handle-fork-ytk (param $t (ref $cont)) (param $k (ref $cont))
+    (call $enqueue (local.get $t))
+    (call $enqueue (local.get $k))
+    (call $scheduler (call $dequeue))
+  )
+  (func $fork-ytk (param $t (ref $cont))
+    (suspend $control (func.bind (type $cont-func) (local.get $t) (ref.func $handle-fork-ytk)))
+  )
+  (func $ytk (export "ytk") (param $k (ref $func-cont-func-cont))
+    (call $scheduler
+      (cont.bind (type $cont) (ref.func $yield) (ref.func $fork-ytk) (local.get $k)))
+  )
+)
+(register "scheduler")
+```
+
+Invoking the schedulers is much like in our original dynamic
+lightweight threads example, but the types are more complex due to the
+need to index the handled computation (`$main` in this case) by the
+implementations of forking and yielding.
+
+```wasm
+(module
+  (type $func (func))       ;; [] -> []
+  (type $cont (cont $func)) ;; cont ([] -> [])
+
+  (type $cont-func (func (param (ref $cont)))) ;; [contref ([] -> [])] -> []
+  (type $cont-cont (cont $cont-func))          ;; cont ([contref ([] -> [])] -> [])
+
+  (type $func-cont-func-func (func (param (ref $func)) (param (ref $cont-func)))) ;; ([] -> []) -> ([contref ([] -> [])] -> []) -> []
+  (type $func-cont-func-cont (cont $func-cont-func-func))                         ;; contref (([] -> []) -> ([contref ([] -> [])] -> []) -> [])
+
+  (func $scheduler-sync (import "scheduler" "sync") (param $nextk (ref $func-cont-func-cont)))
+  (func $scheduler-kt (import "scheduler" "kt") (param $nextk (ref $func-cont-func-cont)))
+  (func $scheduler-tk (import "scheduler" "tk") (param $nextk (ref $func-cont-func-cont)))
+  (func $scheduler-ykt (import "scheduler" "ykt") (param $nextk (ref $func-cont-func-cont)))
+  (func $scheduler-ytk (import "scheduler" "ytk") (param $nextk (ref $func-cont-func-cont)))
+
+  (func $log (import "spectest" "print_i32") (param i32))
+
+  (func $main (import "example" "main") (param $yield (ref $func)) (param $fork (ref $cont-func)))
+
+  (elem declare func $main)
+
+  (func $run (export "run")
+    (call $log (i32.const -1))
+    (call $scheduler-sync (cont.new (type $func-cont-func-cont) (ref.func $main)))
+    (call $log (i32.const -2))
+    (call $scheduler-kt (cont.new (type $func-cont-func-cont) (ref.func $main)))
+    (call $log (i32.const -3))
+    (call $scheduler-tk (cont.new (type $func-cont-func-cont) (ref.func $main)))
+    (call $log (i32.const -4))
+    (call $scheduler-ykt (cont.new (type $func-cont-func-cont) (ref.func $main)))
+    (call $log (i32.const -5))
+    (call $scheduler-ytk (cont.new (type $func-cont-func-cont) (ref.func $main)))
+    (call $log (i32.const -6))
+  )
+)
+```
+
+The output of running this code is just as in the direct
+implementation of dynamic lightweight threads.
+
+## Implementation strategies
+
+### Segmented stacks
+
+TODO
+
+<!--
+Segmented stacks is an implementation technique for
+continuations (cite: Dybvig et al., Chez Scheme, Multicore OCaml). The
+principal idea underpinning segmented stacks is to view each
+continuation as representing a separate stack.
+
+Initially there is one stack, which may create other stacks. Each
+child stack may create further stacks. Lineage of stacks is maintained
+by linking children to their parent.
+
+```ioke
+      (stack 1)
+       (active)
+ |-----------------------|
+ |                       |
+ | ...                   |
+ |                       |
+ | (resume $h1 $c); |
+>| $c = (cont.new $f)    |
+ |                       |
+ .                       .
+ .                       .
+
+```
+
+The first stack may perform some computation, before the stack pointer
+`>` moves to the `cont.new` instruction. Execution of the `cont.new`
+instruction creates a new suspended stack for the computation implied
+by `$f`.
+
+
+```ioke
+      (stack 1)                         (stack 2)
+       (active)
+ |---------------------|
+ |                     |
+ | ...                 |
+ |                     |                 (suspended)
+ |                     |           |---------------------|
+>| resume $h1 $c -------------| $f()                |
+ .                     .           .                     .
+ .                     .           .                     .
+                                   .                     .
+
+```
+
+Stack 1 maintains control after the creation of stack 2, and thus
+execution continues on stack 1. The next instruction, `resume`
+suspends stack 1 and transfers control to new stack 2. Before
+transferring control, the instruction installs a delimiter `$h1` on
+stack 1. The transfer of control reverses the parent-child link, such
+that stack 2 now points back to stack 1. The instruction also installs
+a delimiter on the parent
+
+```ioke
+      (stack 1)                         (stack 2)
+       (active)
+ |---------------------|
+ |                     |
+ | ...                 |
+ |                     |                 (suspended)
+ |                     |       ----|---------------------|
+>| $h1                 |<-----/    | $f()                |
+ .                     .           |                     |
+ .                     .           .                     .
+ .                     .           .                     .
+                                   .                     .
+```
+
+The stack pointer moves to the top of stack 2, and thus execution
+continues on stack 2.
+
+
+```ioke
+      (stack 1)                         (stack 2)
+       (suspended)
+ |---------------------|
+ |                     |
+ | ...                 |
+ |                     |                 (active)
+ |                     |       ----|---------------------|
+ | $h1                 |<-----/   >| $f()                |
+ .                     .           |                     |
+ .                     .           .                     .
+ .                     .           .                     .
+                                   .                     .
+```
+
+As execution continues on stack 2 it may eventually perform a
+`suspend`, which will cause another transfer of
+control. Supposing it invokes `suspend` with some `$e` handled
+by `$h1`, then stack 2 will transfer control back to stack 1.
+
+
+```ioke
+      (stack 1)                         (stack 2)
+       (suspended)
+ |---------------------|
+ |                     |
+ | ...                 |
+ |                     |                 (active)
+ |                     |       ----|---------------------|
+ | $h1                 |<-----/    | ...                 |
+ .                     .          >| suspend $e     |
+ .                     .           .                     .
+ .                     .           .                     .
+                                   .                     .
+```
+
+The suspension reverses the parent-child link again, and leaves behind
+a "hole" on stack 2, that can be filled by an invocation of
+`resume`.
+
+```ioke
+      (stack 1)                         (stack 2)
+       (suspended)
+ |---------------------|
+ |                     |
+ | ...                 |
+ |                     |                 (active)
+ |                     |       ----|---------------------|
+>| $h1                 |------/    | ...                 |
+ .                     .           | [ ]                 |
+ .                     .           .                     .
+ .                     .           .                     .
+                                   .                     .
+```
+
+-->
+
+
+### Continuation-passing style
+
+TODO
+
+### Virtual memory
+
+TODO
+
+### Stack cut'n'paste
+
+TODO
+
+### OS threads
+
+TODO
+
+## Design considerations and extensions
+
+### Memory management
+
+The current proposal does not require a general garbage collector as
+the linearity of continuations guarantees that there are no cycles in
+continuation objects. In theory, we could dispense with automated
+memory management altogether if we took seriously the idea that
+failure to use a continuation constitutes a bug in the producer. In
+practice, for most producers enforcing such a discipline is
+unrealistic and not something an engine can rely on anyway. To prevent
+space leaks, most engines will need some form of automated memory
+meanagement for unconsumed continuations. Due to the acyclicity of
+continuations, a reference counting scheme is sufficient.
+
+### Linear versus constant time dispatch
+
+The `suspend` instruction relies on traversing a stack of
+handlers in order to find the appropriate handler, similarly to
+exception handling. A potential problem is that this can incur a
+linear runtime cost, especially if we think in terms of segmented
+stacks, where `suspend` must search the active stack chain for a
+suitable handler for its argument. Practical experience from Multicore
+OCaml suggests that for critical use cases (async/await, lightweight
+threads, actors, etc.) the depth of the handler stack tends to be
+small so the cost of this linear traversal is negligible. Nonetheless,
+future applications may benefit from constant-time dispatch. To enable
+constant-time dispatch we would need to know the target stack a
+priori, which might be acheived either by maintaining a shadow stack
+or by extending `suspend` to explicitly target a named handler.
+
+### Named handlers
+
+We can accommodate named handlers by introducing a new reference type
+`handler t*`, which essentially is a unique prompt created by
+executing a variant of the `resume` instruction and is passed to the
+continuation:
+
+```wasm
+  resume_with (tag $e $l)* : [ t1* (ref $ht) ] -> [ t2* ]
+  where:
+  - $ht = handler t2*
+  - $ct = cont ([ (ref $ht) t1* ] -> [ t2* ])
+```
+
+The handler reference is similar to a prompt in a system of
+multi-prompt continuations. However, since it is created fresh for
+each handler, multiple activations of the same prompt cannot exist by
+construction.
+
+This instruction is complemented by an instruction for suspending to a
+specific handler:
+
+```wasm
+  suspend_to $e : [ s* (ref $ht) ] -> [ t* ]
+  where:
+  - $ht = handler tr*
+  - $e : [ s* ] -> [ t* ]
+```
+
+If the handler is not currently active, e.g., because an outer handler
+has been suspended, then this instruction would trap.
+
+### Direct switching
+
+The current proposal uses the asymmetric suspend/resume pair of
+primitives that is characteristic of effect handlers. It does not
+include a symmetric way of switching to another continuation directly,
+without going through a handler, and it is conceivable that the double
+hop through a handler might involve unnecessary overhead for use cases
+like lightweight threading.
+
+Though there is currently no evidence that the double hop overhead is
+significant in practice, if it does turn out to be important for some
+applications then the current proposal can be extended with a more
+symmetric `switch_to` primitive.
+
+Given named handlers, it is possible to introduce a somewhat magic
+instruction for switching directly to another continuation:
+
+```wasm
+  switch_to : [ t1* (ref $ct1) (ref $ht) ] -> [ t2* ]
+  where:
+  - $ht = handler t3*
+  - $ct1 = cont ([ (ref $ht) (ref $ct2$) t1* ] -> [ t3* ])
+  - $ct2 = cont ([ t2* ] -> [ t3* ])
+```
+
+This behaves as if there was a built-in tag
+
+```wasm
+  (tag $Switch (param t1* (ref $ct1)) (result t3*))
+```
+
+with which the computation suspends to the handler, and the handler
+implicitly handles this by resuming to the continuation argument,
+thereby effectively switching to it in one step. Like `suspend_to`,
+this would trap if the handler was not currently active.
+
+The fact that the handler implicitly resumes, passing itself as a
+handler to the target continuation, makes this construct behave like a
+deep handler, which is slightly at odds with the rest of the proposal.
+
+In addition to the handler, `switch_to` also passes the new
+continuation to the target, which allows the target to switch back to
+it in a symmetric fashion. Notably, in such a use case, `$ct1` and
+`$ct2` would be the same type (and hence recursive).
+
+In fact, symmetric switching need not necessarily be tied to named
+handlers, since there could also be an indirect version with dynamic
+handler lookup:
+
+```wasm
+  switch : [ t1* (ref $ct1) ] -> [ t2* ]
+  where:
+  - $ct1 = cont ([ (ref $ct2) t1* ] -> [ t3* ])
+  - $ct2 = cont ([ t2* ] -> [ t3* ])
+```
+
+It seems undesirable that every handler implicitly handles the
+built-in `$Switch` tag, so this should be opt-in by a mode flag on the
+resume instruction(s).
+
+### Control/prompt as an alternative basis
+
+An alternative to our typed continuations proposal is to use more
+established delimited control operators such as control/prompt and
+shift/reset. As illustrated in the examples section, control/prompt
+can be viewed as a special instance of the current proposal with a
+single universal control tag `control` and a handler for each
+`prompt`.
+
+As `control` amounts to a universal control tag it correspondingly has
+a higher-order type. As illustrated by the example, this requires more
+complicated types than with the current proposal and depends on
+greater use of function closures.
+
+When considered as a source language feature effect handlers are
+preferable to control/prompt because they are more modular and easier
+to reason about. Effect handlers naturally provide a separation of
+concerns. Users program to an effect interface, whereas `control`
+allows (and indeed requires) them to essentially rewrite the
+implementation inline (in practice this is unmanageable, so one
+abstracts over a few key behaviours using functions as illustrated in
+the example). Of course, intermediate languages have different
+requirements to source languages, so modularity and ease of reasoning
+may be less critical. Nonetheless, they should not be discounted
+entirely.
+
+### Coupling of continuation capture and dispatch
+
+A possible concern with the current design is that it relies on a
+specific form of dispatch based on tags. Suspending not only captures
+the current continuation up to the nearest prompt, but also dispatches
+to the handler clause associated with the given tag. It might be
+tempting to try to decouple continuation capture from dispatch, but it
+is unclear what other form of dispatch would be useful or whether
+there is a clean way to enable such decoupling.
+
+With control/prompt there is no coupling of continuation capture with
+dispatch, because there is no dispatch. But this is precisely because
+`control` behaves as a universal tag, which requires behaviour to be
+given inline via a closure, breaking modularity and necessitating a
+higher-order type even for simple uses of continuations like
+lightweight threads.
+
+This is not to say that control/prompt or a generalisation to
+multiprompt delimited continuations is necessarily a bad low-level
+implementation technique. For instance, the
+[libmprompt](https://github.com/koka-lang/libmprompt) C library
+implements effect handlers on top of multiprompt delimited
+continuations. However, a key difference there is that the C
+implementation does not require static stack typing, something that is
+fundamental to the design of Wasm. Thus, the implementation does not
+need to contend directly with the higher-order type of `control`.
+
+### Tail-resumptive handlers
+
+A handler is said to be *tail-resumptive* if the handler invokes the
+continuation in tail-position in every control tag clause. The
+canonical example of a tail-resumptive handler is dynamic binding
+(which can be useful to implement implicit parameters to
+computations). The control tag clauses of a tail-resumptive handler
+can be inlined at the control tag invocation sites, because they do
+not perform any non-trivial control flow manipulation, they simply
+retrieve a value. Inlining clause definitions means that no time is
+spent constructing continuation objects.
+
+The present iteration of this proposal does not include facilities for
+identifying and inlining tail-resumptive handlers. None of the
+critical use-cases requires such a facility. Nevertheless, it is
+natural to envisage a future iteration of this proposal that includes
+an extension for distinguishing tail-resumptive handlers.
+
+### Multi-shot continuations
+
+Continuations in this proposal are *single-shot* (aka *linear*),
+meaning that they must be invoked exactly once (though this is not
+statically enforced). A continuation can be invoked either by resuming
+it (with `resume`) or by aborting it (with `resume_throw`). Some
+applications such as backtracking, probabilistic programming, and
+process duplication exploit *multi-shot* continuations, but none of
+the critical use cases require multi-shot continuations. Nevertheless,
+it is natural to envisage a future iteration of this proposal that
+includes support for multi-shot continuations by way of a continuation
+clone instruction.
+
+### Interoperability, legacy code, and the barrier instruction
+
+The barrier instruction provides a direct way of preventing control
+tags from being suspended outside a particular computation.
+
+Consider a module A written using an existing C/C++ compiler that
+targets a Wasm backend. Let us assume that module A depends on a
+second Wasm module B. Now suppose that the producer for module B is
+updated to take advantage of typed continuations. In order to ensure
+that suspensions arising in calls to B do not pass through A,
+potentially causing unexpected changes to the semantics of A, the
+producer for module A can ensure that all external calls are wrapped
+in the barrier instruction.
+
+It might seem preferable to somehow guarantee that support for typed
+continuations is not enabled by default, meaning that no changes to
+the producer for module A would be necessary. But it is unclear what
+such an approach would look like in practice and whether it would
+actually be feasible. In any case, using the barrier instruction the
+producer for B could make module B safe for linking with an unchanged
+module A by wrapping the barrier instruction around all of the
+functions exported by module B.
+
+Questions of Wasm interoperability and support for legacy code are
+largely orthogonal to the typed continuations proposal and similar
+issues already arise with extensions such as exceptions.
+
+### First-class tags
+
+In the current proposal tags are statically defined in a module
+header. This should suffice for supporting the critical
+use-cases. However, for some purposes, such as implementing richer
+forms of control operators such as effect handlers, it might be useful
+to add support for dynamically generated tags. These could be used,
+for instance, for more efficiently compiling effect handlers that take
+advantage of features such as Multicore OCaml's functors, where the
+type of an effect (tag) may not be fully known at compile time.
+
+### Shallow versus deep handlers
+
+The effect handlers feature which underlies the design of the typed
+continuations proposal classically comes in too forms: shallow and
+deep handlers. With shallow handlers, the installation of handlers is
+completely decoupled from resuming a continuation. With deep handlers,
+the handler that produced the continuation is automatically
+reinstalled when a continuation is resumed. The typed continuations
+proposal adopts a hybrid of shallow and deep handlers, which we call
+*sheep handlers*. Like a shallow handler, there is no automatic
+reinstallation of an existing handler. But like deep handlers a new
+handler is installed when a continuation is resumed: the new handler
+is written explicitly as part of the `resume` instruction.
+
+
+TODO: resuspend (aka OCaml's reperform, and analogous to exception proposal's rethrow)
+
+TODO: return clauses
+
+TODO: preemption / asynchrony / interrupts
+
+TODO: how do we interact with parametric polymorphism?
+
+TODO: lexically-scoped handlers
+
+TODO: parametric tags / existential types?
+
+TODO: tag subtyping?
+
+TODO: compare to asyncify?
+
+TODO: compare to Wasm/k?
+
+TOOD: compare to the Koka Wasm backend?
diff --git a/proposals/continuations/Overview.md b/proposals/continuations/Overview.md
new file mode 100644
index 00000000..568c6783
--- /dev/null
+++ b/proposals/continuations/Overview.md
@@ -0,0 +1,158 @@
+# Typed Continuations for WebAssembly
+
+## Language Extensions
+
+Based on [typed reference proposal](https://github.com/WebAssembly/function-references/blob/master/proposals/function-references/Overview.md) and [exception handling proposal](https://github.com/WebAssembly/exception-handling/blob/master/proposals/exception-handling/Exceptions.md).
+
+
+### Types
+
+#### Defined Types
+
+* `cont <typeidx>` is a new form of defined type
+  - `(cont $ft) ok` iff `$ft ok` and `$ft = [t1*] -> [t2*]`
+
+
+### Instructions
+
+* `cont.new <typeidx>` creates a new continuation
+  - `cont.new $ct : [(ref null? $ft)] -> [(ref $ct)]`
+    - iff `$ct = cont $ft`
+
+* `cont.bind <typidx>` binds a continuation to (partial) arguments
+  - `cont.bind $ct : [t3* (ref null? $ct')] -> [(ref $ct)]`
+    - iff `$ct = cont $ft`
+    - and `$ft = [t1*] -> [t2*]`
+    - and `$ct' = cont $ft'`
+    - and `$ft' = [t3* t1'*] -> [t2'*]`
+    - and `[t1'*] -> [t2'*] <: [t1*] -> [t2*]`
+
+* `suspend <tagidx>` suspends the current continuation
+  - `suspend $t : [t1*] -> [t2*]`
+    - iff `tag $t : [t1*] -> [t2*]`
+
+* `resume (tag <tagidx> <labelidx>)*` resumes a continuation
+  - `resume (tag $e $l)* : [t1* (ref null? $ct)] -> [t2*]`
+    - iff `$ct = cont $ft`
+    - and `$ft = [t1*] -> [t2*]`
+    - and `(tag $t : [te1*] -> [te2*])*`
+    - and `(label $l : [te1'* (ref null? $ct')])*`
+    - and `([te1*] <: [te1'*])*`
+    - and `($ct' = cont $ft')*`
+    - and `([te2*] -> [t2*] <: $ft')*`
+
+* `resume_throw <tagidx>` aborts a continuation
+  - `resume_throw $e : [te* (ref null? $ct)] -> [t2*]`
+    - iff `exception $e : [te*]`
+    - and `$ct = cont $ft`
+    - and `$ft = [t1*] -> [t2*]`
+
+* `barrier <blocktype> <instr>* end` blocks suspension
+  - `barrier $l bt instr* end : [t1*] -> [t2*]`
+    - iff `bt = [t1*] -> [t2*]`
+    - and `instr* : [t1*] -> [t2*]` with labels extended with `[t2*]`
+
+
+## Reduction Semantics
+
+### Store extensions
+
+* New store component `tags` for allocated tags
+  - `S ::= {..., tags <taginst>*}`
+
+* A *tag instance* represents a control tag
+  - `taginst ::= {type <tagtype>}`
+
+* New store component `conts` for allocated continuations
+  - `S ::= {..., conts <cont>?*}`
+
+* A continuation is a context annotated with its hole's arity
+  - `cont ::= (E : n)`
+
+
+### Administrative instructions
+
+* `(ref.cont a)` represents a continuation value, where `a` is a *continuation address* indexing into the store's `conts` component
+  - `ref.cont a : [] -> [(ref $ct)]`
+    - iff `S.conts[a] = epsilon \/ S.conts[a] = (E : n)`
+    - and `$ct = cont $ft`
+    - and `$ft = [t1^n] -> [t2*]`
+
+* `(handle{(<tagaddr> <labelidx>)*}? <instr>* end)` represents an active handler (or a barrier when no handler list is present)
+  - `(handle{(a $l)*}? instr* end) : [t1*] -> [t2*]`
+    - iff `instr* : [t1*] -> [t2*]`
+    - and `(S.tags[a].type = [te1*] -> [te2*])*`
+    - and `(label $l : [te1'* (ref null? $ct')])*`
+    - and `([te1*] <: [te1'*])*`
+    - and `($ct' = cont $ft')*`
+    - and `([te2*] -> [t2*] <: $ft')*`
+
+
+### Handler contexts
+
+```
+H^ea ::=
+  _
+  val* H^ea instr*
+  label_n{instr*} H^ea end
+  frame_n{F} H^ea end
+  catch{...} H^ea end
+  handle{(ea' $l)*} H^ea end   (iff ea notin ea'*)
+```
+
+
+### Reduction
+
+* `S; F; (ref.null t) (cont.new $ct)  -->  S; F; trap`
+
+* `S; F; (ref.func fa) (cont.new $ct)  -->  S'; F; (ref.cont |S.conts|)`
+  - iff `S' = S with conts += (E : n)`
+  - and `E = _ (invoke fa)`
+  - and `$ct = cont $ft`
+  - and `$ft = [t1^n] -> [t2*]`
+
+* `S; F; (ref.null t) (cont.bind $ct)  -->  S; F; trap`
+
+* `S; F; (ref.cont ca) (cont.bind $ct)  -->  S'; F; trap`
+  - iff `S.conts[ca] = epsilon`
+
+* `S; F; v^n (ref.cont ca) (cont.bind $ct)  -->  S'; F; (ref.const |S.conts|)`
+  - iff `S.conts[ca] = (E' : n')`
+  - and `$ct = cont $ft`
+  - and `$ft = [t1'*] -> [t2'*]`
+  - and `n = n' - |t1'*|`
+  - and `S' = S with conts[ca] = epsilon with conts += (E : |t1'*|)`
+  - and `E = E'[v^n _]`
+
+* `S; F; (ref.null t) (resume (tag $e $l)*)  -->  S; F; trap`
+
+* `S; F; (ref.cont ca) (resume (tag $e $l)*)  -->  S; F; trap`
+  - iff `S.conts[ca] = epsilon`
+
+* `S; F; v^n (ref.cont ca) (resume (tag $e $l)*)  -->  S'; F; handle{(ea $l)*} E[v^n] end`
+  - iff `S.conts[ca] = (E : n)`
+  - and `(ea = F.tags[$e])*`
+  - and `S' = S with conts[ca] = epsilon`
+
+* `S; F; (ref.null t) (resume_throw $e)  -->  S; F; trap`
+
+* `S; F; (ref.cont ca) (resume_throw $e)  -->  S; F; trap`
+  - iff `S.conts[ca] = epsilon`
+
+* `S; F; v^m (ref.cont ca) (resume_throw $e)  -->  S'; F; E[v^m (throw $e)]`
+  - iff `S.conts[ca] = (E : n)`
+  - and `S.tags[F.tags[$e]].type = [t1^m] -> [t2*]`
+  - and `S' = S with conts[ca] = epsilon`
+
+* `S; F; (barrier bt instr* end)  -->  S; F; handle instr* end`
+
+* `S; F; (handle{(e $l)*}? v* end)  -->  S; F; v*`
+
+* `S; F; (handle H^ea[(suspend $e)] end)  --> S; F; trap`
+  - iff `ea = F.tags[$e]`
+
+* `S; F; (handle{(ea1 $l1)* (ea $l) (ea2 $l2)*} H^ea[v^n (suspend $e)] end)  --> S'; F; v^n (ref.cont |S.conts|) (br $l)`
+  - iff `ea notin ea1*`
+  - and `ea = F.tags[$e]`
+  - and `S.tags[ea].type = [t1^n] -> [t2^m]`
+  - and `S' = S with conts += (H^ea : m)`
diff --git a/proposals/continuations/examples/actor-lwt.wast b/proposals/continuations/examples/actor-lwt.wast
new file mode 100644
index 00000000..60d87959
--- /dev/null
+++ b/proposals/continuations/examples/actor-lwt.wast
@@ -0,0 +1,585 @@
+;; Actors via lightweight threads
+
+;; actor interface
+(module $actor
+  (type $func (func))       ;; [] -> []
+  (type $cont (cont $func)) ;; cont ([] -> [])
+
+  ;; self : [i32] -> []
+  ;; spawn : [cont ([] -> [])] -> [i32]
+  ;; send : [i32 i32] -> []
+  ;; recv : [] -> [i32]
+  (tag $self (export "self") (result i32))
+  (tag $spawn (export "spawn") (param (ref $cont)) (result i32))
+  (tag $send (export "send") (param i32 i32))
+  (tag $recv (export "recv") (result i32))
+)
+(register "actor")
+
+;; a simple example - pass a message through a chain of actors
+(module $chain
+  (type $func (func))       ;; [] -> []
+  (type $cont (cont $func)) ;; cont ([] -> [])
+
+  (type $i-func (func (param i32))) ;; [i32] -> []
+  (type $i-cont (cont $i-func))     ;; cont ([i32] -> [])
+
+  ;; self : [i32] -> []
+  ;; spawn : [cont ([] -> [])] -> [i32]
+  ;; send : [i32 i32] -> []
+  ;; recv : [] -> [i32]
+  (tag $self (import "actor" "self") (result i32))
+  (tag $spawn (import "actor" "spawn") (param (ref $cont)) (result i32))
+  (tag $send (import "actor" "send") (param i32 i32))
+  (tag $recv (import "actor" "recv") (result i32))
+
+  (elem declare func $next)
+
+  (func $log (import "spectest" "print_i32") (param i32))
+
+  (func $next (param $p i32)
+    (local $s i32)
+    (local.set $s (suspend $recv))
+    (call $log (i32.const -1))
+    (suspend $send (local.get $s) (local.get $p))
+  )
+
+  ;; send the message 42 through a chain of n actors
+  (func $chain (export "chain") (param $n i32)
+    (local $p i32)
+    (local.set $p (suspend $self))
+
+    (loop $l
+      (if (i32.eqz (local.get $n))
+        (then (suspend $send (i32.const 42) (local.get $p)))
+        (else (local.set $p (suspend $spawn (cont.bind $i-cont $cont (local.get $p) (cont.new $i-cont (ref.func $next)))))
+              (local.set $n (i32.sub (local.get $n) (i32.const 1)))
+              (br $l))
+      )
+    )
+    (call $log (suspend $recv))
+  )
+)
+(register "chain")
+
+;; queues of threads and mailboxes
+(module $queue
+  (type $func (func))       ;; [] -> []
+  (type $cont (cont $func)) ;; cont ([] -> [])
+
+  (func $log (import "spectest" "print_i32") (param i32))
+
+  ;; table (threads) and memory (mailboxes) as simple queues
+  (table $queue 0 (ref null $cont))
+  (memory 1)
+
+  (tag $too-many-mailboxes)
+
+  (global $qdelta i32 (i32.const 10))
+
+  (global $qback-k (mut i32) (i32.const 0))
+  (global $qfront-k (mut i32) (i32.const 0))
+
+  (func $queue-empty-k (export "queue-empty") (result i32)
+    (i32.eq (global.get $qfront-k) (global.get $qback-k))
+  )
+
+  (func $dequeue-k (export "dequeue-k") (result (ref null $cont))
+    (local $i i32)
+    (if (call $queue-empty-k)
+      (then (return (ref.null $cont)))
+    )
+    (local.set $i (global.get $qfront-k))
+    (global.set $qfront-k (i32.add (local.get $i) (i32.const 1)))
+    (table.get $queue (local.get $i))
+  )
+
+  (func $enqueue-k (export "enqueue-k") (param $k (ref $cont))
+    ;; Check if queue is full
+    (if (i32.eq (global.get $qback-k) (table.size $queue))
+      (then
+        ;; Check if there is enough space in the front to compact
+        (if (i32.lt_u (global.get $qfront-k) (global.get $qdelta))
+          (then
+            ;; Space is below threshold, grow table instead
+            (drop (table.grow $queue (ref.null $cont) (global.get $qdelta)))
+          )
+          (else
+            ;; Enough space, move entries up to head of table
+            (global.set $qback-k (i32.sub (global.get $qback-k) (global.get $qfront-k)))
+            (table.copy $queue $queue
+              (i32.const 0)         ;; dest = new front = 0
+              (global.get $qfront-k)  ;; src = old front
+              (global.get $qback-k)   ;; len = new back = old back - old front
+            )
+            (table.fill $queue      ;; null out old entries to avoid leaks
+              (global.get $qback-k)   ;; start = new back
+              (ref.null $cont)      ;; init value
+              (global.get $qfront-k)  ;; len = old front = old front - new front
+            )
+            (global.set $qfront-k (i32.const 0))
+          )
+        )
+      )
+    )
+    (table.set $queue (global.get $qback-k) (local.get $k))
+    (global.set $qback-k (i32.add (global.get $qback-k) (i32.const 1)))
+  )
+
+  (global $qback-mb (mut i32) (i32.const 0))
+  (global $qfront-mb (mut i32) (i32.const 0))
+
+  (func $queue-empty-mb (export "queue-empty-mb") (result i32)
+    (i32.eq (global.get $qfront-mb) (global.get $qback-mb))
+  )
+
+  (func $dequeue-mb (export "dequeue-mb") (result i32)
+    (local $i i32)
+    (local $mb i32)
+    (if (call $queue-empty-mb)
+      (then (return (i32.const -1)))
+    )
+    (local.set $i (global.get $qfront-mb))
+    (global.set $qfront-mb (i32.add (local.get $i) (i32.const 1)))
+    (local.set $mb (i32.load (i32.mul (local.get $i) (i32.const 4))))
+    (return (local.get $mb))
+  )
+
+  (func $enqueue-mb (export "enqueue-mb") (param $mb i32)
+    ;; Check if queue is full
+    (if (i32.eq (global.get $qback-mb) (i32.const 16383))
+      (then
+        ;; Check if there is enough space in the front to compact
+        (if (i32.lt_u (global.get $qfront-mb) (global.get $qdelta))
+          (then
+            ;; Space is below threshold, throw exception
+            (throw $too-many-mailboxes)
+          )
+          (else
+            ;; Enough space, move entries up to head of table
+            (global.set $qback-mb (i32.sub (global.get $qback-mb) (global.get $qfront-mb)))
+            (memory.copy
+              (i32.const 0)                                    ;; dest = new front = 0
+              (i32.mul (global.get $qfront-mb) (i32.const 4))  ;; src = old front
+              (i32.mul (global.get $qback-mb) (i32.const 4))   ;; len = new back = old back - old front
+            )
+            (memory.fill                                       ;; null out old entries to avoid leaks
+              (i32.mul (global.get $qback-mb) (i32.const 4))   ;; start = new back
+              (i32.const -1)                                   ;; init value
+              (i32.mul (global.get $qfront-mb) (i32.const 4))  ;; len = old front = old front - new front
+            )
+            (global.set $qfront-mb (i32.const 0))
+          )
+        )
+      )
+    )
+    (i32.store (i32.mul (global.get $qback-mb) (i32.const 4)) (local.get $mb))
+    (global.set $qback-mb (i32.add (global.get $qback-mb) (i32.const 1)))
+  )
+)
+(register "queue")
+
+(module $mailboxes
+  ;; Stupid implementation of mailboxes that raises an exception if
+  ;; there are too many mailboxes or if more than one message is sent
+  ;; to any given mailbox.
+  ;;
+  ;; Sufficient for the simple chain example.
+
+  ;; -1 means empty
+
+  (func $log (import "spectest" "print_i32") (param i32))
+
+  (tag $too-many-mailboxes)
+  (tag $too-many-messages)
+
+  (memory 1)
+
+  (global $msize (mut i32) (i32.const 0)) ;; current number of mailboxes
+  (global $mmax i32 (i32.const 1024))     ;; maximum number of mailboxes
+
+  (func $init (export "init")
+     (global.set $msize (i32.const 0))
+     (memory.fill (i32.const 0) (i32.const -1) (i32.mul (global.get $mmax) (i32.const 4)))
+  )
+
+  (func $empty-mb (export "empty-mb") (param $mb i32) (result i32)
+    (local $offset i32)
+    (local.set $offset (i32.mul (local.get $mb) (i32.const 4)))
+    (i32.eq (i32.load (local.get $offset)) (i32.const -1))
+  )
+
+  (func $new-mb (export "new-mb") (result i32)
+     (local $mb i32)
+
+     (if (i32.ge_u (global.get $msize) (global.get $mmax))
+         (then (throw $too-many-mailboxes))
+     )
+
+     (local.set $mb (global.get $msize))
+     (global.set $msize (i32.add (global.get $msize) (i32.const 1)))
+     (return (local.get $mb))
+  )
+
+  (func $send-to-mb (export "send-to-mb") (param $v i32) (param $mb i32)
+    (local $offset i32)
+    (local.set $offset (i32.mul (local.get $mb) (i32.const 4)))
+    (if (call $empty-mb (local.get $mb))
+      (then (i32.store (local.get $offset) (local.get $v)))
+      (else (throw $too-many-messages))
+    )
+  )
+
+  (func $recv-from-mb (export "recv-from-mb") (param $mb i32) (result i32)
+    (local $v i32)
+    (local $offset i32)
+    (local.set $offset (i32.mul (local.get $mb) (i32.const 4)))
+    (local.set $v (i32.load (local.get $offset)))
+    (i32.store (local.get $offset) (i32.const -1))
+    (local.get $v)
+  )
+)
+(register "mailboxes")
+
+
+;; a simple example - pass a message through a chain of actors
+(module $chain
+  (type $func (func))
+  (type $cont (cont $func))
+
+  (type $i-func (func (param i32)))
+  (type $i-cont (cont $i-func))
+
+  (tag $self (import "actor" "self") (result i32))
+  (tag $spawn (import "actor" "spawn") (param (ref $cont)) (result i32))
+  (tag $send (import "actor" "send") (param i32 i32))
+  (tag $recv (import "actor" "recv") (result i32))
+
+  (elem declare func $next)
+
+  (func $log (import "spectest" "print_i32") (param i32))
+
+  (func $next (param $p i32)
+    (local $s i32)
+    (local.set $s (suspend $recv))
+    (call $log (i32.const -1))
+    (suspend $send (local.get $s) (local.get $p))
+  )
+
+  ;; send the message 42 through a chain of n actors
+  (func $chain (export "chain") (param $n i32)
+    (local $p i32)
+    (local.set $p (suspend $self))
+
+    (loop $l
+      (if (i32.eqz (local.get $n))
+        (then (suspend $send (i32.const 42) (local.get $p)))
+        (else (local.set $p (suspend $spawn (cont.bind $i-cont $cont (local.get $p) (cont.new $i-cont (ref.func $next)))))
+              (local.set $n (i32.sub (local.get $n) (i32.const 1)))
+              (br $l))
+      )
+    )
+    (call $log (suspend $recv))
+  )
+)
+(register "chain")
+
+;; interface to lightweight threads
+(module $lwt
+  (type $func (func))
+  (type $cont (cont $func))
+
+  (tag $yield (export "yield"))
+  (tag $fork (export "fork") (param (ref $cont)))
+)
+(register "lwt")
+
+;; queue of threads
+(module $queue
+  (type $func (func))
+  (type $cont (cont $func))
+
+  ;; Table as simple queue (keeping it simple, no ring buffer)
+  (table $queue 0 (ref null $cont))
+  (global $qdelta i32 (i32.const 10))
+  (global $qback (mut i32) (i32.const 0))
+  (global $qfront (mut i32) (i32.const 0))
+
+  (func $queue-empty (export "queue-empty") (result i32)
+    (i32.eq (global.get $qfront) (global.get $qback))
+  )
+
+  (func $dequeue (export "dequeue") (result (ref null $cont))
+    (local $i i32)
+    (if (call $queue-empty)
+      (then (return (ref.null $cont)))
+    )
+    (local.set $i (global.get $qfront))
+    (global.set $qfront (i32.add (local.get $i) (i32.const 1)))
+    (table.get $queue (local.get $i))
+  )
+
+  (func $enqueue (export "enqueue") (param $k (ref $cont))
+    ;; Check if queue is full
+    (if (i32.eq (global.get $qback) (table.size $queue))
+      (then
+        ;; Check if there is enough space in the front to compact
+        (if (i32.lt_u (global.get $qfront) (global.get $qdelta))
+          (then
+            ;; Space is below threshold, grow table instead
+            (drop (table.grow $queue (ref.null $cont) (global.get $qdelta)))
+          )
+          (else
+            ;; Enough space, move entries up to head of table
+            (global.set $qback (i32.sub (global.get $qback) (global.get $qfront)))
+            (table.copy $queue $queue
+              (i32.const 0)         ;; dest = new front = 0
+              (global.get $qfront)  ;; src = old front
+              (global.get $qback)   ;; len = new back = old back - old front
+            )
+            (table.fill $queue      ;; null out old entries to avoid leaks
+              (global.get $qback)   ;; start = new back
+              (ref.null $cont)      ;; init value
+              (global.get $qfront)  ;; len = old front = old front - new front
+            )
+            (global.set $qfront (i32.const 0))
+          )
+        )
+      )
+    )
+    (table.set $queue (global.get $qback) (local.get $k))
+    (global.set $qback (i32.add (global.get $qback) (i32.const 1)))
+  )
+)
+(register "queue")
+
+;; simple scheduler for lightweight threads
+(module $scheduler
+  (type $func (func))
+  (type $cont (cont $func))
+
+  (tag $yield (import "lwt" "yield"))
+  (tag $fork (import "lwt" "fork") (param (ref $cont)))
+
+  (func $queue-empty (import "queue" "queue-empty") (result i32))
+  (func $dequeue (import "queue" "dequeue") (result (ref null $cont)))
+  (func $enqueue (import "queue" "enqueue") (param $k (ref $cont)))
+
+  (func $run (export "run") (param $main (ref $cont))
+    (call $enqueue (local.get $main))
+    (loop $l
+      (if (call $queue-empty) (then (return)))
+      (block $on_yield (result (ref $cont))
+        (block $on_fork (result (ref $cont) (ref $cont))
+          (resume $cont (tag $yield $on_yield) (tag $fork $on_fork)
+            (call $dequeue)
+          )
+          (br $l)  ;; thread terminated
+        ) ;;   $on_fork (result (ref $cont) (ref $cont))
+        (call $enqueue)  ;; current thread
+        (call $enqueue)  ;; new thread
+        (br $l)
+      )
+      ;;     $on_yield (result (ref $cont))
+      (call $enqueue) ;; current thread
+      (br $l)
+    )
+  )
+)
+(register "scheduler")
+
+(module $mailboxes
+  ;; Stupid implementation of mailboxes that raises an exception if
+  ;; there are too many mailboxes or if more than one message is sent
+  ;; to any given mailbox.
+  ;;
+  ;; Sufficient for the simple chain example.
+
+  ;; -1 means empty
+
+  (tag $too-many-mailboxes)
+  (tag $too-many-messages)
+
+  (memory 1)
+
+  (global $msize (mut i32) (i32.const 0))
+  (global $mmax i32 (i32.const 1024)) ;; maximum number of mailboxes
+
+  (func $init (export "init")
+     (memory.fill (i32.const 0) (i32.const -1) (i32.mul (global.get $mmax) (i32.const 4)))
+  )
+
+  (func $empty-mb (export "empty-mb") (param $mb i32) (result i32)
+    (local $offset i32)
+    (local.set $offset (i32.mul (local.get $mb) (i32.const 4)))
+    (i32.eq (i32.load (local.get $offset)) (i32.const -1))
+  )
+
+  (func $new-mb (export "new-mb") (result i32)
+     (local $mb i32)
+
+     (if (i32.ge_u (global.get $msize) (global.get $mmax))
+         (then (throw $too-many-mailboxes))
+     )
+
+     (local.set $mb (global.get $msize))
+     (global.set $msize (i32.add (global.get $msize) (i32.const 1)))
+     (return (local.get $mb))
+  )
+
+  (func $send-to-mb (export "send-to-mb") (param $v i32) (param $mb i32)
+    (local $offset i32)
+    (local.set $offset (i32.mul (local.get $mb) (i32.const 4)))
+    (if (call $empty-mb (local.get $mb))
+      (then (i32.store (local.get $offset) (local.get $v)))
+      (else (throw $too-many-messages))
+    )
+  )
+
+  (func $recv-from-mb (export "recv-from-mb") (param $mb i32) (result i32)
+    (local $v i32)
+    (local $offset i32)
+    (local.set $offset (i32.mul (local.get $mb) (i32.const 4)))
+    (local.set $v (i32.load (local.get $offset)))
+    (i32.store (local.get $offset) (i32.const -1))
+    (local.get $v)
+  )
+)
+(register "mailboxes")
+
+;; actors implemented via lightweight threads
+(module $actor-as-lwt
+  (type $func (func))       ;; [] -> []
+  (type $cont (cont $func)) ;; cont ([] -> [])
+
+  (type $i-func (func (param i32))) ;; [i32] -> []
+  (type $i-cont (cont $i-func))     ;; cont ([i32] -> [])
+
+  (type $ic-func (func (param i32 (ref $cont)))) ;; [i32 (cont ([] -> []))] -> []
+  (type $ic-cont (cont $ic-func))                ;; cont ([i32 (cont ([] -> []))] -> [])
+
+  (func $log (import "spectest" "print_i32") (param i32))
+
+  ;; lwt interface
+  (tag $yield (import "lwt" "yield"))
+  (tag $fork (import "lwt" "fork") (param (ref $cont)))
+
+  ;; mailbox interface
+  (func $init (import "mailboxes" "init"))
+  (func $empty-mb (import "mailboxes" "empty-mb") (param $mb i32) (result i32))
+  (func $new-mb (import "mailboxes" "new-mb") (result i32))
+  (func $send-to-mb (import "mailboxes" "send-to-mb") (param $v i32) (param $mb i32))
+  (func $recv-from-mb (import "mailboxes" "recv-from-mb") (param $mb i32) (result i32))
+
+  ;; queue interface
+  (func $queue-empty (import "queue" "queue-empty") (result i32))
+  (func $dequeue (import "queue" "dequeue") (result (ref null $cont)))
+  (func $enqueue (import "queue" "enqueue") (param $k (ref $cont)))
+
+  ;; actor interface
+  ;; self : [i32] -> []
+  ;; spawn : [cont ([] -> [])] -> [i32]
+  ;; send : [i32 i32] -> []
+  ;; recv : [] -> [i32]
+  (tag $self (import "actor" "self") (result i32))
+  (tag $spawn (import "actor" "spawn") (param (ref $cont)) (result i32))
+  (tag $send (import "actor" "send") (param i32 i32))
+  (tag $recv (import "actor" "recv") (result i32))
+
+  (elem declare func $actk)
+
+  (func $actk (param $mine i32) (param $nextk (ref $cont))
+    (local $ik (ref $i-cont))
+    (local $k (ref $cont))
+    (local $you (ref $cont))
+    (local $yours i32)
+    (loop $l
+      (block $on_self (result (ref $i-cont))
+        (block $on_spawn (result (ref $cont) (ref $i-cont))
+          (block $on_send (result i32 i32 (ref $cont))
+            (block $on_recv (result (ref $i-cont))
+               (resume $cont (tag $self $on_self)
+                             (tag $spawn $on_spawn)
+                             (tag $send $on_send)
+                             (tag $recv $on_recv)
+                             (local.get $nextk)
+               )
+               (return)
+            ) ;;   $on_recv (result (ref $i-cont))
+            (local.set $ik)
+            ;; block this thread until the mailbox is non-empty
+            (loop $blocked
+              (if (call $empty-mb (local.get $mine))
+                  (then (suspend $yield)
+                        (br $blocked))
+              )
+            )
+            (local.set $nextk (cont.bind $i-cont $cont (call $recv-from-mb (local.get $mine)) (local.get $ik)))
+            (br $l)
+          ) ;;   $on_send (result i32 i32 (ref $cont))
+          (local.set $k)
+          (call $send-to-mb)
+          (local.set $nextk (local.get $k))
+          (br $l)
+        ) ;;   $on_spawn (result (ref $cont) (ref $i-cont))
+        (local.set $ik)
+        (local.set $you)
+        (call $new-mb)
+        (local.set $yours)
+        (suspend $fork (cont.bind $ic-cont $cont
+                                  (local.get $yours)
+                                  (local.get $you)
+                                  (cont.new $ic-cont (ref.func $actk))))
+        (local.set $nextk (cont.bind $i-cont $cont (local.get $yours) (local.get $ik)))
+        (br $l)
+      ) ;;   $on_self (result (ref $i-cont))
+      (local.set $ik)
+      (local.set $nextk (cont.bind $i-cont $cont (local.get $mine) (local.get $ik)))
+      (br $l)
+    )
+  )
+
+  (func $act (export "act") (param $k (ref $cont))
+    (call $init)
+    (call $actk (call $new-mb) (local.get $k))
+  )
+)
+(register "actor-as-lwt")
+
+;; composing the actor and scheduler handlers together
+(module $actor-scheduler
+  (type $func (func))       ;; [] -> []
+  (type $cont (cont $func)) ;; cont ([] -> [])
+
+  (type $cont-func (func (param (ref $cont)))) ;; [cont ([] -> []) -> []]
+  (type $cont-cont (cont $cont-func))          ;; cont ([cont ([] -> []) -> []])
+
+  (elem declare func $act $scheduler)
+
+  (func $act (import "actor-as-lwt" "act") (param $k (ref $cont)))
+  (func $scheduler (import "scheduler" "run") (param $k (ref $cont)))
+
+  (func $run-actor (export "run-actor") (param $k (ref $cont))
+    (call $scheduler (cont.bind $cont-cont $cont (local.get $k) (cont.new $cont-cont (ref.func $act))))
+  )
+)
+(register "actor-scheduler")
+
+(module
+  (type $func (func))       ;; [] -> []
+  (type $cont (cont $func)) ;; cont ([] -> [])
+
+  (type $i-func (func (param i32))) ;; [i32] -> []
+  (type $i-cont (cont $i-func))     ;; cont ([i32] -> [])
+
+  (elem declare func $chain)
+
+  (func $run-actor (import "actor-scheduler" "run-actor") (param $k (ref $cont)))
+  (func $chain (import "chain" "chain") (param $n i32))
+
+  (func $run-chain (export "run-chain") (param $n i32)
+    (call $run-actor (cont.bind $i-cont $cont (local.get $n) (cont.new $i-cont (ref.func $chain))))
+  )
+)
+
+(invoke "run-chain" (i32.const 64))
diff --git a/proposals/continuations/examples/actor.wast b/proposals/continuations/examples/actor.wast
new file mode 100644
index 00000000..151c08d5
--- /dev/null
+++ b/proposals/continuations/examples/actor.wast
@@ -0,0 +1,395 @@
+;; Actors
+
+;; actor interface
+(module $actor
+  (type $func (func))       ;; [] -> []
+  (type $cont (cont $func)) ;; cont ([] -> [])
+
+  ;; self : [i32] -> []
+  ;; spawn : [cont ([] -> [])] -> [i32]
+  ;; send : [i32 i32] -> []
+  ;; recv : [] -> [i32]
+  (tag $self (export "self") (result i32))
+  (tag $spawn (export "spawn") (param (ref $cont)) (result i32))
+  (tag $send (export "send") (param i32 i32))
+  (tag $recv (export "recv") (result i32))
+)
+(register "actor")
+
+;; a simple example - pass a message through a chain of actors
+(module $chain
+  (type $func (func))       ;; [] -> []
+  (type $cont (cont $func)) ;; cont ([] -> [])
+
+  (type $i-func (func (param i32))) ;; [i32] -> []
+  (type $i-cont (cont $i-func))     ;; cont ([i32] -> [])
+
+  ;; self : [i32] -> []
+  ;; spawn : [cont ([] -> [])] -> [i32]
+  ;; send : [i32 i32] -> []
+  ;; recv : [] -> [i32]
+  (tag $self (import "actor" "self") (result i32))
+  (tag $spawn (import "actor" "spawn") (param (ref $cont)) (result i32))
+  (tag $send (import "actor" "send") (param i32 i32))
+  (tag $recv (import "actor" "recv") (result i32))
+
+  (elem declare func $next)
+
+  (func $log (import "spectest" "print_i32") (param i32))
+
+  (func $next (param $p i32)
+    (local $s i32)
+    (local.set $s (suspend $recv))
+    (call $log (i32.const -1))
+    (suspend $send (local.get $s) (local.get $p))
+  )
+
+  ;; send the message 42 through a chain of n actors
+  (func $chain (export "chain") (param $n i32)
+    (local $p i32)
+    (local.set $p (suspend $self))
+
+    (loop $l
+      (if (i32.eqz (local.get $n))
+        (then (suspend $send (i32.const 42) (local.get $p)))
+        (else (local.set $p (suspend $spawn (cont.bind $i-cont $cont (local.get $p) (cont.new $i-cont (ref.func $next)))))
+              (local.set $n (i32.sub (local.get $n) (i32.const 1)))
+              (br $l))
+      )
+    )
+    (call $log (suspend $recv))
+  )
+)
+(register "chain")
+
+;; queues of threads and mailboxes
+(module $queue
+  (type $func (func))       ;; [] -> []
+  (type $cont (cont $func)) ;; cont ([] -> [])
+
+  (func $log (import "spectest" "print_i32") (param i32))
+
+  ;; table (threads) and memory (mailboxes) as simple queues
+  (table $queue 0 (ref null $cont))
+  (memory 1)
+
+  (tag $too-many-mailboxes)
+
+  (global $qdelta i32 (i32.const 10))
+
+  (global $qback-k (mut i32) (i32.const 0))
+  (global $qfront-k (mut i32) (i32.const 0))
+
+  (func $queue-empty-k (export "queue-empty") (result i32)
+    (i32.eq (global.get $qfront-k) (global.get $qback-k))
+  )
+
+  (func $dequeue-k (export "dequeue-k") (result (ref null $cont))
+    (local $i i32)
+    (if (call $queue-empty-k)
+      (then (return (ref.null $cont)))
+    )
+    (local.set $i (global.get $qfront-k))
+    (global.set $qfront-k (i32.add (local.get $i) (i32.const 1)))
+    (table.get $queue (local.get $i))
+  )
+
+  (func $enqueue-k (export "enqueue-k") (param $k (ref $cont))
+    ;; Check if queue is full
+    (if (i32.eq (global.get $qback-k) (table.size $queue))
+      (then
+        ;; Check if there is enough space in the front to compact
+        (if (i32.lt_u (global.get $qfront-k) (global.get $qdelta))
+          (then
+            ;; Space is below threshold, grow table instead
+            (drop (table.grow $queue (ref.null $cont) (global.get $qdelta)))
+          )
+          (else
+            ;; Enough space, move entries up to head of table
+            (global.set $qback-k (i32.sub (global.get $qback-k) (global.get $qfront-k)))
+            (table.copy $queue $queue
+              (i32.const 0)         ;; dest = new front = 0
+              (global.get $qfront-k)  ;; src = old front
+              (global.get $qback-k)   ;; len = new back = old back - old front
+            )
+            (table.fill $queue      ;; null out old entries to avoid leaks
+              (global.get $qback-k)   ;; start = new back
+              (ref.null $cont)      ;; init value
+              (global.get $qfront-k)  ;; len = old front = old front - new front
+            )
+            (global.set $qfront-k (i32.const 0))
+          )
+        )
+      )
+    )
+    (table.set $queue (global.get $qback-k) (local.get $k))
+    (global.set $qback-k (i32.add (global.get $qback-k) (i32.const 1)))
+  )
+
+  (global $qback-mb (mut i32) (i32.const 0))
+  (global $qfront-mb (mut i32) (i32.const 0))
+
+  (func $queue-empty-mb (export "queue-empty-mb") (result i32)
+    (i32.eq (global.get $qfront-mb) (global.get $qback-mb))
+  )
+
+  (func $dequeue-mb (export "dequeue-mb") (result i32)
+    (local $i i32)
+    (local $mb i32)
+    (if (call $queue-empty-mb)
+      (then (return (i32.const -1)))
+    )
+    (local.set $i (global.get $qfront-mb))
+    (global.set $qfront-mb (i32.add (local.get $i) (i32.const 1)))
+    (local.set $mb (i32.load (i32.mul (local.get $i) (i32.const 4))))
+    (return (local.get $mb))
+  )
+
+  (func $enqueue-mb (export "enqueue-mb") (param $mb i32)
+    ;; Check if queue is full
+    (if (i32.eq (global.get $qback-mb) (i32.const 16383))
+      (then
+        ;; Check if there is enough space in the front to compact
+        (if (i32.lt_u (global.get $qfront-mb) (global.get $qdelta))
+          (then
+            ;; Space is below threshold, throw exception
+            (throw $too-many-mailboxes)
+          )
+          (else
+            ;; Enough space, move entries up to head of table
+            (global.set $qback-mb (i32.sub (global.get $qback-mb) (global.get $qfront-mb)))
+            (memory.copy
+              (i32.const 0)                                    ;; dest = new front = 0
+              (i32.mul (global.get $qfront-mb) (i32.const 4))  ;; src = old front
+              (i32.mul (global.get $qback-mb) (i32.const 4))   ;; len = new back = old back - old front
+            )
+            (memory.fill                                       ;; null out old entries to avoid leaks
+              (i32.mul (global.get $qback-mb) (i32.const 4))   ;; start = new back
+              (i32.const -1)                                   ;; init value
+              (i32.mul (global.get $qfront-mb) (i32.const 4))  ;; len = old front = old front - new front
+            )
+            (global.set $qfront-mb (i32.const 0))
+          )
+        )
+      )
+    )
+    (i32.store (i32.mul (global.get $qback-mb) (i32.const 4)) (local.get $mb))
+    (global.set $qback-mb (i32.add (global.get $qback-mb) (i32.const 1)))
+  )
+)
+(register "queue")
+
+(module $mailboxes
+  ;; Stupid implementation of mailboxes that raises an exception if
+  ;; there are too many mailboxes or if more than one message is sent
+  ;; to any given mailbox.
+  ;;
+  ;; Sufficient for the simple chain example.
+
+  ;; -1 means empty
+
+  (func $log (import "spectest" "print_i32") (param i32))
+
+  (tag $too-many-mailboxes)
+  (tag $too-many-messages)
+
+  (memory 1)
+
+  (global $msize (mut i32) (i32.const 0)) ;; current number of mailboxes
+  (global $mmax i32 (i32.const 1024))     ;; maximum number of mailboxes
+
+  (func $init (export "init")
+     (global.set $msize (i32.const 0))
+     (memory.fill (i32.const 0) (i32.const -1) (i32.mul (global.get $mmax) (i32.const 4)))
+  )
+
+  (func $empty-mb (export "empty-mb") (param $mb i32) (result i32)
+    (local $offset i32)
+    (local.set $offset (i32.mul (local.get $mb) (i32.const 4)))
+    (i32.eq (i32.load (local.get $offset)) (i32.const -1))
+  )
+
+  (func $new-mb (export "new-mb") (result i32)
+     (local $mb i32)
+
+     (if (i32.ge_u (global.get $msize) (global.get $mmax))
+         (then (throw $too-many-mailboxes))
+     )
+
+     (local.set $mb (global.get $msize))
+     (global.set $msize (i32.add (global.get $msize) (i32.const 1)))
+     (return (local.get $mb))
+  )
+
+  (func $send-to-mb (export "send-to-mb") (param $v i32) (param $mb i32)
+    (local $offset i32)
+    (local.set $offset (i32.mul (local.get $mb) (i32.const 4)))
+    (if (call $empty-mb (local.get $mb))
+      (then (i32.store (local.get $offset) (local.get $v)))
+      (else (throw $too-many-messages))
+    )
+  )
+
+  (func $recv-from-mb (export "recv-from-mb") (param $mb i32) (result i32)
+    (local $v i32)
+    (local $offset i32)
+    (local.set $offset (i32.mul (local.get $mb) (i32.const 4)))
+    (local.set $v (i32.load (local.get $offset)))
+    (i32.store (local.get $offset) (i32.const -1))
+    (local.get $v)
+  )
+)
+(register "mailboxes")
+
+;; actors implemented directly
+(module $scheduler
+  (type $func (func))       ;; [] -> []
+  (type $cont (cont $func)) ;; cont ([] -> [])
+
+  (func $log (import "spectest" "print_i32") (param i32))
+
+  (type $i-func (func (param i32))) ;; [i32] -> []
+  (type $i-cont (cont $i-func))     ;; cont ([i32] -> [])
+
+  (type $i-cont-func (func (param (ref $i-cont)))) ;; [(cont ([i32] -> []))] -> []
+  (type $i-cont-cont (cont $i-cont-func))          ;; cont ([(cont ([i32] -> []))] -> [])
+
+  ;; mailbox interface
+  (func $init (import "mailboxes" "init"))
+  (func $empty-mb (import "mailboxes" "empty-mb") (param $mb i32) (result i32))
+  (func $new-mb (import "mailboxes" "new-mb") (result i32))
+  (func $send-to-mb (import "mailboxes" "send-to-mb") (param $v i32) (param $mb i32))
+  (func $recv-from-mb (import "mailboxes" "recv-from-mb") (param $mb i32) (result i32))
+
+  ;; queue interface
+  (func $dequeue-mb (import "queue" "dequeue-mb") (result i32))
+  (func $enqueue-mb (import "queue" "enqueue-mb") (param i32))
+  (func $dequeue-k (import "queue" "dequeue-k") (result (ref null $cont)))
+  (func $enqueue-k (import "queue" "enqueue-k") (param (ref $cont)))
+
+  ;; actor interface
+  ;; self : [i32] -> []
+  ;; spawn : [cont ([] -> [])] -> [i32]
+  ;; send : [i32 i32] -> []
+  ;; recv : [] -> [i32]
+  (tag $self (import "actor" "self") (result i32))
+  (tag $spawn (import "actor" "spawn") (param (ref $cont)) (result i32))
+  (tag $send (import "actor" "send") (param i32 i32))
+  (tag $recv (import "actor" "recv") (result i32))
+
+  (elem declare func $recv-againf)
+
+  ;; We implement blocking by reinvoking recv with the original
+  ;; handler. This is a common pattern nicely supported by shallow but
+  ;; not deep handlers. However, it does require composing the new
+  ;; reinvoked recv with the continuation. We simulate this behaviour
+  ;; (inefficiently, perhaps) by resuming the continuation with an
+  ;; identity handler and then building a new continuation. Might an
+  ;; instruction for composing or extending continuations be palatable
+  ;; / desirable?
+  ;;
+  ;; The resume_throw operation can be implemented (inefficiently)
+  ;; with continuation composition.
+
+  ;; compose recv with an existing continuation
+  (func $recv-againf (param $ik (ref $i-cont))
+    (local $res i32)
+    (suspend $recv)
+    (local.set $res)
+    (resume $i-cont (local.get $res) (local.get $ik))
+  )
+  (func $recv-again (param $ik (ref $i-cont)) (result (ref $cont))
+    (cont.bind $i-cont-cont $cont (local.get $ik) (cont.new $i-cont-cont (ref.func $recv-againf)))
+  )
+
+  ;; There are multiple ways of avoiding the need for
+  ;; $recv-again. Here are a couple.
+  ;;
+  ;; 1) Build handlers on top of lightweight threads (with fork and
+  ;; yield). Then we can just keep on yielding until the mailbox is
+  ;; non-empty, and delegate the actual scheduling to a separate
+  ;; handler.
+  ;;
+  ;; 2) Distinguish between unblocked and blocked threads in the
+  ;; thread queue. Typing makes this a bit of a pain to hack up
+  ;; directly in Wasm, but in practice this is not difficult, and
+  ;; similar to what existing actor implementations do.
+
+  (func $run (export "run") (param $nextk (ref null $cont))
+    (local $mine i32)                ;; current mailbox
+    (local $ik (ref $i-cont))
+    (local $k (ref $cont))
+    (local $you (ref $cont))
+    (local $yours i32)
+    (call $init)
+    (local.set $mine (call $new-mb))
+    (loop $l
+      (if (ref.is_null (local.get $nextk)) (then (return)))
+      (block $on_self (result (ref $i-cont))
+        (block $on_spawn (result (ref $cont) (ref $i-cont))
+          (block $on_send (result i32 i32 (ref $cont))
+            (block $on_recv (result (ref $i-cont))
+               (resume $cont (tag $self $on_self)
+                             (tag $spawn $on_spawn)
+                             (tag $send $on_send)
+                             (tag $recv $on_recv)
+                             (local.get $nextk)
+               )
+               (local.set $mine (call $dequeue-mb))
+               (local.set $nextk (call $dequeue-k))
+               (br $l)
+            ) ;;   $on_recv (result (ref $i-cont))
+            (local.set $ik)
+            ;; block this thread until the mailbox is non-empty
+            (if (call $empty-mb (local.get $mine))
+                (then (call $enqueue-mb (local.get $mine))
+                      (call $enqueue-k (call $recv-again (local.get $ik)))
+                      (local.set $mine (call $dequeue-mb))
+                      (local.set $nextk (call $dequeue-k))
+                      (br $l))
+            )
+            (local.set $nextk (cont.bind $i-cont $cont (call $recv-from-mb (local.get $mine)) (local.get $ik)))
+            (br $l)
+          ) ;;   $on_send (result i32 i32 (ref $cont))
+          (local.set $k)
+          (call $send-to-mb)
+          (local.set $nextk (local.get $k))
+          (br $l)
+        ) ;;   $on_spawn (result (ref $cont) (ref $i-cont))
+        (local.set $ik)
+        (local.set $you)
+        (call $new-mb)
+        (local.set $yours)
+        (call $enqueue-mb (local.get $yours))
+        (call $enqueue-k (local.get $you))
+        (local.set $nextk (cont.bind $i-cont $cont (local.get $yours) (local.get $ik)))
+        (br $l)
+      ) ;;   $on_self (result (ref $i-cont))
+      (local.set $ik)
+      (local.set $nextk (cont.bind $i-cont $cont (local.get $mine) (local.get $ik)))
+      (br $l)
+    )
+  )
+)
+(register "scheduler")
+
+(module
+  (type $func (func))       ;; [] -> []
+  (type $cont (cont $func)) ;; cont ([] -> [])
+
+  (type $i-func (func (param i32))) ;; [i32] -> []
+  (type $i-cont (cont $i-func))     ;; cont ([i32] -> [])
+
+  (func $log (import "spectest" "print_i32") (param i32))
+
+  (elem declare func $chain)
+
+  (func $act (import "scheduler" "run") (param $k (ref null $cont)))
+  (func $chain (import "chain" "chain") (param $n i32))
+
+  (func $run-chain (export "run-chain") (param $n i32)
+    (call $act (cont.bind $i-cont $cont (local.get $n) (cont.new $i-cont (ref.func $chain))))
+  )
+)
+
+(assert_return (invoke "run-chain" (i32.const 64)))
diff --git a/proposals/continuations/examples/async-await.wast b/proposals/continuations/examples/async-await.wast
new file mode 100644
index 00000000..53570c3b
--- /dev/null
+++ b/proposals/continuations/examples/async-await.wast
@@ -0,0 +1,335 @@
+;; async-await interface
+(module $async-await
+  (type $i-func (func (param i32)))
+  (type $i-cont (cont $i-func))
+
+  ;; We use yield and fulfill to simulate asynchronous operations.
+  ;;
+  ;; Given a suitable asynchronous I/O API, they needn't be exposed to
+  ;; user code.
+  ;;
+  ;; yield : [] -> []
+  ;; fulfill : [i32] -> [i32]
+  (tag $yield (export "yield"))
+  (tag $fulfill (export "fulfill") (param i32) (param i32))
+
+  ;; async : [cont ([i32] -> [])] -> [i32]
+  ;; await : [i32] -> [i32]
+  (tag $async (export "async") (param (ref $i-cont)) (result i32))
+  (tag $await (export "await") (param i32) (result i32))
+)
+(register "async-await")
+
+(module $example
+  (type $i-func (func (param i32)))
+  (type $i-cont (cont $i-func))
+
+  (type $iii-fun (func (param i32 i32 i32)))
+  (type $iii-cont (cont $iii-fun))
+
+  ;; yield : [] -> []
+  ;; fulfill : [i32] -> [i32]
+  ;; async : [cont ([i32] -> [])] -> [i32]
+  ;; await : [i32] -> [i32]
+  (tag $yield (import "async-await" "yield"))
+  (tag $fulfill (import "async-await" "fulfill") (param i32) (param i32))
+  (tag $async (import "async-await" "async") (param (ref $i-cont)) (result i32))
+  (tag $await (import "async-await" "await") (param i32) (result i32))
+
+  (func $log (import "spectest" "print_i32") (param i32))
+
+  (elem declare func $sum)
+
+  ;; an asynchronous function that computes i + i+1 + ... + j
+  ;;
+  ;; (instead of computing synchronously, it allows other computations
+  ;; to execute each time round the loop)
+  ;;
+  ;; the final result is written to the promise $p
+  (func $sum (param $i i32) (param $j i32) (param $p i32)
+     (local $a i32)
+     (loop $l
+        (call $log (local.get $i))
+        (local.set $a (i32.add (local.get $a) (local.get $i)))
+        (local.set $i (i32.add (local.get $i) (i32.const 1)))
+        (if (i32.le_u (local.get $i) (local.get $j))
+           (then (suspend $yield)
+                 (br $l))
+        )
+     )
+     (suspend $fulfill (local.get $p) (local.get $a))
+  )
+
+  ;; compute p = 1+..+3; q = 5+..+7; r = 10+...+15 asynchronously
+  ;; once p and q have finished computing, compute x = p*q
+  ;; once r has finished computing, return x+r
+  (func $run (export "run")
+     (local $p i32)
+     (local $q i32)
+     (local $r i32)
+
+     (local $x i32)
+     (local $y i32)
+
+     (call $log (i32.const -1))
+     (local.set $p (suspend $async (cont.bind $iii-cont $i-cont (i32.const 1) (i32.const 3) (cont.new $iii-cont (ref.func $sum)))))
+     (call $log (i32.const -2))
+     (local.set $q (suspend $async (cont.bind $iii-cont $i-cont (i32.const 5) (i32.const 7) (cont.new $iii-cont (ref.func $sum)))))
+     (call $log (i32.const -3))
+     (local.set $r (suspend $async (cont.bind $iii-cont $i-cont (i32.const 10) (i32.const 15) (cont.new $iii-cont (ref.func $sum)))))
+     (call $log (i32.const -4))
+
+     (local.set $x (i32.mul (suspend $await (local.get $p))
+                            (suspend $await (local.get $q))))
+
+     (call $log (i32.const -5))
+
+     (local.set $y (i32.add (suspend $await (local.get $r)) (local.get $x)))
+
+     (call $log (i32.const -6))
+     (call $log (local.get $y))
+     (call $log (i32.const -7))
+  )
+)
+(register "example")
+
+;; queue of threads
+(module $queue
+  (type $func (func))
+  (type $cont (cont $func))
+
+  ;; Table as simple queue (keeping it simple, no ring buffer)
+  (table $queue 0 (ref null $cont))
+  (global $qdelta i32 (i32.const 10))
+  (global $qback (mut i32) (i32.const 0))
+  (global $qfront (mut i32) (i32.const 0))
+
+  (func $queue-empty (export "queue-empty") (result i32)
+    (i32.eq (global.get $qfront) (global.get $qback))
+  )
+
+  (func $dequeue (export "dequeue") (result (ref null $cont))
+    (local $i i32)
+    (if (call $queue-empty)
+      (then (return (ref.null $cont)))
+    )
+    (local.set $i (global.get $qfront))
+    (global.set $qfront (i32.add (local.get $i) (i32.const 1)))
+    (table.get $queue (local.get $i))
+  )
+
+  (func $enqueue (export "enqueue") (param $k (ref null $cont))
+    ;; Check if queue is full
+    (if (i32.eq (global.get $qback) (table.size $queue))
+      (then
+        ;; Check if there is enough space in the front to compact
+        (if (i32.lt_u (global.get $qfront) (global.get $qdelta))
+          (then
+            ;; Space is below threshold, grow table instead
+            (drop (table.grow $queue (ref.null $cont) (global.get $qdelta)))
+          )
+          (else
+            ;; Enough space, move entries up to head of table
+            (global.set $qback (i32.sub (global.get $qback) (global.get $qfront)))
+            (table.copy $queue $queue
+              (i32.const 0)         ;; dest = new front = 0
+              (global.get $qfront)  ;; src = old front
+              (global.get $qback)   ;; len = new back = old back - old front
+            )
+            (table.fill $queue      ;; null out old entries to avoid leaks
+              (global.get $qback)   ;; start = new back
+              (ref.null $cont)      ;; init value
+              (global.get $qfront)  ;; len = old front = old front - new front
+            )
+            (global.set $qfront (i32.const 0))
+          )
+        )
+      )
+    )
+    (table.set $queue (global.get $qback) (local.get $k))
+    (global.set $qback (i32.add (global.get $qback) (i32.const 1)))
+  )
+)
+(register "queue")
+
+;; promises
+(module $promise
+  (type $func (func))
+  (type $cont (cont $func))
+
+  (type $i-func (func (param i32)))
+  (type $i-cont (cont $i-func))
+
+  ;; a simplistic implementation of promises that assumes a maximum of
+  ;; 1000 promises and a maximum of one observer per promise
+
+  (tag $too-many-promises)
+  (tag $too-many-observers)
+
+  (global $num-promises (mut i32) (i32.const 0))
+  (global $max-promises i32 (i32.const 1000))
+  (table $observers 1000 (ref null $i-cont))  ;; observers waiting for promises to be fulfilled
+  (memory 1)                                 ;; promise values
+
+  ;; create and return a new promise
+  (func $new (export "new") (result i32)
+     (local $offset i32)
+     (local $p i32)
+     (if (i32.eq (global.get $num-promises) (global.get $max-promises))
+        (then (throw $too-many-promises)))
+     (local.set $p (global.get $num-promises))
+     (local.set $offset (i32.mul (local.get $p) (i32.const 4)))
+     (table.set $observers (local.get $p) (ref.null $i-cont))
+     (i32.store (local.get $offset) (i32.const -1))
+     (global.set $num-promises (i32.add (local.get $p) (i32.const 1)))
+     (return (local.get $p))
+  )
+
+  ;; check whether promise $p is fulfilled
+  (func $fulfilled (export "fulfilled") (param $p i32) (result i32)
+    (local $offset i32)
+    (local.set $offset (i32.mul (local.get $p) (i32.const 4)))
+    (i32.ne (i32.load (local.get $offset)) (i32.const -1))
+  )
+
+  ;; current value of promise $p
+  (func $read (export "read") (param $p i32) (result i32)
+    (local $offset i32)
+    (local.set $offset (i32.mul (local.get $p) (i32.const 4)))
+    (i32.load (local.get $offset))
+  )
+
+  ;; register an observer for when promise $p is fulfilled
+  (func $await (export "await") (param $p i32) (param $k (ref $i-cont))
+    (if (ref.is_null (table.get $observers (local.get $p)))
+       (then (table.set $observers (local.get $p) (local.get $k)))
+       (else (throw $too-many-observers))
+    )
+  )
+
+  ;; fulfill promise $p with value $v
+  (func $fulfill (export "fulfill") (param $p i32) (param $v i32) (result (ref null $cont))
+    (local $offset i32)
+    (local $k (ref null $i-cont))
+    (local.set $offset (i32.mul (local.get $p) (i32.const 4)))
+    (i32.store (local.get $offset) (local.get $v))
+    (local.set $k (table.get $observers (local.get $p)))
+    (if (ref.is_null (local.get $k))
+      (then (return (ref.null $cont)))
+    )
+    (return (cont.bind $i-cont $cont (local.get $v) (local.get $k)))
+  )
+)
+(register "promise")
+
+;; async-await scheduler
+(module $scheduler
+  (type $func (func))
+  (type $cont (cont $func))
+
+  (type $i-func (func (param i32)))
+  (type $i-cont (cont $i-func))
+
+  ;; async-await interface
+  ;;
+  ;; yield : [] -> []
+  ;; fulfill : [i32] -> [i32]
+  ;; async : [cont ([i32] -> [])] -> [i32]
+  ;; await : [i32] -> [i32]
+  (tag $yield (import "async-await" "yield"))
+  (tag $fulfill (import "async-await" "fulfill") (param i32) (param i32))
+  (tag $async (import "async-await" "async") (param (ref $i-cont)) (result i32))
+  (tag $await (import "async-await" "await") (param i32) (result i32))
+
+  ;; queue interface
+  (func $queue-empty (import "queue" "queue-empty") (result i32))
+  (func $dequeue (import "queue" "dequeue") (result (ref null $cont)))
+  (func $enqueue (import "queue" "enqueue") (param $k (ref null $cont)))
+
+  ;; promise interface
+  (func $new-promise (import "promise" "new") (result i32))
+  (func $promise-fulfilled (import "promise" "fulfilled") (param $p i32) (result i32))
+  (func $promise-value (import "promise" "read") (param $p i32) (result i32))
+  (func $await-promise (import "promise" "await") (param $p i32) (param $k (ref $i-cont)))
+  (func $fulfill-promise (import "promise" "fulfill") (param $p i32) (param $v i32) (result (ref null $cont)))
+
+  (func $run (export "run") (param $nextk (ref null $cont))
+    (local $p i32)
+    (local $v i32)
+    (local $ik (ref $i-cont))
+    (local $ak (ref $i-cont))
+    (local $k (ref null $cont))
+    (loop $l
+      (if (ref.is_null (local.get $nextk)) (then (return)))
+      (block $on_yield (result (ref $cont))
+        (block $on_fulfill (result i32 i32 (ref $cont))
+          (block $on_async (result (ref $i-cont) (ref $i-cont))
+            (block $on_await (result i32 (ref $i-cont))
+              (resume $cont (tag $yield $on_yield)
+                            (tag $fulfill $on_fulfill)
+                            (tag $async $on_async)
+                            (tag $await $on_await)
+                            (local.get $nextk)
+              )
+              (local.set $nextk (call $dequeue))
+              (br $l)  ;; thread terminated
+            ) ;;   $on_await (result i32 (ref $i-cont))
+            (local.set $ik)
+            (local.set $p)
+            (if (call $promise-fulfilled (local.get $p))
+                ;; if promise fulfilled then run continuation partially applied to value
+                (then (local.set $nextk (cont.bind $i-cont $cont (call $promise-value (local.get $p)) (local.get $ik))))
+                ;; else add continuation to promise and run next continuation from the queue
+                (else (call $await-promise (local.get $p) (local.get $ik))
+                      (local.set $nextk (call $dequeue)))
+            )
+            (br $l)
+          ) ;;   $on_async (result (ref $i-func) (ref $i-cont))
+          (local.set $ik)
+          (local.set $ak)
+            ;; create new promise
+            (call $new-promise)
+            (local.set $p)
+            ;; enqueue continuation partially applied to promise
+            (call $enqueue (cont.bind $i-cont $cont (local.get $p) (local.get $ik)))
+            ;; run computation partially applied to promise
+            (local.set $nextk (cont.bind $i-cont $cont (local.get $p) (local.get $ak)))
+          (br $l)
+        ) ;;   $on_fulfill (result i32 i32 (ref $cont))
+        (local.set $nextk)
+        (local.set $v)
+        (local.set $p)
+        (call $fulfill-promise (local.get $p) (local.get $v))
+        (local.set $k)
+        (if (ref.is_null (local.get $k))
+          (then)
+          (else (call $enqueue (local.get $k)))
+        )
+        (br $l)
+      ) ;;   $on_yield (result (ref $cont))
+      (call $enqueue)                    ;; current thread
+      (local.set $nextk (call $dequeue)) ;; next thread
+      (br $l)
+    )
+  )
+)
+(register "scheduler")
+
+(module
+  (type $func (func))
+  (type $cont (cont $func))
+
+  (func $scheduler (import "scheduler" "run") (param $nextk (ref null $cont)))
+
+  (func $log (import "spectest" "print_i32") (param i32))
+
+  (func $run-example (import "example" "run"))
+
+  (elem declare func $run-example)
+
+  (func (export "run")
+    (call $scheduler (cont.new $cont (ref.func $run-example)))
+  )
+)
+
+(invoke "run")
diff --git a/proposals/continuations/examples/control-lwt.wast b/proposals/continuations/examples/control-lwt.wast
new file mode 100644
index 00000000..1c1e6496
--- /dev/null
+++ b/proposals/continuations/examples/control-lwt.wast
@@ -0,0 +1,341 @@
+;; dynamic lightweight threads via control/prompt
+
+;; interface to control/prompt
+(module $control
+  (type $func (func))       ;; [] -> []
+  (type $cont (cont $func)) ;; cont ([] -> [])
+
+  (type $cont-func (func (param (ref $cont)))) ;; [cont ([] -> [])] -> []
+  (type $cont-cont (cont $cont-func))          ;; cont ([cont ([] -> [])] -> [])
+
+  ;; Implementation of a generic delimited control operator using
+  ;; effect handlers.
+  ;;
+  ;; For lightweight threads we have no payload. More general types
+  ;; for control and prompt are:
+  ;;
+  ;;   control : ([cont ([ta*] -> [tr*])] -> [tr*]) -> [ta*]
+  ;;   prompt : cont ([] -> [tr*]) -> [tr*]
+  ;;
+  ;; (We can also give more refined types if we want to support
+  ;; answer-type modification and various flavours of answer-type
+  ;; polymorphism - but these are well outside the scope of a Wasm
+  ;; proposal!)
+  ;;
+  ;; (Technically this is control0/prompt0 rather than
+  ;; control/prompt.)
+  (tag $control (export "control") (param (ref $cont-func)))    ;; control : ([cont ([] -> [])] -> []) -> []
+  (func $prompt (export "prompt") (param $nextk (ref null $cont)) ;; prompt : cont ([] -> []) -> []
+    (block $on_control (result (ref $cont-func) (ref $cont))
+       (resume (tag $control $on_control)
+               (local.get $nextk))
+       (return)
+    ) ;;   $on_control (param (ref $cont-func) (ref $cont))
+    (let (local $h (ref $cont-func)) (local $k (ref $cont))
+      (call_ref (local.get $k) (local.get $h))
+    )
+  )
+)
+(register "control")
+
+;; With control/prompt we use functions for abstracting over yield and
+;; fork operations rather than tags.
+
+(module $example
+  (type $func (func))       ;; [] -> []
+  (type $cont (cont $func)) ;; cont ([] -> [])
+
+  (type $cont-func (func (param (ref $cont)))) ;; [cont ([] -> [])] -> []
+  (type $cont-cont (cont $cont-func))          ;; cont ([cont ([] -> [])] -> [])
+
+  (type $func-cont-func-func (func (param (ref $func)) (param (ref $cont-func)))) ;; ([] -> []) -> ([cont ([] -> [])] -> []) -> []
+  (type $func-cont-func-cont (cont $func-cont-func-func))                         ;; cont (([] -> []) -> ([cont ([] -> [])] -> []) -> [])
+
+  (func $log (import "spectest" "print_i32") (param i32))
+
+  (elem declare func $main $thread1 $thread2 $thread3)
+
+  (func $main (export "main") (param $yield (ref $func)) (param $fork (ref $cont-func))
+    (call $log (i32.const 0))
+    (call_ref
+      (cont.bind (type $cont) (local.get $yield) (local.get $fork)
+        (cont.new (type $func-cont-func-cont) (ref.func $thread1)))
+      (local.get $fork))
+    (call $log (i32.const 1))
+    (call_ref
+      (cont.bind (type $cont) (local.get $yield) (local.get $fork)
+        (cont.new (type $func-cont-func-cont) (ref.func $thread2)))
+      (local.get $fork))
+    (call $log (i32.const 2))
+    (call_ref
+      (cont.bind (type $cont) (local.get $yield) (local.get $fork)
+        (cont.new (type $func-cont-func-cont) (ref.func $thread3)))
+      (local.get $fork))
+    (call $log (i32.const 3))
+  )
+
+  (func $thread1 (param $yield (ref $func)) (param $fork (ref $cont-func))
+    (call $log (i32.const 10))
+    (call_ref (local.get $yield))
+    (call $log (i32.const 11))
+    (call_ref (local.get $yield))
+    (call $log (i32.const 12))
+  )
+
+  (func $thread2 (param $yield (ref $func)) (param $fork (ref $cont-func))
+    (call $log (i32.const 20))
+    (call_ref (local.get $yield))
+    (call $log (i32.const 21))
+    (call_ref (local.get $yield))
+    (call $log (i32.const 22))
+  )
+
+  (func $thread3 (param $yield (ref $func)) (param $fork (ref $cont-func))
+    (call $log (i32.const 30))
+    (call_ref (local.get $yield))
+    (call $log (i32.const 31))
+    (call_ref (local.get $yield))
+    (call $log (i32.const 32))
+  )
+)
+(register "example")
+
+(module $queue
+  (type $func (func))
+  (type $cont (cont $func))
+
+  (func $log (import "spectest" "print_i32") (param i32))
+
+  ;; Table as simple queue (keeping it simple, no ring buffer)
+  (table $queue 0 (ref null $cont))
+  (global $qdelta i32 (i32.const 10))
+  (global $qback (mut i32) (i32.const 0))
+  (global $qfront (mut i32) (i32.const 0))
+
+  (func $queue-empty (export "queue-empty") (result i32)
+    (i32.eq (global.get $qfront) (global.get $qback))
+  )
+
+  (func $dequeue (export "dequeue") (result (ref null $cont))
+    (local $i i32)
+    (if (call $queue-empty)
+      (then (return (ref.null $cont)))
+    )
+    (local.set $i (global.get $qfront))
+    (global.set $qfront (i32.add (local.get $i) (i32.const 1)))
+    (table.get $queue (local.get $i))
+  )
+
+  (func $enqueue (export "enqueue") (param $k (ref $cont))
+    ;; Check if queue is full
+    (if (i32.eq (global.get $qback) (table.size $queue))
+      (then
+        ;; Check if there is enough space in the front to compact
+        (if (i32.lt_u (global.get $qfront) (global.get $qdelta))
+          (then
+            ;; Space is below threshold, grow table instead
+            (drop (table.grow $queue (ref.null $cont) (global.get $qdelta)))
+          )
+          (else
+            ;; Enough space, move entries up to head of table
+            (global.set $qback (i32.sub (global.get $qback) (global.get $qfront)))
+            (table.copy $queue $queue
+              (i32.const 0)         ;; dest = new front = 0
+              (global.get $qfront)  ;; src = old front
+              (global.get $qback)   ;; len = new back = old back - old front
+            )
+            (table.fill $queue      ;; null out old entries to avoid leaks
+              (global.get $qback)   ;; start = new back
+              (ref.null $cont)      ;; init value
+              (global.get $qfront)  ;; len = old front = old front - new front
+            )
+            (global.set $qfront (i32.const 0))
+          )
+        )
+      )
+    )
+    (table.set $queue (global.get $qback) (local.get $k))
+    (global.set $qback (i32.add (global.get $qback) (i32.const 1)))
+  )
+)
+(register "queue")
+
+(module $scheduler
+  (type $func (func))       ;; [] -> []
+  (type $cont (cont $func)) ;; cont ([] -> [])
+
+  (type $cont-func (func (param (ref $cont)))) ;; [cont ([] -> [])] -> []
+  (type $cont-cont (cont $cont-func))          ;; cont ([cont ([] -> [])] -> [])
+
+  (type $func-cont-func-func (func (param (ref $func)) (param (ref $cont-func)))) ;; ([] -> []) -> ([cont ([] -> [])] -> []) -> []
+  (type $func-cont-func-cont (cont $func-cont-func-func))                         ;; cont (([] -> []) -> ([cont ([] -> [])] -> []) -> [])
+
+  (func $log (import "spectest" "print_i32") (param i32))
+
+  ;; queue interface
+  (func $queue-empty (import "queue" "queue-empty") (result i32))
+  (func $dequeue (import "queue" "dequeue") (result (ref null $cont)))
+  (func $enqueue (import "queue" "enqueue") (param $k (ref $cont)))
+
+  (elem declare func
+     $handle-yield-sync $handle-yield
+     $handle-fork-sync $handle-fork-kt $handle-fork-tk $handle-fork-ykt $handle-fork-ytk
+     $yield
+     $fork-sync $fork-kt $fork-tk $fork-ykt $fork-ytk)
+
+  ;; control/prompt interface
+  (tag $control (import "control" "control") (param (ref $cont-func)))     ;; control : ([cont ([] -> [])] -> []) -> []
+  (func $prompt (import "control" "prompt") (param $nextk (ref null $cont))) ;; prompt : cont ([] -> []) -> []
+
+  ;; generic boilerplate scheduler
+  ;;
+  ;; with control/prompt the core scheduler loop must be decoupled
+  ;; from the implementations of each operation (yield / fork) as the
+  ;; latter are passed in as arguments to user code
+  (func $scheduler (param $nextk (ref null $cont))
+    (loop $loop
+      (if (ref.is_null (local.get $nextk)) (then (return)))
+      (call $prompt (local.get $nextk))
+      (local.set $nextk (call $dequeue))
+      (br $loop)
+    )
+  )
+
+  ;; func.bind is needed in the implementations of fork
+  ;;
+  ;; More generally func.bind is needed for any operation that
+  ;; takes arguments.
+  ;;
+  ;; One could use another continuation here instead, but constructing
+  ;; a new continuation every time an operation is invoked seems
+  ;; unnecessarily wasteful.
+
+  ;; synchronous scheduler
+  (func $handle-yield-sync (param $k (ref $cont))
+    (call $scheduler (local.get $k))
+  )
+  (func $yield-sync
+    (suspend $control (ref.func $handle-yield))
+  )
+  (func $handle-fork-sync (param $t (ref $cont)) (param $k (ref $cont))
+    (call $enqueue (local.get $t))
+    (call $scheduler (local.get $k))
+  )
+  (func $fork-sync (param $t (ref $cont))
+    (suspend $control (func.bind (type $cont-func) (local.get $t) (ref.func $handle-fork-sync)))
+  )
+  (func $sync (export "sync") (param $k (ref $func-cont-func-cont))
+    (call $scheduler
+      (cont.bind (type $cont) (ref.func $yield) (ref.func $fork-sync) (local.get $k)))
+  )
+
+  ;; asynchronous yield (used by all asynchronous schedulers)
+  (func $handle-yield (param $k (ref $cont))
+    (call $enqueue (local.get $k))
+    (call $scheduler (call $dequeue))
+  )
+  (func $yield
+    (suspend $control (ref.func $handle-yield))
+  )
+  ;; four asynchronous implementations of fork:
+  ;;   * kt and tk don't yield on encountering a fork
+  ;;     1) kt runs the continuation, queuing up the new thread for later
+  ;;     2) tk runs the new thread first, queuing up the continuation for later
+  ;;   * ykt and ytk do yield on encountering a fork
+  ;;     3) ykt runs the continuation, queuing up the new thread for later
+  ;;     4) ytk runs the new thread first, queuing up the continuation for later
+
+  ;; no yield on fork, continuation first
+  (func $handle-fork-kt (param $t (ref $cont)) (param $k (ref $cont))
+    (call $enqueue (local.get $t))
+    (call $scheduler (local.get $k))
+  )
+  (func $fork-kt (param $t (ref $cont))
+    (suspend $control (func.bind (type $cont-func) (local.get $t) (ref.func $handle-fork-kt)))
+  )
+  (func $kt (export "kt") (param $k (ref $func-cont-func-cont))
+    (call $scheduler
+      (cont.bind (type $cont) (ref.func $yield) (ref.func $fork-kt) (local.get $k)))
+  )
+
+  ;; no yield on fork, new thread first
+  (func $handle-fork-tk (param $t (ref $cont)) (param $k (ref $cont))
+    (call $enqueue (local.get $k))
+    (call $scheduler (local.get $t))
+  )
+  (func $fork-tk (param $t (ref $cont))
+    (suspend $control (func.bind (type $cont-func) (local.get $t) (ref.func $handle-fork-tk)))
+  )
+  (func $tk (export "tk") (param $k (ref $func-cont-func-cont))
+    (call $scheduler
+      (cont.bind (type $cont) (ref.func $yield) (ref.func $fork-tk) (local.get $k)))
+  )
+
+  ;; yield on fork, continuation first
+  (func $handle-fork-ykt (param $t (ref $cont)) (param $k (ref $cont))
+    (call $enqueue (local.get $k))
+    (call $enqueue (local.get $t))
+    (call $scheduler (call $dequeue))
+  )
+  (func $fork-ykt (param $t (ref $cont))
+    (suspend $control (func.bind (type $cont-func) (local.get $t) (ref.func $handle-fork-ykt)))
+  )
+  (func $ykt (export "ykt") (param $k (ref $func-cont-func-cont))
+    (call $scheduler
+      (cont.bind (type $cont) (ref.func $yield) (ref.func $fork-ykt) (local.get $k)))
+  )
+
+  ;; yield on fork, new thread first
+  (func $handle-fork-ytk (param $t (ref $cont)) (param $k (ref $cont))
+    (call $enqueue (local.get $t))
+    (call $enqueue (local.get $k))
+    (call $scheduler (call $dequeue))
+  )
+  (func $fork-ytk (param $t (ref $cont))
+    (suspend $control (func.bind (type $cont-func) (local.get $t) (ref.func $handle-fork-ytk)))
+  )
+  (func $ytk (export "ytk") (param $k (ref $func-cont-func-cont))
+    (call $scheduler
+      (cont.bind (type $cont) (ref.func $yield) (ref.func $fork-ytk) (local.get $k)))
+  )
+)
+(register "scheduler")
+
+(module
+  (type $func (func))       ;; [] -> []
+  (type $cont (cont $func)) ;; cont ([] -> [])
+
+  (type $cont-func (func (param (ref $cont)))) ;; [cont ([] -> [])] -> []
+  (type $cont-cont (cont $cont-func))          ;; cont ([cont ([] -> [])] -> [])
+
+  (type $func-cont-func-func (func (param (ref $func)) (param (ref $cont-func)))) ;; ([] -> []) -> ([cont ([] -> [])] -> []) -> []
+  (type $func-cont-func-cont (cont $func-cont-func-func))                         ;; cont (([] -> []) -> ([cont ([] -> [])] -> []) -> [])
+
+  (func $scheduler-sync (import "scheduler" "sync") (param $nextk (ref $func-cont-func-cont)))
+  (func $scheduler-kt (import "scheduler" "kt") (param $nextk (ref $func-cont-func-cont)))
+  (func $scheduler-tk (import "scheduler" "tk") (param $nextk (ref $func-cont-func-cont)))
+  (func $scheduler-ykt (import "scheduler" "ykt") (param $nextk (ref $func-cont-func-cont)))
+  (func $scheduler-ytk (import "scheduler" "ytk") (param $nextk (ref $func-cont-func-cont)))
+
+  (func $log (import "spectest" "print_i32") (param i32))
+
+  (func $main (import "example" "main") (param $yield (ref $func)) (param $fork (ref $cont-func)))
+
+  (elem declare func $main)
+
+  (func $run (export "run")
+    (call $log (i32.const -1))
+    (call $scheduler-sync (cont.new (type $func-cont-func-cont) (ref.func $main)))
+    (call $log (i32.const -2))
+    (call $scheduler-kt (cont.new (type $func-cont-func-cont) (ref.func $main)))
+    (call $log (i32.const -3))
+    (call $scheduler-tk (cont.new (type $func-cont-func-cont) (ref.func $main)))
+    (call $log (i32.const -4))
+    (call $scheduler-ykt (cont.new (type $func-cont-func-cont) (ref.func $main)))
+    (call $log (i32.const -5))
+    (call $scheduler-ytk (cont.new (type $func-cont-func-cont) (ref.func $main)))
+    (call $log (i32.const -6))
+  )
+)
+
+(invoke "run")
diff --git a/proposals/continuations/examples/fun-actor-lwt.wast b/proposals/continuations/examples/fun-actor-lwt.wast
new file mode 100644
index 00000000..a9cfff91
--- /dev/null
+++ b/proposals/continuations/examples/fun-actor-lwt.wast
@@ -0,0 +1,398 @@
+;; Actors via lightweight threads - functional version
+
+;; actor interface
+(module $actor
+  (type $func (func))
+  (type $cont (cont $func))
+
+  (tag $self (export "self") (result i32))
+  (tag $spawn (export "spawn") (param (ref $cont)) (result i32))
+  (tag $send (export "send") (param i32 i32))
+  (tag $recv (export "recv") (result i32))
+)
+(register "actor")
+
+;; a simple example - pass a message through a chain of actors
+(module $chain
+  (type $func (func))
+  (type $cont (cont $func))
+
+  (type $i-func (func (param i32)))
+  (type $i-cont (cont $i-func))
+
+  (tag $self (import "actor" "self") (result i32))
+  (tag $spawn (import "actor" "spawn") (param (ref $cont)) (result i32))
+  (tag $send (import "actor" "send") (param i32 i32))
+  (tag $recv (import "actor" "recv") (result i32))
+
+  (elem declare func $next)
+
+  (func $log (import "spectest" "print_i32") (param i32))
+
+  (func $next (param $p i32)
+    (local $s i32)
+    (local.set $s (suspend $recv))
+    (call $log (i32.const -1))
+    (suspend $send (local.get $s) (local.get $p))
+  )
+
+  ;; send the message 42 through a chain of n actors
+  (func $chain (export "chain") (param $n i32)
+    (local $s i32)
+    (local $p i32)
+    (local.set $p (suspend $self))
+
+    (loop $l
+      (if (i32.eqz (local.get $n))
+        (then (suspend $send (i32.const 42) (local.get $p)))
+        (else (local.set $p (suspend $spawn (cont.bind $i-cont $cont (local.get $p) (cont.new $i-cont (ref.func $next)))))
+              (local.set $n (i32.sub (local.get $n) (i32.const 1)))
+              (br $l))
+      )
+    )
+    (local.set $s (suspend $recv))
+    (call $log (local.get $s))
+  )
+)
+(register "chain")
+
+;; interface to lightweight threads
+(module $lwt
+  (type $func (func))
+  (type $cont (cont $func))
+
+  (tag $yield (export "yield"))
+  (tag $fork (export "fork") (param (ref $cont)))
+)
+(register "lwt")
+
+;; queue of threads
+(module $queue
+  (type $func (func))
+  (type $cont (cont $func))
+
+  ;; Table as simple queue (keeping it simple, no ring buffer)
+  (table $queue 0 (ref null $cont))
+  (global $qdelta i32 (i32.const 10))
+  (global $qback (mut i32) (i32.const 0))
+  (global $qfront (mut i32) (i32.const 0))
+
+  (func $queue-empty (export "queue-empty") (result i32)
+    (i32.eq (global.get $qfront) (global.get $qback))
+  )
+
+  (func $dequeue (export "dequeue") (result (ref null $cont))
+    (local $i i32)
+    (if (call $queue-empty)
+      (then (return (ref.null $cont)))
+    )
+    (local.set $i (global.get $qfront))
+    (global.set $qfront (i32.add (local.get $i) (i32.const 1)))
+    (table.get $queue (local.get $i))
+  )
+
+  (func $enqueue (export "enqueue") (param $k (ref $cont))
+    ;; Check if queue is full
+    (if (i32.eq (global.get $qback) (table.size $queue))
+      (then
+        ;; Check if there is enough space in the front to compact
+        (if (i32.lt_u (global.get $qfront) (global.get $qdelta))
+          (then
+            ;; Space is below threshold, grow table instead
+            (drop (table.grow $queue (ref.null $cont) (global.get $qdelta)))
+          )
+          (else
+            ;; Enough space, move entries up to head of table
+            (global.set $qback (i32.sub (global.get $qback) (global.get $qfront)))
+            (table.copy $queue $queue
+              (i32.const 0)         ;; dest = new front = 0
+              (global.get $qfront)  ;; src = old front
+              (global.get $qback)   ;; len = new back = old back - old front
+            )
+            (table.fill $queue      ;; null out old entries to avoid leaks
+              (global.get $qback)   ;; start = new back
+              (ref.null $cont)      ;; init value
+              (global.get $qfront)  ;; len = old front = old front - new front
+            )
+            (global.set $qfront (i32.const 0))
+          )
+        )
+      )
+    )
+    (table.set $queue (global.get $qback) (local.get $k))
+    (global.set $qback (i32.add (global.get $qback) (i32.const 1)))
+  )
+)
+(register "queue")
+
+;; simple scheduler
+(module $scheduler
+  (type $func (func))
+  (type $cont (cont $func))
+
+  (tag $yield (import "lwt" "yield"))
+  (tag $fork (import "lwt" "fork") (param (ref $cont)))
+
+  (func $queue-empty (import "queue" "queue-empty") (result i32))
+  (func $dequeue (import "queue" "dequeue") (result (ref null $cont)))
+  (func $enqueue (import "queue" "enqueue") (param $k (ref $cont)))
+
+  (func $run (export "run") (param $main (ref $cont))
+    (call $enqueue (local.get $main))
+    (loop $l
+      (if (call $queue-empty) (then (return)))
+      (block $on_yield (result (ref $cont))
+        (block $on_fork (result (ref $cont) (ref $cont))
+          (resume $cont (tag $yield $on_yield) (tag $fork $on_fork)
+            (call $dequeue)
+          )
+          (br $l)  ;; thread terminated
+        ) ;;   $on_fork (result (ref $cont) (ref $cont))
+        (call $enqueue) ;; current thread
+        (call $enqueue) ;; new thread
+        (br $l)
+      )
+      ;;     $on_yield (result (ref $cont))
+      (call $enqueue) ;; current thread
+      (br $l)
+    )
+  )
+)
+(register "scheduler")
+
+(module $mailboxes
+  ;; Stupid implementation of mailboxes that raises an exception if
+  ;; there are too many mailboxes or if more than one message is sent
+  ;; to any given mailbox.
+  ;;
+  ;; Sufficient for the simple chain example.
+
+  ;; -1 means empty
+
+  (tag $too-many-mailboxes)
+  (tag $too-many-messages)
+
+  (memory 1)
+
+  (global $msize (mut i32) (i32.const 0))
+  (global $mmax i32 (i32.const 1024)) ;; maximum number of mailboxes
+
+  (func $init (export "init")
+     (memory.fill (i32.const 0) (i32.const -1) (i32.mul (global.get $mmax) (i32.const 4)))
+  )
+
+  (func $empty-mb (export "empty-mb") (param $mb i32) (result i32)
+    (local $offset i32)
+    (local.set $offset (i32.mul (local.get $mb) (i32.const 4)))
+    (i32.eq (i32.load (local.get $offset)) (i32.const -1))
+  )
+
+  (func $new-mb (export "new-mb") (result i32)
+     (local $mb i32)
+
+     (if (i32.ge_u (global.get $msize) (global.get $mmax))
+         (then (throw $too-many-mailboxes))
+     )
+
+     (local.set $mb (global.get $msize))
+     (global.set $msize (i32.add (global.get $msize) (i32.const 1)))
+     (return (local.get $mb))
+  )
+
+  (func $send-to-mb (export "send-to-mb") (param $v i32) (param $mb i32)
+    (local $offset i32)
+    (local.set $offset (i32.mul (local.get $mb) (i32.const 4)))
+    (if (call $empty-mb (local.get $mb))
+      (then (i32.store (local.get $offset) (local.get $v)))
+      (else (throw $too-many-messages))
+    )
+  )
+
+  (func $recv-from-mb (export "recv-from-mb") (param $mb i32) (result i32)
+    (local $v i32)
+    (local $offset i32)
+    (local.set $offset (i32.mul (local.get $mb) (i32.const 4)))
+    (local.set $v (i32.load (local.get $offset)))
+    (i32.store (local.get $offset) (i32.const -1))
+    (local.get $v)
+  )
+)
+(register "mailboxes")
+
+;; actors via lightweight threads
+(module $actor-as-lwt
+  (type $func (func))
+  (type $cont (cont $func))
+
+  (type $i-func (func (param i32)))
+  (type $i-cont (cont $i-func))
+
+  (type $icont-func (func (param i32 (ref $cont))))
+  (type $icont-cont (cont $icont-func))
+
+  (func $log (import "spectest" "print_i32") (param i32))
+
+  ;; lwt interface
+  (tag $yield (import "lwt" "yield"))
+  (tag $fork (import "lwt" "fork") (param (ref $cont)))
+
+  ;; mailbox interface
+  (func $init (import "mailboxes" "init"))
+  (func $empty-mb (import "mailboxes" "empty-mb") (param $mb i32) (result i32))
+  (func $new-mb (import "mailboxes" "new-mb") (result i32))
+  (func $send-to-mb (import "mailboxes" "send-to-mb") (param $v i32) (param $mb i32))
+  (func $recv-from-mb (import "mailboxes" "recv-from-mb") (param $mb i32) (result i32))
+
+  ;; actor interface
+  (tag $self (import "actor" "self") (result i32))
+  (tag $spawn (import "actor" "spawn") (param (ref $cont)) (result i32))
+  (tag $send (import "actor" "send") (param i32 i32))
+  (tag $recv (import "actor" "recv") (result i32))
+
+  (elem declare func $act-nullary $act-res)
+
+  ;; resume with $ik applied to $res
+  (func $act-res (param $mine i32) (param $res i32) (param $ik (ref $i-cont))
+    (local $yours i32)
+    (local $k (ref $cont))
+    (local $you (ref $cont))
+    (block $on_self (result (ref $i-cont))
+      (block $on_spawn (result (ref $cont) (ref $i-cont))
+        (block $on_send (result i32 i32 (ref $cont))
+          (block $on_recv (result (ref $i-cont))
+             ;; this should really be a tail call to the continuation
+             ;; do we need a 'return_resume' operator?
+             (resume $i-cont (tag $self $on_self)
+                             (tag $spawn $on_spawn)
+                             (tag $send $on_send)
+                             (tag $recv $on_recv)
+                             (local.get $res) (local.get $ik)
+             )
+             (return)
+          ) ;;   $on_recv (result (ref $i-cont))
+          (local.set $ik)
+          ;; block this thread until the mailbox is non-empty
+          (loop $l
+            (if (call $empty-mb (local.get $mine))
+                (then (suspend $yield)
+                      (br $l))
+            )
+          )
+          (call $recv-from-mb (local.get $mine))
+          (local.set $res)
+          (return_call $act-res (local.get $mine) (local.get $res) (local.get $ik))
+        ) ;;   $on_send (result i32 i32 (ref $cont))
+        (local.set $k)
+        (call $send-to-mb)
+        (return_call $act-nullary (local.get $mine) (local.get $k))
+      ) ;;   $on_spawn (result (ref $cont) (ref $i-cont))
+      (local.set $ik)
+      (local.set $you)
+      (call $new-mb)
+      (local.set $yours)
+      (suspend $fork (cont.bind $icont-cont $cont
+                                (local.get $yours)
+                                (local.get $you)
+                                (cont.new $icont-cont (ref.func $act-nullary))))
+      (return_call $act-res (local.get $mine) (local.get $yours) (local.get $ik))
+    ) ;;   $on_self (result (ref $i-cont))
+    (local.set $ik)
+    (return_call $act-res (local.get $mine) (local.get $mine) (local.get $ik))
+  )
+
+  ;; resume with nullary continuation
+  (func $act-nullary (param $mine i32) (param $k (ref $cont))
+    (local $res i32)
+    (local $ik (ref $i-cont))
+    (local $you (ref $cont))
+    (local $yours i32)
+    (block $on_self (result (ref $i-cont))
+      (block $on_spawn (result (ref $cont) (ref $i-cont))
+        (block $on_send (result i32 i32 (ref $cont))
+          (block $on_recv (result (ref $i-cont))
+             ;; this should really be a tail call to the continuation
+             ;; do we need a 'return_resume' operator?
+             (resume $cont (tag $self $on_self)
+                           (tag $spawn $on_spawn)
+                           (tag $send $on_send)
+                           (tag $recv $on_recv)
+                           (local.get $k)
+             )
+             (return)
+          ) ;;   $on_recv (result (ref $i-cont))
+          (local.set $ik)
+          ;; block this thread until the mailbox is non-empty
+          (loop $l
+            (if (call $empty-mb (local.get $mine))
+                (then (suspend $yield)
+                      (br $l))
+            )
+          )
+          (call $recv-from-mb (local.get $mine))
+          (local.set $res)
+          (return_call $act-res (local.get $mine) (local.get $res) (local.get $ik))
+        ) ;;   $on_send (result i32 i32 (ref $cont))
+        (local.set $k)
+        (call $send-to-mb)
+        (return_call $act-nullary (local.get $mine) (local.get $k))
+      ) ;;   $on_spawn (result (ref $cont) (ref $i-cont))
+      (local.set $ik)
+      (local.set $you)
+      (call $new-mb)
+      (local.set $yours)
+      (suspend $fork (cont.bind $icont-cont $cont
+                                (local.get $yours)
+                                (local.get $you)
+                                (cont.new $icont-cont (ref.func $act-nullary))))
+      (return_call $act-res (local.get $mine) (local.get $yours) (local.get $ik))
+    ) ;;   $on_self (result (ref $i-cont))
+    (local.set $ik)
+    (return_call $act-res (local.get $mine) (local.get $mine) (local.get $ik))
+  )
+
+  (func $act (export "act") (param $k (ref $cont))
+    (call $init)
+    (call $act-nullary (call $new-mb) (local.get $k))
+  )
+)
+(register "actor-as-lwt")
+
+;; composing the actor and scheduler handlers together
+(module $actor-scheduler
+  (type $func (func))
+  (type $cont (cont $func))
+
+  (type $cont-func (func (param (ref $cont))))
+  (type $cont-cont (cont $cont-func))
+
+  (type $f-func (func (param (ref $func))))
+
+  (elem declare func $act $scheduler)
+
+  (func $act (import "actor-as-lwt" "act") (param $k (ref $cont)))
+  (func $scheduler (import "scheduler" "run") (param $k (ref $cont)))
+
+  (func $run-actor (export "run-actor") (param $k (ref $cont))
+    (call $scheduler (cont.bind $cont-cont $cont (local.get $k) (cont.new $cont-cont (ref.func $act))))
+  )
+)
+(register "actor-scheduler")
+
+(module
+  (type $func (func))
+  (type $cont (cont $func))
+
+  (type $i-func (func (param i32)))
+  (type $i-cont (cont $i-func))
+
+  (elem declare func $chain)
+
+  (func $run-actor (import "actor-scheduler" "run-actor") (param $k (ref $cont)))
+  (func $chain (import "chain" "chain") (param $n i32))
+
+  (func $run-chain (export "run-chain") (param $n i32)
+    (call $run-actor (cont.bind $i-cont $cont (local.get $n) (cont.new $i-cont (ref.func $chain))))
+  )
+)
+
+(invoke "run-chain" (i32.const 64))
diff --git a/proposals/continuations/examples/fun-lwt.wast b/proposals/continuations/examples/fun-lwt.wast
new file mode 100644
index 00000000..2b57b53d
--- /dev/null
+++ b/proposals/continuations/examples/fun-lwt.wast
@@ -0,0 +1,267 @@
+;; functional lightweight threads
+
+;; interface to lightweight threads
+(module $lwt
+  (type $func (func))       ;; [] -> []
+  (type $cont (cont $func)) ;; cont ([] -> [])
+
+  (tag $yield (export "yield"))                   ;; [] -> []
+  (tag $fork (export "fork") (param (ref $cont))) ;; [cont ([] -> [])] -> []
+)
+(register "lwt")
+
+(module $example
+  (type $func (func))       ;; [] -> []
+  (type $cont (cont $func)) ;; cont ([] -> [])
+
+  (tag $yield (import "lwt" "yield"))                   ;; [] -> []
+  (tag $fork (import "lwt" "fork") (param (ref $cont))) ;; [cont ([] -> [])] -> []
+
+  (func $log (import "spectest" "print_i32") (param i32))
+
+  (elem declare func $thread1 $thread2 $thread3)
+
+  (func $main (export "main")
+    (call $log (i32.const 0))
+    (suspend $fork (cont.new $cont (ref.func $thread1)))
+    (call $log (i32.const 1))
+    (suspend $fork (cont.new $cont (ref.func $thread2)))
+    (call $log (i32.const 2))
+    (suspend $fork (cont.new $cont (ref.func $thread3)))
+    (call $log (i32.const 3))
+  )
+
+  (func $thread1
+    (call $log (i32.const 10))
+    (suspend $yield)
+    (call $log (i32.const 11))
+    (suspend $yield)
+    (call $log (i32.const 12))
+  )
+
+  (func $thread2
+    (call $log (i32.const 20))
+    (suspend $yield)
+    (call $log (i32.const 21))
+    (suspend $yield)
+    (call $log (i32.const 22))
+  )
+
+  (func $thread3
+    (call $log (i32.const 30))
+    (suspend $yield)
+    (call $log (i32.const 31))
+    (suspend $yield)
+    (call $log (i32.const 32))
+  )
+)
+(register "example")
+
+(module $queue
+  (type $func (func))       ;; [] -> []
+  (type $cont (cont $func)) ;; cont ([] -> [])
+
+  ;; Table as simple queue (keeping it simple, no ring buffer)
+  (table $queue 0 (ref null $cont))
+  (global $qdelta i32 (i32.const 10))
+  (global $qback (mut i32) (i32.const 0))
+  (global $qfront (mut i32) (i32.const 0))
+
+  (func $queue-empty (export "queue-empty") (result i32)
+    (i32.eq (global.get $qfront) (global.get $qback))
+  )
+
+  (func $dequeue (export "dequeue") (result (ref null $cont))
+    (local $i i32)
+    (if (call $queue-empty)
+      (then (return (ref.null $cont)))
+    )
+    (local.set $i (global.get $qfront))
+    (global.set $qfront (i32.add (local.get $i) (i32.const 1)))
+    (table.get $queue (local.get $i))
+  )
+
+  (func $enqueue (export "enqueue") (param $k (ref $cont))
+    ;; Check if queue is full
+    (if (i32.eq (global.get $qback) (table.size $queue))
+      (then
+        ;; Check if there is enough space in the front to compact
+        (if (i32.lt_u (global.get $qfront) (global.get $qdelta))
+          (then
+            ;; Space is below threshold, grow table instead
+            (drop (table.grow $queue (ref.null $cont) (global.get $qdelta)))
+          )
+          (else
+            ;; Enough space, move entries up to head of table
+            (global.set $qback (i32.sub (global.get $qback) (global.get $qfront)))
+            (table.copy $queue $queue
+              (i32.const 0)         ;; dest = new front = 0
+              (global.get $qfront)  ;; src = old front
+              (global.get $qback)   ;; len = new back = old back - old front
+            )
+            (table.fill $queue      ;; null out old entries to avoid leaks
+              (global.get $qback)   ;; start = new back
+              (ref.null $cont)      ;; init value
+              (global.get $qfront)  ;; len = old front = old front - new front
+            )
+            (global.set $qfront (i32.const 0))
+          )
+        )
+      )
+    )
+    (table.set $queue (global.get $qback) (local.get $k))
+    (global.set $qback (i32.add (global.get $qback) (i32.const 1)))
+  )
+)
+(register "queue")
+
+(module $scheduler
+  (type $func (func))       ;; [] -> []
+  (type $cont (cont $func)) ;; cont ([] -> [])
+
+  (tag $yield (import "lwt" "yield"))                   ;; [] -> []
+  (tag $fork (import "lwt" "fork") (param (ref $cont))) ;; [cont ([] -> [])] -> []
+
+  (func $queue-empty (import "queue" "queue-empty") (result i32))
+  (func $dequeue (import "queue" "dequeue") (result (ref null $cont)))
+  (func $enqueue (import "queue" "enqueue") (param $k (ref $cont)))
+
+  ;; synchronous scheduler (run current thread to completion without
+  ;; yielding)
+  (func $sync (export "sync") (param $nextk (ref null $cont))
+    (if (ref.is_null (local.get $nextk)) (then (return)))
+    (block $on_yield (result (ref $cont))
+      (block $on_fork (result (ref $cont) (ref $cont))
+        (resume $cont
+          (tag $yield $on_yield)
+          (tag $fork $on_fork)
+          (local.get $nextk)
+        )
+        (return_call $sync (call $dequeue))
+      ) ;;   $on_fork (result (ref $func) (ref $cont))
+      (local.set $nextk)
+      (call $enqueue)
+      (return_call $sync (local.get $nextk))
+    ) ;;   $on_yield (result (ref $cont))
+    (return_call $sync)
+  )
+
+  ;; four different schedulers:
+  ;;   * kt and tk don't yield on encountering a fork
+  ;;     1) kt runs the continuation, queuing up the new thread for later
+  ;;     2) tk runs the new thread first, queuing up the continuation for later
+  ;;   * ykt and ytk do yield on encountering a fork
+  ;;     3) ykt runs the continuation, queuing up the new thread for later
+  ;;     4) ytk runs the new thread first, queuing up the continuation for later
+
+  ;; no yield on fork, continuation first
+  (func $kt (export "kt") (param $nextk (ref null $cont))
+    (if (ref.is_null (local.get $nextk)) (then (return)))
+    (block $on_yield (result (ref $cont))
+      (block $on_fork (result (ref $cont) (ref $cont))
+        (resume $cont
+          (tag $yield $on_yield)
+          (tag $fork $on_fork)
+          (local.get $nextk)
+        )
+        (return_call $tk (call $dequeue))
+      ) ;;   $on_fork (result (ref $func) (ref $cont))
+      (local.set $nextk)
+      (call $enqueue)
+      (return_call $tk (local.get $nextk))
+    ) ;;   $on_yield (result (ref $cont))
+    (call $enqueue)
+    (return_call $tk (call $dequeue))
+  )
+
+  ;; no yield on fork, new thread first
+  (func $tk (export "tk") (param $nextk (ref null $cont))
+    (if (ref.is_null (local.get $nextk)) (then (return)))
+    (block $on_yield (result (ref $cont))
+      (block $on_fork (result (ref $cont) (ref $cont))
+        (resume $cont
+          (tag $yield $on_yield)
+          (tag $fork $on_fork)
+          (local.get $nextk))
+        (return_call $kt (call $dequeue))
+      ) ;;   $on_fork (result (ref $cont) (ref $cont))
+      (return_call $kt (call $enqueue))
+    ) ;;   $on_yield (result (ref $cont))
+    (call $enqueue)
+    (return_call $kt (call $dequeue))
+  )
+
+  ;; yield on fork, continuation first
+  (func $ykt (export "ykt") (param $nextk (ref null $cont))
+    (if (ref.is_null (local.get $nextk)) (then (return)))
+    (block $on_yield (result (ref $cont))
+      (block $on_fork (result (ref $cont) (ref $cont))
+        (resume $cont
+          (tag $yield $on_yield)
+          (tag $fork $on_fork)
+          (local.get $nextk)
+        )
+        (return_call $ykt (call $dequeue))
+      ) ;;   $on_fork (result (ref $cont) (ref $cont))
+      (call $enqueue)
+      (call $enqueue)
+      (return_call $ykt (call $dequeue))
+    ) ;;   $on_yield (result (ref $cont))
+    (call $enqueue)
+    (return_call $ykt (call $dequeue))
+  )
+
+  ;; yield on fork, new thread first
+  (func $ytk (export "ytk") (param $nextk (ref null $cont))
+    (local $k (ref $cont))
+    (if (ref.is_null (local.get $nextk)) (then (return)))
+    (block $on_yield (result (ref $cont))
+      (block $on_fork (result (ref $cont) (ref $cont))
+        (resume $cont (tag $yield $on_yield) (tag $fork $on_fork) (local.get $nextk))
+        (return_call $ytk (call $dequeue))
+      ) ;;   $on_fork (result (ref $cont) (ref $cont))
+      (local.set $k)
+      (call $enqueue)
+      (call $enqueue (local.get $k))
+      (return_call $ytk (call $dequeue))
+    ) ;;   $on_yield (result (ref $cont))
+    (call $enqueue)
+    (return_call $ytk (call $dequeue))
+  )
+)
+
+(register "scheduler")
+
+(module
+  (type $func (func))       ;; [] -> []
+  (type $cont (cont $func)) ;; cont ([] -> [])
+
+  (func $scheduler-sync (import "scheduler" "sync") (param $nextk (ref null $cont)))
+  (func $scheduler-kt (import "scheduler" "kt") (param $nextk (ref null $cont)))
+  (func $schedule-tk (import "scheduler" "tk") (param $nextk (ref null $cont)))
+  (func $scheduler-ykt (import "scheduler" "ykt") (param $nextk (ref null $cont)))
+  (func $scheduler-ytk (import "scheduler" "ytk") (param $nextk (ref null $cont)))
+
+  (func $log (import "spectest" "print_i32") (param i32))
+
+  (func $main (import "example" "main"))
+
+  (elem declare func $main)
+
+  (func (export "run")
+    (call $log (i32.const -1))
+    (call $scheduler-sync (cont.new $cont (ref.func $main)))
+    (call $log (i32.const -2))
+    (call $scheduler-kt (cont.new $cont (ref.func $main)))
+    (call $log (i32.const -3))
+    (call $schedule-tk (cont.new $cont (ref.func $main)))
+    (call $log (i32.const -4))
+    (call $scheduler-ykt (cont.new $cont (ref.func $main)))
+    (call $log (i32.const -5))
+    (call $scheduler-ytk (cont.new $cont (ref.func $main)))
+    (call $log (i32.const -6))
+  )
+)
+
+(invoke "run")
+
diff --git a/proposals/continuations/examples/fun-pipes.wast b/proposals/continuations/examples/fun-pipes.wast
new file mode 100644
index 00000000..4c4008de
--- /dev/null
+++ b/proposals/continuations/examples/fun-pipes.wast
@@ -0,0 +1,88 @@
+;; Simple pipes example (functional version)
+(module $pipes
+  (type $pfun (func (result i32)))
+  (type $cfun (func (param i32) (result i32)))
+  (type $producer (cont $pfun))
+  (type $consumer (cont $cfun))
+
+  (tag $send (export "send") (param i32))
+  (tag $receive (export "receive") (result i32))
+
+  (func $piper (param $n i32) (param $p (ref $producer)) (param $c (ref $consumer))
+     (block $on-receive (result (ref $consumer))
+        (resume $consumer (tag $receive $on-receive) (local.get $n) (local.get $c))
+        (return)
+     ) ;; receive
+     (local.set $c)
+     (return_call $copiper (local.get $c) (local.get $p))
+  )
+
+  (func $copiper (param $c (ref $consumer)) (param $p (ref $producer))
+     (local $n i32)
+     (block $on-send (result i32 (ref $producer))
+        (resume $producer (tag $send $on-send) (local.get $p))
+        (return)
+     ) ;; send
+     (local.set $p)
+     (local.set $n)
+     (return_call $piper (local.get $n) (local.get $p) (local.get $c))
+  )
+
+  (func $pipe (export "pipe") (param $p (ref $producer)) (param $c (ref $consumer))
+     (call $piper (i32.const -1) (local.get $p) (local.get $c))
+  )
+)
+(register "pipes")
+
+(module
+  (type $pfun (func (result i32)))
+  (type $cfun (func (param i32) (result i32)))
+
+  (type $producer (cont $pfun))
+  (type $consumer (cont $cfun))
+
+  (tag $send (import "pipes" "send") (param i32))
+  (tag $receive (import "pipes" "receive") (result i32))
+
+  (func $pipe (import "pipes" "pipe") (param $p (ref $producer)) (param $c (ref $consumer)))
+
+  (func $log (import "spectest" "print_i32") (param i32))
+
+  (elem declare func $nats $sum)
+
+  ;; send n, n+1, ...
+  (func $nats (param $n i32) (result i32)
+     (loop $l
+       (call $log (i32.const -1))
+       (call $log (local.get $n))
+       (suspend $send (local.get $n))
+       (local.set $n (i32.add (local.get $n) (i32.const 1)))
+       (br $l)
+     )
+     (unreachable)
+  )
+
+  ;; receive 10 nats and return their sum
+  (func $sum (param $dummy i32) (result i32)
+     (local $i i32)
+     (local $a i32)
+     (local.set $i (i32.const 10))
+     (local.set $a (i32.const 0))
+     (loop $l
+       (local.set $a (i32.add (local.get $a) (suspend $receive)))
+       (call $log (i32.const -2))
+       (call $log (local.get $a))
+       (local.set $i (i32.sub (local.get $i) (i32.const 1)))
+       (br_if $l (i32.ne (local.get $i) (i32.const 0)))
+     )
+     (return (local.get $a))
+  )
+
+  (func (export "run") (param $n i32)
+     (call $pipe (cont.bind $consumer $producer (local.get $n) (cont.new $consumer (ref.func $nats)))
+                 (cont.new $consumer (ref.func $sum))
+     )
+ )
+)
+
+(invoke "run" (i32.const 0))
diff --git a/proposals/continuations/examples/fun-state.wast b/proposals/continuations/examples/fun-state.wast
new file mode 100644
index 00000000..440aaedf
--- /dev/null
+++ b/proposals/continuations/examples/fun-state.wast
@@ -0,0 +1,61 @@
+;; Simple state example - functional with heterogeneous continuations
+(module $state
+  (tag $get (result i32))
+  (tag $set (param i32))
+
+  (type $gf (func (param i32) (result i32)))
+  (type $sf (func (result i32)))
+
+  (type $gk (cont $gf))
+  (type $sk (cont $sf))
+
+  (func $getting (param $k (ref $gk)) (param $s i32) (result i32)
+     (block $on_get (result (ref $gk))
+       (block $on_set (result i32 (ref $sk))
+          (resume $gk (tag $get $on_get) (tag $set $on_set)
+            (local.get $s) (local.get $k)
+          )
+          (return)
+        ) ;;  $on_set (result i32 (ref $sk))
+        (return_call $setting)
+      ) ;;  $on_get (result (ref $gk))
+      (local.get $s)
+      (return_call $getting)
+  )
+
+  (func $setting (param $s i32) (param $k (ref $sk)) (result i32)
+     (block $on_get (result (ref $gk))
+       (block $on_set (result i32 (ref $sk))
+          (resume $sk (tag $get $on_get) (tag $set $on_set)
+            (local.get $k)
+          )
+          (return)
+        ) ;;  $on_set (result i32 (ref $sk))
+        (return_call $setting)
+      ) ;;  $on_get (result (ref $gk))
+      (local.get $s)
+      (return_call $getting)
+  )
+
+  (func $f (result i32)
+    (suspend $set (i32.const 7))
+    (i32.add
+      (suspend $get)
+      (i32.mul
+        (i32.const 2)
+        (suspend $set (i32.const 3))
+        (i32.add
+          (i32.const 3)
+          (suspend $get)
+        )
+      )
+    )
+  )
+
+  (elem declare func $f)
+  (func (export "run") (result i32)
+    (call $setting (i32.const 0) (cont.new $sk (ref.func $f)))
+  )
+)
+
+(assert_return (invoke "run") (i32.const 19))
diff --git a/proposals/continuations/examples/generators.wast b/proposals/continuations/examples/generators.wast
new file mode 100644
index 00000000..a7ce4e05
--- /dev/null
+++ b/proposals/continuations/examples/generators.wast
@@ -0,0 +1,166 @@
+;; Generators
+
+;; generator interface
+(module $generator
+  (tag $yield (export "yield") (param i32))
+)
+(register "generator")
+
+(module $examples
+  (type $func (func))
+  (type $cont (cont $func))
+
+  (tag $yield (import "generator" "yield") (param i32))
+
+  (func $log (import "spectest" "print_i32") (param i32))
+
+  ;; yields successive natural numbers
+  (func $naturals (export "naturals")
+    (local $n i32)
+    (loop $l
+      (suspend $yield (local.get $n))
+      (local.set $n (i32.add (local.get $n) (i32.const 1)))
+      (br $l)
+    )
+  )
+
+  ;; yields 1-2-3
+  (func $one-two-three (export "one-two-three")
+    (suspend $yield (i32.const 1))
+    (suspend $yield (i32.const 2))
+    (suspend $yield (i32.const 3))
+  )
+
+  ;; yields successive Fibonacci numbers
+  (func $fibonacci (export "fibonacci")
+    (local $a i32)
+    (local $b i32)
+    (local $t i32)
+    (local.set $b (i32.const 1))
+    (loop $l
+      (suspend $yield (local.get $a))
+      (local.set $t (local.get $a))
+      (local.set $a (local.get $b))
+      (local.set $b (i32.add (local.get $t) (local.get $a)))
+      (br $l)
+    )
+  )
+
+  (func $print-first (export "print-first") (param $n i32) (param $k (ref $cont))
+    (loop $l
+      (block $on_yield (result i32 (ref $cont))
+        (if (local.get $n)
+          (then (resume $cont (tag $yield $on_yield) (local.get $k)))
+        )
+        (return)
+      ) ;;   $on_yield (result i32 (ref $cont))
+      (local.set $k)
+      (call $log)
+      (local.set $n (i32.add (local.get $n) (i32.const -1)))
+      (br $l)
+    )
+    (unreachable)
+  )
+  
+  (func $sum-first (export "sum-first") (param $n i32) (param $k (ref $cont)) (result i32)
+    (local $sum i32)
+    (loop $l
+      (block $on_yield (result i32 (ref $cont))
+        (if (local.get $n)
+          (then (resume $cont (tag $yield $on_yield) (local.get $k)))
+        )
+        (return (local.get $sum))
+      ) ;;   $on_yield (result i32 (ref $cont))
+      (local.set $k)
+      (local.set $sum (i32.add (local.get $sum)))
+      (local.set $n (i32.add (local.get $n) (i32.const -1)))
+      (br $l)
+    )
+    (unreachable)
+  )
+)
+(register "examples")
+
+;; storing generators in a global table and then accessing them through i32 handles
+;; without knowledge of handlers
+(module $manager
+  (type $func (func))
+  (type $cont (cont $func))
+
+  (tag $yield (import "generator" "yield") (param i32))
+
+  (table $active 0 (ref null $cont))
+
+  (func $init (export "init") (param $k (ref $cont)) (result i32)
+    (table.grow $active (local.get $k) (i32.const 1))
+  )
+
+  (func $next (export "next") (param $g i32) (result i32)
+    (local $next_k (ref $cont))
+    (local $next_v i32)
+    (block $on_yield (result i32 (ref $cont))
+      (resume $cont (tag $yield $on_yield)
+                    (table.get $active (local.get $g))
+      )
+      (return (i32.const -1))
+    ) ;;   $on_yield (result i32 (ref $cont))
+    (local.set $next_k)
+    (local.set $next_v)
+    (table.set (local.get $g) (local.get $next_k))
+    (return (local.get $next_v))
+  )
+)
+(register "manager")
+
+(module
+  (type $func (func))
+  (type $cont (cont $func))
+
+  (elem declare func $naturals $fibonacci $one-two-three)
+
+  (func $log (import "spectest" "print_i32") (param i32))
+  (func $naturals (import "examples" "naturals"))
+  (func $fibonacci (import "examples" "fibonacci"))
+  (func $one-two-three (import "examples" "one-two-three"))
+  (func $print-first (import "examples" "print-first") (param $n i32) (param $k (ref $cont)))
+  (func $sum-first (import "examples" "sum-first") (param $n i32) (param $k (ref $cont)) (result i32))
+  (func $init (import "manager" "init") (param $k (ref $cont)) (result i32))
+  (func $next (import "manager" "next") (param i32) (result i32))
+
+  (func $print-with-next (param $n i32) (param $gen i32)
+    (loop $l
+      (if (i32.eqz (local.get $n)) (then (return)))
+      (call $next (local.get $gen))
+      (call $log)
+      (local.set $n (i32.add (local.get $n) (i32.const -1)))
+      (br $l)
+    )
+  )
+
+  (func $interleave-naturals-and-fib
+      (local $gen1 i32)
+      (local $gen2 i32)
+      (local.set $gen1 (call $init (cont.new $cont (ref.func $naturals))))
+      (local.set $gen2 (call $init (cont.new $cont (ref.func $fibonacci))))
+      (call $print-with-next (i32.const 5) (local.get $gen1))
+      (call $print-with-next (i32.const 5) (local.get $gen2))
+      (call $print-with-next (i32.const 5) (local.get $gen1))
+      (call $print-with-next (i32.const 5) (local.get $gen2))
+      (call $print-with-next (i32.const 5) (local.get $gen1))
+      (call $print-with-next (i32.const 5) (local.get $gen2))
+      (call $print-with-next (i32.const 5) (local.get $gen1))
+      (call $print-with-next (i32.const 5) (local.get $gen2))
+  )
+
+  (func $main (export "main")
+    (call $interleave-naturals-and-fib)
+    (call $print-first (i32.const 42) (cont.new $cont (ref.func $naturals)))
+    (call $print-first (i32.const 42) (cont.new $cont (ref.func $fibonacci)))
+    (call $sum-first (i32.const 101) (cont.new $cont (ref.func $naturals)))
+    (call $log)
+    (call $sum-first (i32.const 10) (cont.new $cont (ref.func $one-two-three)))
+    (call $log)
+  )
+)
+
+(invoke "main")
diff --git a/proposals/continuations/examples/lwt.wast b/proposals/continuations/examples/lwt.wast
new file mode 100644
index 00000000..65232d5b
--- /dev/null
+++ b/proposals/continuations/examples/lwt.wast
@@ -0,0 +1,294 @@
+;; dynamic lightweight threads
+
+;; interface to lightweight threads
+(module $lwt
+  (type $func (func))       ;; [] -> []
+  (type $cont (cont $func)) ;; cont ([] -> [])
+
+  (tag $yield (export "yield"))                   ;; [] -> []
+  (tag $fork (export "fork") (param (ref $cont))) ;; [cont ([] -> [])] -> []
+)
+(register "lwt")
+
+(module $example
+  (type $func (func))       ;; [] -> []
+  (type $cont (cont $func)) ;; cont ([] -> [])
+
+  (tag $yield (import "lwt" "yield"))                   ;; [] -> []
+  (tag $fork (import "lwt" "fork") (param (ref $cont))) ;; [cont ([] -> [])] -> []
+
+  (func $log (import "spectest" "print_i32") (param i32))
+
+  (elem declare func $thread1 $thread2 $thread3)
+
+  (func $main (export "main")
+    (call $log (i32.const 0))
+    (suspend $fork (cont.new $cont (ref.func $thread1)))
+    (call $log (i32.const 1))
+    (suspend $fork (cont.new $cont (ref.func $thread2)))
+    (call $log (i32.const 2))
+    (suspend $fork (cont.new $cont (ref.func $thread3)))
+    (call $log (i32.const 3))
+  )
+
+  (func $thread1
+    (call $log (i32.const 10))
+    (suspend $yield)
+    (call $log (i32.const 11))
+    (suspend $yield)
+    (call $log (i32.const 12))
+  )
+
+  (func $thread2
+    (call $log (i32.const 20))
+    (suspend $yield)
+    (call $log (i32.const 21))
+    (suspend $yield)
+    (call $log (i32.const 22))
+  )
+
+  (func $thread3
+    (call $log (i32.const 30))
+    (suspend $yield)
+    (call $log (i32.const 31))
+    (suspend $yield)
+    (call $log (i32.const 32))
+  )
+)
+(register "example")
+
+;; queue of threads
+(module $queue
+  (type $func (func))       ;; [] -> []
+  (type $cont (cont $func)) ;; cont ([] -> [])
+
+  ;; Table as simple queue (keeping it simple, no ring buffer)
+  (table $queue 0 (ref null $cont))
+  (global $qdelta i32 (i32.const 10))
+  (global $qback (mut i32) (i32.const 0))
+  (global $qfront (mut i32) (i32.const 0))
+
+  (func $queue-empty (export "queue-empty") (result i32)
+    (i32.eq (global.get $qfront) (global.get $qback))
+  )
+
+  (func $dequeue (export "dequeue") (result (ref null $cont))
+    (local $i i32)
+    (if (call $queue-empty)
+      (then (return (ref.null $cont)))
+    )
+    (local.set $i (global.get $qfront))
+    (global.set $qfront (i32.add (local.get $i) (i32.const 1)))
+    (table.get $queue (local.get $i))
+  )
+
+  (func $enqueue (export "enqueue") (param $k (ref null $cont))
+    ;; Check if queue is full
+    (if (i32.eq (global.get $qback) (table.size $queue))
+      (then
+        ;; Check if there is enough space in the front to compact
+        (if (i32.lt_u (global.get $qfront) (global.get $qdelta))
+          (then
+            ;; Space is below threshold, grow table instead
+            (drop (table.grow $queue (ref.null $cont) (global.get $qdelta)))
+          )
+          (else
+            ;; Enough space, move entries up to head of table
+            (global.set $qback (i32.sub (global.get $qback) (global.get $qfront)))
+            (table.copy $queue $queue
+              (i32.const 0)         ;; dest = new front = 0
+              (global.get $qfront)  ;; src = old front
+              (global.get $qback)   ;; len = new back = old back - old front
+            )
+            (table.fill $queue      ;; null out old entries to avoid leaks
+              (global.get $qback)   ;; start = new back
+              (ref.null $cont)      ;; init value
+              (global.get $qfront)  ;; len = old front = old front - new front
+            )
+            (global.set $qfront (i32.const 0))
+          )
+        )
+      )
+    )
+    (table.set $queue (global.get $qback) (local.get $k))
+    (global.set $qback (i32.add (global.get $qback) (i32.const 1)))
+  )
+)
+(register "queue")
+
+(module $scheduler
+  (type $func (func))       ;; [] -> []
+  (type $cont (cont $func)) ;; cont ([] -> [])
+
+  (tag $yield (import "lwt" "yield"))                   ;; [] -> []
+  (tag $fork (import "lwt" "fork") (param (ref $cont))) ;; [cont ([] -> [])] -> []
+
+  (func $queue-empty (import "queue" "queue-empty") (result i32))
+  (func $dequeue (import "queue" "dequeue") (result (ref null $cont)))
+  (func $enqueue (import "queue" "enqueue") (param $k (ref null $cont)))
+
+  ;; synchronous scheduler (run current thread to completion without
+  ;; yielding)
+  (func $sync (export "sync") (param $nextk (ref null $cont))
+    (loop $l
+      (if (ref.is_null (local.get $nextk)) (then (return)))
+      (block $on_yield (result (ref $cont))
+        (block $on_fork (result (ref $cont) (ref $cont))
+          (resume $cont
+            (tag $yield $on_yield)
+            (tag $fork $on_fork)
+            (local.get $nextk)
+          )
+          (local.set $nextk (call $dequeue))
+          (br $l)  ;; thread terminated
+        ) ;;   $on_fork (result (ref $cont) (ref $cont))
+        (local.set $nextk)                      ;; current thread
+        (call $enqueue) ;; new thread
+        (br $l)
+      ) ;;   $on_yield (result (ref $cont))
+      (local.set $nextk)  ;; carry on with current thread
+      (br $l)
+    )
+  )
+
+  ;; four asynchronous schedulers:
+  ;;   * kt and tk don't yield on encountering a fork
+  ;;     1) kt runs the continuation, queuing up the new thread for later
+  ;;     2) tk runs the new thread first, queuing up the continuation for later
+  ;;   * ykt and ytk do yield on encountering a fork
+  ;;     3) ykt runs the continuation, queuing up the new thread for later
+  ;;     4) ytk runs the new thread first, queuing up the continuation for later
+
+  ;; no yield on fork, continuation first
+  (func $kt (export "kt") (param $nextk (ref null $cont))
+    (loop $l
+      (if (ref.is_null (local.get $nextk)) (then (return)))
+      (block $on_yield (result (ref $cont))
+        (block $on_fork (result (ref $cont) (ref $cont))
+          (resume $cont
+            (tag $yield $on_yield)
+            (tag $fork $on_fork)
+            (local.get $nextk)
+          )
+          (local.set $nextk (call $dequeue))
+          (br $l)  ;; thread terminated
+        ) ;;   $on_fork (result (ref $cont) (ref $cont))
+        (local.set $nextk) ;; current thread
+        (call $enqueue) ;; new thread
+        (br $l)
+      ) ;;   $on_yield (result (ref $cont))
+      (call $enqueue) ;; current thread
+      (local.set $nextk (call $dequeue)) ;; next thread
+      (br $l)
+    )
+  )
+
+  ;; no yield on fork, new thread first
+  (func $tk (export "tk") (param $nextk (ref null $cont))
+    (loop $l
+      (if (ref.is_null (local.get $nextk)) (then (return)))
+      (block $on_yield (result (ref $cont))
+        (block $on_fork (result (ref $cont) (ref $cont))
+          (resume $cont
+            (tag $yield $on_yield)
+            (tag $fork $on_fork)
+            (local.get $nextk)
+          )
+          (local.set $nextk (call $dequeue))
+          (br $l)  ;; thread terminated
+        ) ;;   $on_fork (result (ref $cont) (ref $cont))
+        (call $enqueue) ;; current thread
+        (local.set $nextk) ;; new thread
+        (br $l)
+      ) ;;   $on_yield (result (ref $cont))
+      (call $enqueue) ;; current thread
+      (local.set $nextk (call $dequeue)) ;; next thread
+      (br $l)
+    )
+  )
+
+  ;; yield on fork, continuation first
+  (func $ykt (export "ykt") (param $nextk (ref null $cont))
+    (loop $l
+      (if (ref.is_null (local.get $nextk)) (then (return)))
+      (block $on_yield (result (ref $cont))
+        (block $on_fork (result (ref $cont) (ref $cont))
+          (resume $cont
+            (tag $yield $on_yield)
+            (tag $fork $on_fork)
+            (local.get $nextk)
+          )
+          (local.set $nextk (call $dequeue))
+          (br $l)  ;; thread terminated
+        ) ;;   $on_fork (result (ref $cont) (ref $cont))
+        (call $enqueue) ;; current thread
+        (call $enqueue) ;; new thread
+        (local.set $nextk (call $dequeue)) ;; next thread
+        (br $l)
+      ) ;;   $on_yield (result (ref $cont))
+      (call $enqueue) ;; current thread
+      (local.set $nextk (call $dequeue)) ;; next thread
+      (br $l)
+    )
+  )
+
+  ;; yield on fork, new thread first
+  (func $ytk (export "ytk") (param $nextk (ref null $cont))
+    (loop $l
+      (if (ref.is_null (local.get $nextk)) (then (return)))
+      (block $on_yield (result (ref $cont))
+        (block $on_fork (result (ref $cont) (ref $cont))
+          (resume $cont
+            (tag $yield $on_yield)
+            (tag $fork $on_fork)
+            (local.get $nextk)
+          )
+          (local.set $nextk (call $dequeue))
+          (br $l)  ;; thread terminated
+        ) ;;   $on_fork (result (ref $cont) (ref $cont))
+        (local.set $nextk)
+        (call $enqueue) ;; new thread
+        (call $enqueue (local.get $nextk)) ;; current thread
+        (local.set $nextk (call $dequeue)) ;; next thread
+        (br $l)
+      ) ;;   $on_yield (result (ref $cont))
+      (call $enqueue) ;; current thread
+      (local.set $nextk (call $dequeue)) ;; next thread
+      (br $l)
+    )
+  )
+)
+(register "scheduler")
+
+(module
+  (type $func (func))       ;; [] -> []
+  (type $cont (cont $func)) ;; cont ([] -> [])
+
+  (func $scheduler-sync (import "scheduler" "sync") (param $nextk (ref null $cont)))
+  (func $scheduler-kt (import "scheduler" "kt") (param $nextk (ref null $cont)))
+  (func $schedule-tk (import "scheduler" "tk") (param $nextk (ref null $cont)))
+  (func $scheduler-ykt (import "scheduler" "ykt") (param $nextk (ref null $cont)))
+  (func $scheduler-ytk (import "scheduler" "ytk") (param $nextk (ref null $cont)))
+
+  (func $log (import "spectest" "print_i32") (param i32))
+
+  (func $main (import "example" "main"))
+
+  (elem declare func $main)
+
+  (func (export "run")
+    (call $log (i32.const -1))
+    (call $scheduler-sync (cont.new $cont (ref.func $main)))
+    (call $log (i32.const -2))
+    (call $scheduler-kt (cont.new $cont (ref.func $main)))
+    (call $log (i32.const -3))
+    (call $schedule-tk (cont.new $cont (ref.func $main)))
+    (call $log (i32.const -4))
+    (call $scheduler-ykt (cont.new $cont (ref.func $main)))
+    (call $log (i32.const -5))
+    (call $scheduler-ytk (cont.new $cont (ref.func $main)))
+    (call $log (i32.const -6))
+  )
+)
+
+(invoke "run")
diff --git a/proposals/continuations/examples/pipes.wast b/proposals/continuations/examples/pipes.wast
new file mode 100644
index 00000000..e3581785
--- /dev/null
+++ b/proposals/continuations/examples/pipes.wast
@@ -0,0 +1,95 @@
+;; Simple pipes example
+(module $pipes
+  (type $pfun (func (result i32)))
+  (type $cfun (func (param i32) (result i32)))
+  (type $producer (cont $pfun))
+  (type $consumer (cont $cfun))
+
+  (tag $send (export "send") (param i32))
+  (tag $receive (export "receive") (result i32))
+
+  (func $piper (export "pipe") (param $p (ref $producer)) (param $c (ref $consumer))
+    (local $n i32)
+    (local $consuming i32)
+
+    (local.set $n (i32.const -1))
+    (local.set $consuming (i32.const 1))
+
+    (loop $l
+      (if (local.get $consuming)
+        (then
+           (block $on-receive (result (ref $consumer))
+             (resume $consumer (tag $receive $on-receive) (local.get $n) (local.get $c))
+             (return)
+           ) ;; receive
+           (local.set $c)
+           (local.set $consuming (i32.const 0))
+           (br $l)
+        )
+      ) ;; else producing
+           (block $on-send (result i32 (ref $producer))
+             (resume $producer (tag $send $on-send) (local.get $p))
+             (return)
+           ) ;; send
+           (local.set $p)
+           (local.set $n)
+           (local.set $consuming (i32.const 1))
+           (br $l)
+    )
+  )
+)
+
+(register "pipes")
+
+(module
+  (type $pfun (func (result i32)))
+  (type $cfun (func (param i32) (result i32)))
+
+  (type $producer (cont $pfun))
+  (type $consumer (cont $cfun))
+
+  (tag $send (import "pipes" "send") (param i32))
+  (tag $receive (import "pipes" "receive") (result i32))
+
+  (func $pipe (import "pipes" "pipe") (param $p (ref $producer)) (param $c (ref $consumer)))
+
+  (func $log (import "spectest" "print_i32") (param i32))
+
+  (elem declare func $nats $sum)
+
+  ;; send n, n+1, ...
+  (func $nats (param $n i32) (result i32)
+     (loop $l
+       (call $log (i32.const -1))
+       (call $log (local.get $n))
+       (suspend $send (local.get $n))
+       (local.set $n (i32.add (local.get $n) (i32.const 1)))
+       (br $l)
+     )
+     (unreachable)
+  )
+
+  ;; receive 10 nats and return their sum
+  (func $sum (param $dummy i32) (result i32)
+     (local $i i32)
+     (local $a i32)
+     (local.set $i (i32.const 10))
+     (local.set $a (i32.const 0))
+     (loop $l
+       (local.set $a (i32.add (local.get $a) (suspend $receive)))
+       (call $log (i32.const -2))
+       (call $log (local.get $a))
+       (local.set $i (i32.sub (local.get $i) (i32.const 1)))
+       (br_if $l (i32.ne (local.get $i) (i32.const 0)))
+     )
+     (return (local.get $a))
+  )
+
+  (func (export "run") (param $n i32)
+     (call $pipe (cont.bind $consumer $producer (local.get $n) (cont.new $consumer (ref.func $nats)))
+                 (cont.new $consumer (ref.func $sum))
+     )
+ )
+)
+
+(invoke "run" (i32.const 0))
diff --git a/proposals/continuations/examples/static-lwt.wast b/proposals/continuations/examples/static-lwt.wast
new file mode 100644
index 00000000..22bd0f34
--- /dev/null
+++ b/proposals/continuations/examples/static-lwt.wast
@@ -0,0 +1,151 @@
+;; static lightweight threads
+
+;; interface to a fixed collection of lightweight threads
+(module $lwt
+  (tag $yield (export "yield"))
+)
+(register "lwt")
+
+(module $example
+  (tag $yield (import "lwt" "yield"))
+  (func $log (import "spectest" "print_i32") (param i32))
+
+  (func $thread1 (export "thread1")
+    (call $log (i32.const 10))
+    (suspend $yield)
+    (call $log (i32.const 11))
+    (suspend $yield)
+    (call $log (i32.const 12))
+  )
+
+  (func $thread2 (export "thread2")
+    (call $log (i32.const 20))
+    (suspend $yield)
+    (call $log (i32.const 21))
+    (suspend $yield)
+    (call $log (i32.const 22))
+  )
+
+  (func $thread3 (export "thread3")
+    (call $log (i32.const 30))
+    (suspend $yield)
+    (call $log (i32.const 31))
+    (suspend $yield)
+    (call $log (i32.const 32))
+  )
+)
+(register "example")
+
+;; queue of threads
+(module $queue
+  (type $func (func))
+  (type $cont (cont $func))
+
+  ;; Table as simple queue (keeping it simple, no ring buffer)
+  (table $queue 0 (ref null $cont))
+  (global $qdelta i32 (i32.const 10))
+  (global $qback (mut i32) (i32.const 0))
+  (global $qfront (mut i32) (i32.const 0))
+
+  (func $queue-empty (export "queue-empty") (result i32)
+    (i32.eq (global.get $qfront) (global.get $qback))
+  )
+
+  (func $dequeue (export "dequeue") (result (ref null $cont))
+    (local $i i32)
+    (if (call $queue-empty)
+      (then (return (ref.null $cont)))
+    )
+    (local.set $i (global.get $qfront))
+    (global.set $qfront (i32.add (local.get $i) (i32.const 1)))
+    (table.get $queue (local.get $i))
+  )
+
+  (func $enqueue (export "enqueue") (param $k (ref $cont))
+    ;; Check if queue is full
+    (if (i32.eq (global.get $qback) (table.size $queue))
+      (then
+        ;; Check if there is enough space in the front to compact
+        (if (i32.lt_u (global.get $qfront) (global.get $qdelta))
+          (then
+            ;; Space is below threshold, grow table instead
+            (drop (table.grow $queue (ref.null $cont) (global.get $qdelta)))
+          )
+          (else
+            ;; Enough space, move entries up to head of table
+            (global.set $qback (i32.sub (global.get $qback) (global.get $qfront)))
+            (table.copy $queue $queue
+              (i32.const 0)         ;; dest = new front = 0
+              (global.get $qfront)  ;; src = old front
+              (global.get $qback)   ;; len = new back = old back - old front
+            )
+            (table.fill $queue      ;; null out old entries to avoid leaks
+              (global.get $qback)   ;; start = new back
+              (ref.null $cont)      ;; init value
+              (global.get $qfront)  ;; len = old front = old front - new front
+            )
+            (global.set $qfront (i32.const 0))
+          )
+        )
+      )
+    )
+    (table.set $queue (global.get $qback) (local.get $k))
+    (global.set $qback (i32.add (global.get $qback) (i32.const 1)))
+  )
+)
+(register "queue")
+
+(module $scheduler
+  (type $func (func))
+  (type $cont (cont $func))
+
+  (tag $yield (import "lwt" "yield"))
+
+  ;; queue interface
+  (func $queue-empty (import "queue" "queue-empty") (result i32))
+  (func $dequeue (import "queue" "dequeue") (result (ref null $cont)))
+  (func $enqueue (import "queue" "enqueue") (param $k (ref $cont)))
+
+  (func $run (export "run")
+    (loop $l
+      (if (call $queue-empty) (then (return)))
+      (block $on_yield (result (ref $cont))
+        (resume $cont (tag $yield $on_yield)
+                      (call $dequeue)
+        )
+        (br $l)  ;; thread terminated
+      ) ;;   $on_yield (result (ref $cont))
+      (call $enqueue)  ;; continuation of current thread
+      (br $l)
+    )
+  )
+)
+(register "scheduler")
+
+(module
+  (type $func (func))
+  (type $cont (cont $func))
+
+  (func $scheduler (import "scheduler" "run"))
+  (func $enqueue (import "queue" "enqueue") (param (ref $cont)))
+
+  (func $log (import "spectest" "print_i32") (param i32))
+
+  (func $thread1 (import "example" "thread1"))
+  (func $thread2 (import "example" "thread2"))
+  (func $thread3 (import "example" "thread3"))
+
+  (elem declare func $thread1 $thread2 $thread3)
+
+  (func (export "run")
+    (call $enqueue (cont.new $cont (ref.func $thread1)))
+    (call $enqueue (cont.new $cont (ref.func $thread2)))
+    (call $enqueue (cont.new $cont (ref.func $thread3)))
+
+    (call $log (i32.const -1))
+    (call $scheduler)
+    (call $log (i32.const -2))
+  )
+)
+
+(invoke "run")
diff --git a/proposals/function-references/Overview.md b/proposals/function-references/Overview.md
index eb32bc37..57947c5a 100644
--- a/proposals/function-references/Overview.md
+++ b/proposals/function-references/Overview.md
@@ -62,9 +62,9 @@ The function `$hof` takes a function pointer as parameter, and is invoked by `$c
 
 It is also possible to create a typed function table:
 ```wasm
-(table 1 (ref $i32-i32) (ref.func $inc))
+(table 0 (ref $i32-i32))
 ```
-Such a table can neither contain `null` entries nor functions of another type. Because entries can't be `null`, tables of concrete type are required to be declared with an explicit initialisation value. Any use of `call_indirect` on this table does hence avoid all runtime checks beyond the basic bounds check. By using multiple tables, each one can be given a homogeneous type. The table can be initialised with an initializer or by growing it.
+Such a table can neither contain `null` entries nor functions of another type. Any use of `call_indirect` on this table does hence avoid all runtime checks beyond the basic bounds check. By using multiple tables, each one can be given a homogeneous type. The table can be initialised with an initializer or by growing it.
 
 Typed function references are a subtype of `funcref`, so they can also be used as untyped references. All previous uses of `ref.func` remain valid:
 ```wasm
diff --git a/test/core/binary.wast b/test/core/binary.wast
index 464dffec..61296d8d 100644
--- a/test/core/binary.wast
+++ b/test/core/binary.wast
@@ -1385,7 +1385,7 @@
       "\02\04\01"                           ;; import section with single entry
       "\00"                                 ;; string length 0
       "\00"                                 ;; string length 0
-      "\04"                                 ;; malformed import kind
+      "\05"                                 ;; malformed import kind
   )
   "malformed import kind"
 )
@@ -1395,7 +1395,7 @@
       "\02\05\01"                           ;; import section with single entry
       "\00"                                 ;; string length 0
       "\00"                                 ;; string length 0
-      "\04"                                 ;; malformed import kind
+      "\05"                                 ;; malformed import kind
       "\00"                                 ;; dummy byte
   )
   "malformed import kind"
diff --git a/test/core/cont.wast b/test/core/cont.wast
new file mode 100644
index 00000000..041c4ab3
--- /dev/null
+++ b/test/core/cont.wast
@@ -0,0 +1,546 @@
+;; Unhandled tags & guards
+
+(module
+  (tag $exn)
+  (tag $e1)
+  (tag $e2)
+
+  (type $f1 (func))
+  (type $k1 (cont $f1))
+
+  (func $f1 (export "unhandled-1")
+    (suspend $e1)
+  )
+
+  (func (export "unhandled-2")
+    (resume $k1 (cont.new $k1 (ref.func $f1)))
+  )
+
+  (func (export "unhandled-3")
+    (block $h (result (ref $k1))
+      (resume $k1 (tag $e2 $h) (cont.new $k1 (ref.func $f1)))
+      (unreachable)
+    )
+    (drop)
+  )
+
+  (func (export "handled")
+    (block $h (result (ref $k1))
+      (resume $k1 (tag $e1 $h) (cont.new $k1 (ref.func $f1)))
+      (unreachable)
+    )
+    (drop)
+  )
+
+  (elem declare func $f2)
+  (func $f2
+    (throw $exn)
+  )
+
+  (func (export "uncaught-1")
+    (block $h (result (ref $k1))
+      (resume $k1 (tag $e1 $h) (cont.new $k1 (ref.func $f2)))
+      (unreachable)
+    )
+    (drop)
+  )
+
+  (func (export "uncaught-2")
+    (block $h (result (ref $k1))
+      (resume $k1 (tag $e1 $h) (cont.new $k1 (ref.func $f1)))
+      (unreachable)
+    )
+    (resume_throw $k1 $exn)
+  )
+
+  (elem declare func $f3)
+  (func $f3
+    (barrier (call $f4))
+  )
+  (func $f4
+    (suspend $e1)
+  )
+
+  (func (export "barrier")
+    (block $h (result (ref $k1))
+      (resume $k1 (tag $e1 $h) (cont.new $k1 (ref.func $f3)))
+      (unreachable)
+    )
+    (resume_throw $k1 $exn)
+  )
+
+  (elem declare func $r0 $r1)
+  (func $r0)
+  (func $r1 (suspend $e1) (suspend $e1))
+
+  (func $nl1 (param $k (ref $k1))
+    (resume $k1 (local.get $k))
+    (resume $k1 (local.get $k))
+  )
+  (func $nl2 (param $k (ref $k1))
+    (block $h (result (ref $k1))
+      (resume $k1 (tag $e1 $h) (local.get $k))
+      (unreachable)
+    )
+    (resume $k1 (local.get $k))
+    (unreachable)
+  )
+  (func $nl3 (param $k (ref $k1))
+    (local $k' (ref null $k1))
+    (block $h1 (result (ref $k1))
+      (resume $k1 (tag $e1 $h1) (local.get $k))
+      (unreachable)
+    )
+    (local.set $k')
+    (block $h2 (result (ref $k1))
+      (resume $k1 (tag $e1 $h2) (local.get $k'))
+      (unreachable)
+    )
+    (resume $k1 (local.get $k'))
+    (unreachable)
+  )
+  (func $nl4 (param $k (ref $k1))
+    (drop (cont.bind $k1 $k1 (local.get $k)))
+    (resume $k1 (local.get $k))
+  )
+
+  (func (export "non-linear-1")
+    (call $nl1 (cont.new $k1 (ref.func $r0)))
+  )
+  (func (export "non-linear-2")
+    (call $nl2 (cont.new $k1 (ref.func $r1)))
+  )
+  (func (export "non-linear-3")
+    (call $nl3 (cont.new $k1 (ref.func $r1)))
+  )
+  (func (export "non-linear-4")
+    (call $nl4 (cont.new $k1 (ref.func $r1)))
+  )
+)
+
+(assert_suspension (invoke "unhandled-1") "unhandled")
+(assert_suspension (invoke "unhandled-2") "unhandled")
+(assert_suspension (invoke "unhandled-3") "unhandled")
+(assert_return (invoke "handled"))
+
+(assert_exception (invoke "uncaught-1") "unhandled")
+(assert_exception (invoke "uncaught-2") "unhandled")
+
+(assert_trap (invoke "barrier") "barrier")
+
+(assert_trap (invoke "non-linear-1") "continuation already consumed")
+(assert_trap (invoke "non-linear-2") "continuation already consumed")
+(assert_trap (invoke "non-linear-3") "continuation already consumed")
+(assert_trap (invoke "non-linear-4") "continuation already consumed")
+
+
+;; Simple state example
+
+(module $state
+  (tag $get (result i32))
+  (tag $set (param i32) (result i32))
+
+  (type $f (func (param i32) (result i32)))
+  (type $k (cont $f))
+
+  (func $runner (param $s i32) (param $k (ref $k)) (result i32)
+    (loop $loop
+      (block $on_get (result (ref $k))
+        (block $on_set (result i32 (ref $k))
+          (resume $k (tag $get $on_get) (tag $set $on_set)
+            (local.get $s) (local.get $k)
+          )
+          (return)
+        )
+        ;; on set
+        (local.set $k)
+        (local.set $s)
+        (br $loop)
+      )
+      ;; on get
+      (local.set $k)
+      (br $loop)
+    )
+    (unreachable)
+  )
+
+  (func $f (param i32) (result i32)
+    (drop (suspend $set (i32.const 7)))
+    (i32.add
+      (suspend $get)
+      (i32.mul
+        (i32.const 2)
+        (i32.add
+          (suspend $set (i32.const 3))
+          (suspend $get)
+        )
+      )
+    )
+  )
+
+  (elem declare func $f)
+  (func (export "run") (result i32)
+    (call $runner (i32.const 0) (cont.new $k (ref.func $f)))
+  )
+)
+
+(assert_return (invoke "run") (i32.const 19))
+
+
+;; Simple generator example
+
+(module $generator
+  (type $gen (func (param i64)))
+  (type $geny (func (param i32)))
+  (type $cont0 (cont $gen))
+  (type $cont (cont $geny))
+
+  (tag $yield (param i64) (result i32))
+
+  ;; Hook for logging purposes
+  (global $hook (export "hook") (mut (ref $gen)) (ref.func $dummy))
+  (func $dummy (param i64))
+
+  (func $gen (export "start") (param $i i64)
+    (loop $l
+      (br_if 1 (suspend $yield (local.get $i)))
+      (call_ref $gen (local.get $i) (global.get $hook))
+      (local.set $i (i64.add (local.get $i) (i64.const 1)))
+      (br $l)
+    )
+  )
+
+  (elem declare func $gen)
+
+  (func (export "sum") (param $i i64) (param $j i64) (result i64)
+    (local $sum i64)
+    (local $n i64)
+    (local $k (ref null $cont))
+    (local.get $i)
+    (cont.new $cont0 (ref.func $gen))
+    (block $on_first_yield (param i64 (ref $cont0)) (result i64 (ref $cont))
+      (resume $cont0 (tag $yield $on_first_yield))
+      (unreachable)
+    )
+    (loop $on_yield (param i64) (param (ref $cont))
+      (local.set $k)
+      (local.set $n)
+      (local.set $sum (i64.add (local.get $sum) (local.get $n)))
+      (i64.eq (local.get $n) (local.get $j))
+      (local.get $k)
+      (resume $cont (tag $yield $on_yield))
+    )
+    (return (local.get $sum))
+  )
+)
+
+(register "generator")
+
+(assert_return (invoke "sum" (i64.const 0) (i64.const 0)) (i64.const 0))
+(assert_return (invoke "sum" (i64.const 2) (i64.const 2)) (i64.const 2))
+(assert_return (invoke "sum" (i64.const 0) (i64.const 3)) (i64.const 6))
+(assert_return (invoke "sum" (i64.const 1) (i64.const 10)) (i64.const 55))
+(assert_return (invoke "sum" (i64.const 100) (i64.const 2000)) (i64.const 1_996_050))
+
+
+;; Simple scheduler example
+
+(module $scheduler
+  (type $proc (func))
+  (type $cont (cont $proc))
+
+  (tag $yield (export "yield"))
+  (tag $spawn (export "spawn") (param (ref $cont)))
+
+  ;; Table as simple queue (keeping it simple, no ring buffer)
+  (table $queue 0 (ref null $cont))
+  (global $qdelta i32 (i32.const 10))
+  (global $qback (mut i32) (i32.const 0))
+  (global $qfront (mut i32) (i32.const 0))
+
+  (func $queue-empty (result i32)
+    (i32.eq (global.get $qfront) (global.get $qback))
+  )
+
+  (func $dequeue (result (ref null $cont))
+    (local $i i32)
+    (if (call $queue-empty)
+      (then (return (ref.null $cont)))
+    )
+    (local.set $i (global.get $qfront))
+    (global.set $qfront (i32.add (local.get $i) (i32.const 1)))
+    (table.get $queue (local.get $i))
+  )
+
+  (func $enqueue (param $k (ref $cont))
+    ;; Check if queue is full
+    (if (i32.eq (global.get $qback) (table.size $queue))
+      (then
+        ;; Check if there is enough space in the front to compact
+        (if (i32.lt_u (global.get $qfront) (global.get $qdelta))
+          (then
+            ;; Space is below threshold, grow table instead
+            (drop (table.grow $queue (ref.null $cont) (global.get $qdelta)))
+          )
+          (else
+            ;; Enough space, move entries up to head of table
+            (global.set $qback (i32.sub (global.get $qback) (global.get $qfront)))
+            (table.copy $queue $queue
+              (i32.const 0)         ;; dest = new front = 0
+              (global.get $qfront)  ;; src = old front
+              (global.get $qback)   ;; len = new back = old back - old front
+            )
+            (table.fill $queue      ;; null out old entries to avoid leaks
+              (global.get $qback)   ;; start = new back
+              (ref.null $cont)      ;; init value
+              (global.get $qfront)  ;; len = old front = old front - new front
+            )
+            (global.set $qfront (i32.const 0))
+          )
+        )
+      )
+    )
+    (table.set $queue (global.get $qback) (local.get $k))
+    (global.set $qback (i32.add (global.get $qback) (i32.const 1)))
+  )
+
+  (func $scheduler (export "scheduler") (param $main (ref $cont))
+    (call $enqueue (local.get $main))
+    (loop $l
+      (if (call $queue-empty) (then (return)))
+      (block $on_yield (result (ref $cont))
+        (block $on_spawn (result (ref $cont) (ref $cont))
+          (resume $cont (tag $yield $on_yield) (tag $spawn $on_spawn)
+            (call $dequeue)
+          )
+          (br $l)  ;; thread terminated
+        )
+        ;; on $spawn, proc and cont on stack
+        (call $enqueue)             ;; continuation of old thread
+        (call $enqueue)             ;; new thread
+        (br $l)
+      )
+      ;; on $yield, cont on stack
+      (call $enqueue)
+      (br $l)
+    )
+  )
+)
+
+(register "scheduler")
+
+(module
+  (type $proc (func))
+  (type $pproc (func (param i32))) ;; parameterised proc
+  (type $cont (cont $proc))
+  (type $pcont (cont $pproc)) ;; parameterised continuation proc
+  (tag $yield (import "scheduler" "yield"))
+  (tag $spawn (import "scheduler" "spawn") (param (ref $cont)))
+  (func $scheduler (import "scheduler" "scheduler") (param $main (ref $cont)))
+
+  (func $log (import "spectest" "print_i32") (param i32))
+
+  (global $width (mut i32) (i32.const 0))
+  (global $depth (mut i32) (i32.const 0))
+
+  (elem declare func $main $thread1 $thread2 $thread3)
+
+  (func $main
+    (call $log (i32.const 0))
+    (suspend $spawn (cont.new $cont (ref.func $thread1)))
+    (call $log (i32.const 1))
+    (suspend $spawn (cont.bind $pcont $cont (global.get $depth) (cont.new $pcont (ref.func $thread2))))
+    (call $log (i32.const 2))
+    (suspend $spawn (cont.new $cont (ref.func $thread3)))
+    (call $log (i32.const 3))
+  )
+
+  (func $thread1
+    (call $log (i32.const 10))
+    (suspend $yield)
+    (call $log (i32.const 11))
+    (suspend $yield)
+    (call $log (i32.const 12))
+    (suspend $yield)
+    (call $log (i32.const 13))
+  )
+
+  (func $thread2 (param $d i32)
+    (local $w i32)
+    (local.set $w (global.get $width))
+    (call $log (i32.const 20))
+    (br_if 0 (i32.eqz (local.get $d)))
+    (call $log (i32.const 21))
+    (loop $l
+      (if (local.get $w)
+        (then
+          (call $log (i32.const 22))
+          (suspend $yield)
+          (call $log (i32.const 23))
+          (suspend $spawn
+            (cont.bind $pcont $cont
+              (i32.sub (local.get $d) (i32.const 1))
+              (cont.new $pcont (ref.func $thread2))
+            )
+          )
+          (call $log (i32.const 24))
+          (local.set $w (i32.sub (local.get $w) (i32.const 1)))
+          (br $l)
+        )
+      )
+    )
+    (call $log (i32.const 25))
+  )
+
+  (func $thread3
+    (call $log (i32.const 30))
+    (suspend $yield)
+    (call $log (i32.const 31))
+    (suspend $yield)
+    (call $log (i32.const 32))
+  )
+
+  (func (export "run") (param $width i32) (param $depth i32)
+    (global.set $depth (local.get $depth))
+    (global.set $width (local.get $width))
+    (call $log (i32.const -1))
+    (call $scheduler (cont.new $cont (ref.func $main)))
+    (call $log (i32.const -2))
+  )
+)
+
+(assert_return (invoke "run" (i32.const 0) (i32.const 0)))
+(assert_return (invoke "run" (i32.const 0) (i32.const 1)))
+(assert_return (invoke "run" (i32.const 1) (i32.const 0)))
+(assert_return (invoke "run" (i32.const 1) (i32.const 1)))
+(assert_return (invoke "run" (i32.const 3) (i32.const 4)))
+
+
+;; Nested example: generator in a thread
+
+(module $concurrent-generator
+  (func $log (import "spectest" "print_i64") (param i64))
+
+  (tag $syield (import "scheduler" "yield"))
+  (tag $spawn (import "scheduler" "spawn") (param (ref $cont)))
+  (func $scheduler (import "scheduler" "scheduler") (param $main (ref $cont)))
+
+  (type $ghook (func (param i64)))
+  (func $gsum (import "generator" "sum") (param i64 i64) (result i64))
+  (global $ghook (import "generator" "hook") (mut (ref $ghook)))
+
+  (global $result (mut i64) (i64.const 0))
+  (global $done (mut i32) (i32.const 0))
+
+  (elem declare func $main $bg-thread $syield)
+
+  (func $syield (param $i i64)
+    (call $log (local.get $i))
+    (suspend $syield)
+  )
+
+  (func $bg-thread
+    (call $log (i64.const -10))
+    (loop $l
+      (call $log (i64.const -11))
+      (suspend $syield)
+      (br_if $l (i32.eqz (global.get $done)))
+    )
+    (call $log (i64.const -12))
+  )
+
+  (func $main (param $i i64) (param $j i64)
+    (suspend $spawn (cont.new $cont (ref.func $bg-thread)))
+    (global.set $ghook (ref.func $syield))
+    (global.set $result (call $gsum (local.get $i) (local.get $j)))
+    (global.set $done (i32.const 1))
+  )
+
+  (type $proc (func))
+  (type $pproc (func (param i64 i64)))
+  (type $cont (cont $proc))
+  (type $pcont (cont $pproc))
+  (func (export "sum") (param $i i64) (param $j i64) (result i64)
+    (call $log (i64.const -1))
+    (call $scheduler
+      (cont.bind $pcont $cont (local.get $i) (local.get $j) (cont.new $pcont (ref.func $main)))
+    )
+    (call $log (i64.const -2))
+    (global.get $result)
+  )
+)
+
+(assert_return (invoke "sum" (i64.const 10) (i64.const 20)) (i64.const 165))
+
+
+;; cont.bind
+
+(module
+  (type $f2 (func (param i32 i32) (result i32 i32 i32 i32 i32 i32)))
+  (type $f4 (func (param i32 i32 i32 i32) (result i32 i32 i32 i32 i32 i32)))
+  (type $f6 (func (param i32 i32 i32 i32 i32 i32) (result i32 i32 i32 i32 i32 i32)))
+
+  (type $k2 (cont $f2))
+  (type $k4 (cont $f4))
+  (type $k6 (cont $f6))
+
+  (elem declare func $f)
+  (func $f (param i32 i32 i32 i32 i32 i32) (result i32 i32 i32 i32 i32 i32)
+    (local.get 0) (local.get 1) (local.get 2)
+    (local.get 3) (local.get 4) (local.get 5)
+  )
+
+  (func (export "run") (result i32 i32 i32 i32 i32 i32)
+    (local $k6 (ref null $k6))
+    (local $k4 (ref null $k4))
+    (local $k2 (ref null $k2))
+    (local.set $k6 (cont.new $k6 (ref.func $f)))
+    (local.set $k4 (cont.bind $k6 $k4 (i32.const 1) (i32.const 2) (local.get $k6)))
+    (local.set $k2 (cont.bind $k4 $k2 (i32.const 3) (i32.const 4) (local.get $k4)))
+    (resume $k2 (i32.const 5) (i32.const 6) (local.get $k2))
+  )
+)
+
+(assert_return (invoke "run")
+  (i32.const 1) (i32.const 2) (i32.const 3)
+  (i32.const 4) (i32.const 5) (i32.const 6)
+)
+
+
+(module
+  (tag $e (result i32 i32 i32 i32 i32 i32))
+
+  (type $f0 (func (result i32 i32 i32 i32 i32 i32 i32)))
+  (type $f2 (func (param i32 i32) (result i32 i32 i32 i32 i32 i32 i32)))
+  (type $f4 (func (param i32 i32 i32 i32) (result i32 i32 i32 i32 i32 i32 i32)))
+  (type $f6 (func (param i32 i32 i32 i32 i32 i32) (result i32 i32 i32 i32 i32 i32 i32)))
+
+  (type $k0 (cont $f0))
+  (type $k2 (cont $f2))
+  (type $k4 (cont $f4))
+  (type $k6 (cont $f6))
+
+  (elem declare func $f)
+  (func $f (result i32 i32 i32 i32 i32 i32 i32)
+    (i32.const 0) (suspend $e)
+  )
+
+  (func (export "run") (result i32 i32 i32 i32 i32 i32 i32)
+    (local $k6 (ref null $k6))
+    (local $k4 (ref null $k4))
+    (local $k2 (ref null $k2))
+    (block $l (result (ref $k6))
+      (resume $k0 (tag $e $l) (cont.new $k0 (ref.func $f)))
+      (unreachable)
+    )
+    (local.set $k6)
+    (local.set $k4 (cont.bind $k6 $k4 (i32.const 1) (i32.const 2) (local.get $k6)))
+    (local.set $k2 (cont.bind $k4 $k2 (i32.const 3) (i32.const 4) (local.get $k4)))
+    (resume $k2 (i32.const 5) (i32.const 6) (local.get $k2))
+  )
+)
+
+(assert_return (invoke "run")
+  (i32.const 0) (i32.const 1) (i32.const 2) (i32.const 3)
+  (i32.const 4) (i32.const 5) (i32.const 6)
+)
diff --git a/test/core/data.wast b/test/core/data.wast
index a5c87fbb..b1e12397 100644
--- a/test/core/data.wast
+++ b/test/core/data.wast
@@ -81,8 +81,14 @@
   (data (global.get $g) "a")
 )
 
-(module (memory 1) (global i32 (i32.const 0)) (data (global.get 0) "a"))
-(module (memory 1) (global $g i32 (i32.const 0)) (data (global.get $g) "a"))
+(assert_invalid
+  (module (memory 1) (global i32 (i32.const 0)) (data (global.get 0) "a"))
+  "unknown global"
+)
+(assert_invalid
+  (module (memory 1) (global $g i32 (i32.const 0)) (data (global.get $g) "a"))
+  "unknown global"
+)
 
 
 ;; Corner cases
diff --git a/test/core/elem.wast b/test/core/elem.wast
index 6eef1b15..5857ae8b 100644
--- a/test/core/elem.wast
+++ b/test/core/elem.wast
@@ -167,8 +167,14 @@
 (assert_return (invoke "call-7") (i32.const 65))
 (assert_return (invoke "call-9") (i32.const 66))
 
-(module (table 1 funcref) (global i32 (i32.const 0)) (elem (global.get 0) $f) (func $f))
-(module (table 1 funcref) (global $g i32 (i32.const 0)) (elem (global.get $g) $f) (func $f))
+(assert_invalid
+  (module (table 1 funcref) (global i32 (i32.const 0)) (elem (global.get 0) $f) (func $f))
+  "unknown global"
+)
+(assert_invalid
+  (module (table 1 funcref) (global $g i32 (i32.const 0)) (elem (global.get $g) $f) (func $f))
+  "unknown global"
+)
 
 
 ;; Corner cases
diff --git a/test/core/global.wast b/test/core/global.wast
index 621de798..03d8b117 100644
--- a/test/core/global.wast
+++ b/test/core/global.wast
@@ -348,8 +348,14 @@
   "unknown global"
 )
 
-(module (global i32 (i32.const 0)) (global i32 (global.get 0)))
-(module (global $g i32 (i32.const 0)) (global i32 (global.get $g)))
+(assert_invalid
+  (module (global i32 (i32.const 0)) (global i32 (global.get 0)))
+  "unknown global"
+)
+(assert_invalid
+  (module (global $g i32 (i32.const 0)) (global i32 (global.get $g)))
+  "unknown global"
+)
 
 (assert_invalid
   (module (global i32 (global.get 1)) (global i32 (i32.const 0)))
diff --git a/test/core/table.wast b/test/core/table.wast
index 1142c784..16e35a80 100644
--- a/test/core/table.wast
+++ b/test/core/table.wast
@@ -95,31 +95,6 @@
 (assert_return (invoke "get3") (ref.func))
 
 
-(assert_invalid
-  (module
-    (type $f (func))
-    (table 10 (ref $f))
-  )
-  "type mismatch"
-)
-
-(assert_invalid
-  (module
-    (type $f (func))
-    (table 0 (ref $f))
-  )
-  "type mismatch"
-)
-
-(assert_invalid
-  (module
-    (type $f (func))
-    (table 0 0 (ref $f))
-  )
-  "type mismatch"
-)
-
-
 ;; Duplicate table identifiers
 
 (assert_malformed
diff --git a/test/core/try_catch.wast b/test/core/try_catch.wast
new file mode 100644
index 00000000..8ab9096b
--- /dev/null
+++ b/test/core/try_catch.wast
@@ -0,0 +1,242 @@
+;; Test try-catch blocks.
+
+(module
+  (tag $e0 (export "e0"))
+  (func (export "throw") (throw $e0))
+)
+
+(register "test")
+
+(module
+  (tag $imported-e0 (import "test" "e0"))
+  (func $imported-throw (import "test" "throw"))
+  (tag $e0)
+  (tag $e1)
+  (tag $e2)
+  (tag $e-i32 (param i32))
+  (tag $e-f32 (param f32))
+  (tag $e-i64 (param i64))
+  (tag $e-f64 (param f64))
+
+  (func $throw-if (param i32) (result i32)
+    (local.get 0)
+    (i32.const 0) (if (i32.ne) (then (throw $e0)))
+    (i32.const 0)
+  )
+
+  (func (export "empty-catch") (try (do) (catch $e0)))
+
+  (func (export "simple-throw-catch") (param i32) (result i32)
+    (try (result i32)
+      (do (local.get 0) (i32.eqz) (if (then (throw $e0)) (else)) (i32.const 42))
+      (catch $e0 (i32.const 23))
+    )
+  )
+
+  (func (export "unreachable-not-caught") (try (do (unreachable)) (catch_all)))
+
+  (func $div (param i32 i32) (result i32)
+    (local.get 0) (local.get 1) (i32.div_u)
+  )
+  (func (export "trap-in-callee") (param i32 i32) (result i32)
+    (try (result i32)
+      (do (local.get 0) (local.get 1) (call $div))
+      (catch_all (i32.const 11))
+    )
+  )
+
+  (func (export "catch-complex-1") (param i32) (result i32)
+    (try (result i32)
+      (do
+        (try (result i32)
+          (do
+            (local.get 0)
+            (i32.eqz)
+            (if
+              (then (throw $e0))
+              (else
+                (local.get 0)
+                (i32.const 1)
+                (i32.eq)
+                (if (then (throw $e1)) (else (throw $e2)))
+              )
+            )
+            (i32.const 2)
+          )
+          (catch $e0 (i32.const 3))
+        )
+      )
+      (catch $e1 (i32.const 4))
+    )
+  )
+
+  (func (export "catch-complex-2") (param i32) (result i32)
+    (try (result i32)
+      (do
+        (local.get 0)
+        (i32.eqz)
+        (if
+          (then (throw $e0))
+          (else
+            (local.get 0)
+            (i32.const 1)
+            (i32.eq)
+            (if (then (throw $e1)) (else (throw $e2)))
+          )
+        )
+        (i32.const 2)
+      )
+      (catch $e0 (i32.const 3))
+      (catch $e1 (i32.const 4))
+    )
+  )
+
+  (func (export "throw-catch-param-i32") (param i32) (result i32)
+    (try (result i32)
+      (do (local.get 0) (throw $e-i32) (i32.const 2))
+      (catch $e-i32 (return))
+    )
+  )
+
+  (func (export "throw-catch-param-f32") (param f32) (result f32)
+    (try (result f32)
+      (do (local.get 0) (throw $e-f32) (f32.const 0))
+      (catch $e-f32 (return))
+    )
+  )
+
+  (func (export "throw-catch-param-i64") (param i64) (result i64)
+    (try (result i64)
+      (do (local.get 0) (throw $e-i64) (i64.const 2))
+      (catch $e-i64 (return))
+    )
+  )
+
+  (func (export "throw-catch-param-f64") (param f64) (result f64)
+    (try (result f64)
+      (do (local.get 0) (throw $e-f64) (f64.const 0))
+      (catch $e-f64 (return))
+    )
+  )
+
+  (func $throw-param-i32 (param i32) (local.get 0) (throw $e-i32))
+  (func (export "catch-param-i32") (param i32) (result i32)
+    (try (result i32)
+      (do (i32.const 0) (local.get 0) (call $throw-param-i32))
+      (catch $e-i32)
+    )
+  )
+
+  (func (export "catch-imported") (result i32)
+    (try (result i32)
+      (do
+        (i32.const 1)
+        (call $imported-throw)
+      )
+      (catch $imported-e0 (i32.const 2))
+    )
+  )
+
+  (func (export "catchless-try") (param i32) (result i32)
+    (try (result i32)
+      (do
+        (try (result i32)
+          (do (local.get 0) (call $throw-if))
+        )
+      )
+      (catch $e0 (i32.const 1))
+    )
+  )
+)
+
+(assert_return (invoke "empty-catch"))
+
+(assert_return (invoke "simple-throw-catch" (i32.const 0)) (i32.const 23))
+(assert_return (invoke "simple-throw-catch" (i32.const 1)) (i32.const 42))
+
+(assert_trap (invoke "unreachable-not-caught") "unreachable")
+
+(assert_return (invoke "trap-in-callee" (i32.const 7) (i32.const 2)) (i32.const 3))
+(assert_trap (invoke "trap-in-callee" (i32.const 1) (i32.const 0)) "integer divide by zero")
+
+(assert_return (invoke "catch-complex-1" (i32.const 0)) (i32.const 3))
+(assert_return (invoke "catch-complex-1" (i32.const 1)) (i32.const 4))
+(assert_exception (invoke "catch-complex-1" (i32.const 2)) "unhandled exception")
+
+(assert_return (invoke "catch-complex-2" (i32.const 0)) (i32.const 3))
+(assert_return (invoke "catch-complex-2" (i32.const 1)) (i32.const 4))
+(assert_exception (invoke "catch-complex-2" (i32.const 2)) "unhandled exception")
+
+(assert_return (invoke "throw-catch-param-i32" (i32.const 0)) (i32.const 0))
+(assert_return (invoke "throw-catch-param-i32" (i32.const 1)) (i32.const 1))
+(assert_return (invoke "throw-catch-param-i32" (i32.const 10)) (i32.const 10))
+
+(assert_return (invoke "throw-catch-param-f32" (f32.const 5.0)) (f32.const 5.0))
+(assert_return (invoke "throw-catch-param-f32" (f32.const 10.5)) (f32.const 10.5))
+
+(assert_return (invoke "throw-catch-param-i64" (i64.const 5)) (i64.const 5))
+(assert_return (invoke "throw-catch-param-i64" (i64.const 0)) (i64.const 0))
+(assert_return (invoke "throw-catch-param-i64" (i64.const -1)) (i64.const -1))
+
+(assert_return (invoke "throw-catch-param-f64" (f64.const 5.0)) (f64.const 5.0))
+(assert_return (invoke "throw-catch-param-f64" (f64.const 10.5)) (f64.const 10.5))
+
+(assert_return (invoke "catch-param-i32" (i32.const 5)) (i32.const 5))
+
+(assert_return (invoke "catch-imported") (i32.const 2))
+
+(assert_return (invoke "catchless-try" (i32.const 0)) (i32.const 0))
+(assert_return (invoke "catchless-try" (i32.const 1)) (i32.const 1))
+
+(module
+  (func $imported-throw (import "test" "throw"))
+  (tag $e0)
+
+  (func (export "imported-mismatch") (result i32)
+    (try (result i32)
+      (do
+        (try (result i32)
+          (do
+            (i32.const 1)
+            (call $imported-throw)
+          )
+          (catch $e0 (i32.const 2))
+        )
+      )
+      (catch_all (i32.const 3))
+    )
+  )
+)
+
+(assert_return (invoke "imported-mismatch") (i32.const 3))
+
+(assert_malformed
+  (module quote "(module (func (catch_all)))")
+  "unexpected token"
+)
+
+(assert_malformed
+  (module quote "(module (tag $e) (func (catch $e)))")
+  "unexpected token"
+)
+
+(assert_malformed
+  (module quote
+    "(module (func (try (do) (catch_all) (catch_all))))"
+  )
+  "unexpected token"
+)
+
+(assert_invalid (module (func (result i32) (try (result i32) (do))))
+                "type mismatch: instruction requires [i32] but stack has []")
+(assert_invalid (module (func (result i32) (try (result i32) (do (i64.const 42)))))
+                "type mismatch: instruction requires [i32] but stack has [i64]")
+(assert_invalid (module (tag) (func (try (do) (catch 0 (i32.const 42)))))
+                "type mismatch: block requires [] but stack has [i32]")
+(assert_invalid (module
+                  (tag (param i64))
+                  (func (result i32)
+                    (try (result i32) (do (i32.const 42)) (catch 0))))
+                "type mismatch: instruction requires [i32] but stack has [i64]")
+(assert_invalid (module (func (try (do) (catch_all (i32.const 42)))))
+                "type mismatch: block requires [] but stack has [i32]")
\ No newline at end of file
