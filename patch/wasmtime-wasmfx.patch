diff --git a/.github/actions/install-cargo-vet/action.yml b/.github/actions/install-cargo-vet/action.yml
deleted file mode 100644
index 0d481d744..000000000
--- a/.github/actions/install-cargo-vet/action.yml
+++ /dev/null
@@ -1,20 +0,0 @@
-name: 'Install the `cargo-vet` tool'
-description: 'Runs `cargo install cargo-vet`'
-
-inputs:
-  version:
-    description: 'Version to install'
-    required: false
-    default: '0.8.0'
-
-runs:
-  using: composite
-  steps:
-    - uses: actions/cache@v3
-      with:
-        path: ${{ runner.tool_cache }}/cargo-vet
-        key: cargo-vet-bin-${{ inputs.version }}
-    - run: echo "${{ runner.tool_cache }}/cargo-vet/bin" >> $GITHUB_PATH
-      shell: bash
-    - run: cargo install --root ${{ runner.tool_cache }}/cargo-vet --version ${{ inputs.version }} cargo-vet
-      shell: bash
diff --git a/.github/actions/install-rust/action.yml b/.github/actions/install-rust/action.yml
index 04b227cbc..3b190930a 100644
--- a/.github/actions/install-rust/action.yml
+++ b/.github/actions/install-rust/action.yml
@@ -5,7 +5,7 @@ inputs:
   toolchain:
     description: 'Default toolchan to install'
     required: false
-    default: '1.71.0'
+    default: '1.69.0'
   lockfiles:
     description: 'Path glob for Cargo.lock files to use as cache keys'
     required: false
diff --git a/.github/workflows/main.yml b/.github/workflows/main.yml
index 4f155f96a..d9800b7de 100644
--- a/.github/workflows/main.yml
+++ b/.github/workflows/main.yml
@@ -86,12 +86,19 @@ jobs:
     needs: determine
     if: needs.determine.outputs.audit
     runs-on: ubuntu-latest
+    env:
+      CARGO_VET_VERSION: 0.8.0
     steps:
     - uses: actions/checkout@v3
       with:
         submodules: true
     - uses: ./.github/actions/install-rust
-    - uses: ./.github/actions/install-cargo-vet
+    - uses: actions/cache@v3
+      with:
+        path: ${{ runner.tool_cache }}/cargo-vet
+        key: cargo-vet-bin-${{ env.CARGO_VET_VERSION }}
+    - run: echo "${{ runner.tool_cache }}/cargo-vet/bin" >> $GITHUB_PATH
+    - run: cargo install --root ${{ runner.tool_cache }}/cargo-vet --version ${{ env.CARGO_VET_VERSION }} cargo-vet
     - run: cargo vet --locked
 
     # common logic to cancel the entire run if this job fails
@@ -187,7 +194,7 @@ jobs:
         submodules: true
     - uses: ./.github/actions/install-rust
       with:
-        toolchain: nightly-2023-07-02
+        toolchain: nightly-2023-03-20
 
     # Build C API documentation
     - run: curl -L https://sourceforge.net/projects/doxygen/files/rel-1.9.3/doxygen-1.9.3.linux.bin.tar.gz/download | tar xzf -
@@ -346,7 +353,7 @@ jobs:
     # flags to rustc.
     - uses: ./.github/actions/install-rust
       with:
-        toolchain: nightly-2023-07-02
+        toolchain: nightly-2023-03-20
     - run: cargo install cargo-fuzz --vers "^0.11"
     # Install the OCaml packages necessary for fuzz targets that use the
     # `wasm-spec-interpreter`.
@@ -644,7 +651,7 @@ jobs:
         submodules: true
     - uses: ./.github/actions/install-rust
       with:
-        toolchain: nightly-2023-07-02
+        toolchain: nightly-2023-03-20
     - run: rustup component add rust-src miri
     - uses: actions/cache@v3
       with:
diff --git a/.github/workflows/release-process.yml b/.github/workflows/release-process.yml
index 8e6a5e585..f1361ce89 100644
--- a/.github/workflows/release-process.yml
+++ b/.github/workflows/release-process.yml
@@ -48,9 +48,6 @@ jobs:
           git config user.email 'wasmtime-publish@users.noreply.github.com'
           git remote set-url origin https://git:${{ secrets.PERSONAL_ACCESS_TOKEN }}@github.com/${{ github.repository }}
 
-      - uses: ./.github/actions/install-rust
-      - uses: ./.github/actions/install-cargo-vet
-
       - name: Bump major version number
         run: |
           set -ex
@@ -69,9 +66,6 @@ jobs:
           cat backup-releases >> RELEASES.md
           rm backup-releases
 
-          # Update `cargo vet` entries for all the new crate versions
-          cargo vet
-
           # Commit all of the above changes.
           git commit -am "Bump Wasmtime to $num"
 
diff --git a/.github/workflows/typed-continuations.yml b/.github/workflows/typed-continuations.yml
new file mode 100644
index 000000000..6d9482f26
--- /dev/null
+++ b/.github/workflows/typed-continuations.yml
@@ -0,0 +1,201 @@
+name: TC CI
+on:
+  # Run CI for PRs to `main` and to release branches.
+  #
+  # Note that PRs to `main` will run a subset of tests and PRs to the
+  # `release-*` branches will run full CI.
+  pull_request:
+    branches:
+    - 'typed-continuations'
+
+  # Run full CI on the `typed-continuations` branch once a day to prime the GitHub Actions
+  # caches used by PRs and the merge queue.
+  schedule:
+  - cron: '13 4 * * *'
+
+defaults:
+  run:
+    shell: bash
+
+jobs:
+  # Check Code style quickly by running `rustfmt` over all code
+  rustfmt:
+    name: Rustfmt
+    runs-on: ubuntu-latest
+    steps:
+    - uses: actions/checkout@v3
+      with:
+        submodules: true
+    - uses: ./.github/actions/install-rust
+    - run: rustup component add rustfmt
+    - run: cargo fmt --all -- --check
+
+  # Checks of various feature combinations and whether things
+  # compile. The goal here isn't to run tests, mostly just serve as a
+  # double-check that Rust code compiles and is likely to work everywhere else.
+  checks:
+    name: Check
+    runs-on: ubuntu-latest
+    env:
+      CARGO_NDK_VERSION: 2.12.2
+    steps:
+    - uses: actions/checkout@v3
+      with:
+        submodules: true
+    - uses: ./.github/actions/install-rust
+
+    # Check some feature combinations of the `wasmtime` crate
+    - run: cargo check -p wasmtime --no-default-features
+    - run: cargo check -p wasmtime --no-default-features --features wat
+    - run: cargo check -p wasmtime --no-default-features --features jitdump
+    - run: cargo check -p wasmtime --no-default-features --features vtune
+    - run: cargo check -p wasmtime --no-default-features --features cache
+    - run: cargo check -p wasmtime --no-default-features --features async
+    - run: cargo check -p wasmtime --no-default-features --features pooling-allocator
+    - run: cargo check -p wasmtime --no-default-features --features cranelift
+    - run: cargo check -p wasmtime --no-default-features --features component-model
+    - run: cargo check -p wasmtime --no-default-features --features cranelift,wat,async,cache
+    - run: cargo check -p wasmtime --no-default-features --features winch
+    - run: cargo check --features component-model
+    - run: cargo check -p wasmtime --features incremental-cache
+
+    # Check that benchmarks of the cranelift project build
+    - run: cargo check --benches -p cranelift-codegen
+
+    # Check some feature combinations of the `wasmtime-c-api` crate
+    - run: cargo check -p wasmtime-c-api --no-default-features
+    - run: cargo check -p wasmtime-c-api --no-default-features --features wat
+    - run: cargo check -p wasmtime-c-api --no-default-features --features wasi
+
+    # Check a few builds of the cranelift backend
+    # - only x86 backend support,
+    # - only arm64 backend support,
+    # - no debug_assertions.
+    - run: cargo check --manifest-path=./cranelift/Cargo.toml --bin clif-util --no-default-features --features=cranelift-codegen/arm64
+    - run: cargo check --manifest-path=./cranelift/Cargo.toml --bin clif-util --no-default-features --features=cranelift-codegen/x86
+    - run: cargo check --manifest-path=./cranelift/Cargo.toml --bin clif-util
+      env:
+        CARGO_PROFILE_DEV_DEBUG_ASSERTIONS: false
+
+  # Verify all fuzz targets compile successfully
+  fuzz_targets:
+    name: Fuzz Targets
+    runs-on: ubuntu-latest
+    steps:
+    - uses: actions/checkout@v3
+      with:
+        submodules: true
+    # Note that building with fuzzers requires nightly since it uses unstable
+    # flags to rustc.
+    - uses: ./.github/actions/install-rust
+      with:
+        toolchain: nightly-2023-03-20
+    - run: cargo install cargo-fuzz --vers "^0.11"
+    # Install the OCaml packages necessary for fuzz targets that use the
+    # `wasm-spec-interpreter`.
+    - run: sudo apt install -y ocaml-nox ocamlbuild ocaml-findlib libzarith-ocaml-dev
+    - run: cargo fetch
+      working-directory: ./fuzz
+    - run: cargo fuzz build --dev -s none
+    # Check that the ISLE fuzz targets build too.
+    - run: cargo fuzz build --dev -s none --fuzz-dir ./cranelift/isle/fuzz
+
+
+  # Perform all tests (debug mode) for `wasmtime`.
+  #
+  # Note that the full matrix for what may run here is defined within
+  # `./ci/build-test-matrix.js` and the execution of the `determine` step will
+  # calculate whether the tests are actually run as part of PRs and such.
+  test:
+    name: ${{ matrix.name }}
+    runs-on: ${{ matrix.os }}
+    env:
+      QEMU_BUILD_VERSION: 7.2.0
+    strategy:
+      fail-fast: true
+      matrix:
+        os:
+          - ubuntu-latest
+        name:
+          - "Test Linux x86_64"
+        filter:
+          - "linux-x64"
+        isa:
+          - "x64"
+    steps:
+    - uses: actions/checkout@v3
+      with:
+        submodules: true
+    - uses: ./.github/actions/install-rust
+
+    # Install targets in order to build various tests throughout the repo
+    - run: rustup target add wasm32-wasi wasm32-unknown-unknown ${{ matrix.target }}
+    - run: echo CARGO_BUILD_TARGET=${{ matrix.target }} >> $GITHUB_ENV
+      if: matrix.target != ''
+
+    - run: cargo fetch --locked
+    - run: cargo fetch --locked --manifest-path crates/test-programs/wasi-tests/Cargo.toml
+    - run: cargo fetch --locked --manifest-path crates/test-programs/wasi-http-tests/Cargo.toml
+
+    - uses: actions/cache@v3
+      with:
+        path: ${{ runner.tool_cache }}/qemu
+        key: qemu-${{ matrix.target }}-${{ env.QEMU_BUILD_VERSION }}-patchcpuinfo
+      if: matrix.target != '' && matrix.os == 'ubuntu-latest'
+    - name: Install cross-compilation tools
+      run: |
+        set -ex
+        sudo apt-get update
+        sudo apt-get install -y ${{ matrix.gcc_package }} ninja-build
+
+        # Configure Cargo for cross compilation and tell it how it can run
+        # cross executables
+        upcase=$(echo ${{ matrix.target }} | awk '{ print toupper($0) }' | sed 's/-/_/g')
+        echo CARGO_TARGET_${upcase}_RUNNER=${{ runner.tool_cache }}/qemu/bin/${{ matrix.qemu }} >> $GITHUB_ENV
+        echo CARGO_TARGET_${upcase}_LINKER=${{ matrix.gcc }} >> $GITHUB_ENV
+
+        # QEMU emulation is not always the speediest, so total testing time
+        # goes down if we build the libs in release mode when running tests.
+        echo CARGO_PROFILE_DEV_OPT_LEVEL=2 >> $GITHUB_ENV
+
+        # See comments in the source for why we enable this during QEMU
+        # emulation.
+        echo WASMTIME_TEST_NO_HOG_MEMORY=1 >> $GITHUB_ENV
+
+        # See if qemu is already in the cache
+        if [ -f ${{ runner.tool_cache }}/qemu/built ]; then
+          exit 0
+        fi
+
+        # Download and build qemu from source since the most recent release is
+        # way faster at arm emulation than the current version github actions'
+        # ubuntu image uses. Disable as much as we can to get it to build
+        # quickly.
+        curl https://download.qemu.org/qemu-$QEMU_BUILD_VERSION.tar.xz | tar xJf -
+        cd qemu-$QEMU_BUILD_VERSION
+        patch -p1 < $GITHUB_WORKSPACE/ci/qemu-cpuinfo.patch
+        ./configure --target-list=${{ matrix.qemu_target }} --prefix=${{ runner.tool_cache}}/qemu --disable-tools --disable-slirp --disable-fdt --disable-capstone --disable-docs
+        ninja -C build install
+        touch ${{ runner.tool_cache }}/qemu/built
+      if: matrix.gcc != ''
+
+    # Build and test the C API with example C programs along with the example
+    # Rust programs. Note that this only executes if the `determine` step told
+    # us to test the capi which is off-by-default for PRs.
+    - run: cmake -Sexamples -Bexamples/build -DBUILD_SHARED_LIBS=OFF
+      if: matrix.target == ''
+    - run: cmake --build examples/build --config Debug
+      if: matrix.target == ''
+
+    # Build and test all features
+    - run: ./ci/run-tests.sh --locked
+      env:
+        RUST_BACKTRACE: 1
+
+    # Test debug (DWARF) related functionality.
+    - run: |
+        sudo apt-get update && sudo apt-get install -y gdb lldb llvm
+        cargo test test_debug_dwarf -- --ignored --test-threads 1
+      if: matrix.os == 'ubuntu-latest' && matrix.target == ''
+      env:
+        RUST_BACKTRACE: 1
diff --git a/Cargo.lock b/Cargo.lock
index 092871bed..78c5dea75 100644
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -54,9 +54,9 @@ dependencies = [
 
 [[package]]
 name = "ahash"
-version = "0.8.2"
+version = "0.8.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "bf6ccdb167abbf410dcb915cabd428929d7f6a04980b54a11f26a39f1c7f7107"
+checksum = "2c99f64d1e06488f620f932677e24bc6e2897582980441ae90a671415bd7ec2f"
 dependencies = [
  "cfg-if",
  "once_cell",
@@ -65,9 +65,9 @@ dependencies = [
 
 [[package]]
 name = "aho-corasick"
-version = "0.7.18"
+version = "1.0.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "1e37cfd5e7657ada45f742d6e99ca5788580b5c529dc78faf11ece6dc702656f"
+checksum = "43f6cb1bf222025340178f382c426f13757b2960e89779dfcb319c32542a5a41"
 dependencies = [
  "memchr",
 ]
@@ -101,13 +101,13 @@ dependencies = [
 
 [[package]]
 name = "async-trait"
-version = "0.1.53"
+version = "0.1.68"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "ed6aa3524a2dfcf9fe180c51eae2b58738348d819517ceadf95789c51fff7600"
+checksum = "b9ccdd8f2a161be9bd5c023df56f1b2a0bd1d83872ae53b71a84a12c9bf6e842"
 dependencies = [
  "proc-macro2",
  "quote",
- "syn 1.0.92",
+ "syn 2.0.18",
 ]
 
 [[package]]
@@ -153,9 +153,9 @@ dependencies = [
 
 [[package]]
 name = "base64"
-version = "0.21.0"
+version = "0.21.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "a4a4ddaa51a5bc52a6948f74c06d20aaaddb71924eab79b8c97a8c556e942d6a"
+checksum = "604178f6c5c21f02dc555784810edfb88d34ac2c73b2eae109655649ee73ce3d"
 
 [[package]]
 name = "base64ct"
@@ -174,9 +174,9 @@ dependencies = [
 
 [[package]]
 name = "bit-set"
-version = "0.5.2"
+version = "0.5.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "6e11e16035ea35e4e5997b393eacbf6f63983188f7a2ad25bfb13465f5ad59de"
+checksum = "0700ddab506f33b20a03b13996eccd309a48e5ff77d0d95926aa0210fb4e95f1"
 dependencies = [
  "bit-vec",
 ]
@@ -195,9 +195,9 @@ checksum = "bef38d45163c2f1dde094a7dfd33ccf595c92905c8f8f4fdc18d06fb1037718a"
 
 [[package]]
 name = "bitflags"
-version = "2.2.1"
+version = "2.3.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "24a6904aef64d73cf10ab17ebace7befb918b82164785cb89907993be7f83813"
+checksum = "6776fc96284a0bb647b615056fc496d1fe1644a7ab01829818a6d91cae888b84"
 
 [[package]]
 name = "block-buffer"
@@ -210,9 +210,9 @@ dependencies = [
 
 [[package]]
 name = "block-buffer"
-version = "0.10.2"
+version = "0.10.4"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "0bf7fe51849ea569fd452f37822f606a5cabb684dc918707a0193fd4664ff324"
+checksum = "3078c7629b62d3f0439517fa394996acacc5cbc91c5a20d8c658e77abd503a71"
 dependencies = [
  "generic-array",
 ]
@@ -230,13 +230,13 @@ dependencies = [
 
 [[package]]
 name = "bumpalo"
-version = "3.12.0"
+version = "3.13.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "0d261e256854913907f67ed06efbc3338dfe6179796deefc1ff763fc1aee5535"
+checksum = "a3e2c3daef883ecc1b5d58c15adae93470a91d425f3532ba1695849656af3fc1"
 
 [[package]]
 name = "byte-array-literals"
-version = "12.0.0"
+version = "11.0.0"
 
 [[package]]
 name = "byteorder"
@@ -246,9 +246,9 @@ checksum = "14c189c53d098945499cdfa7ecc63567cf3886b3332b312a5b4585d8d3a6a610"
 
 [[package]]
 name = "bytes"
-version = "1.1.0"
+version = "1.4.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "c4872d67bab6358e59559027aa3b9157c53d9358c51423c17554809a8858e0f8"
+checksum = "89b2fd2a0dcf38d7971e2194b6b6eebab45ae01067456a7fd93d5547a61b70be"
 
 [[package]]
 name = "camino"
@@ -261,9 +261,9 @@ dependencies = [
 
 [[package]]
 name = "cap-fs-ext"
-version = "1.0.14"
+version = "1.0.15"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "e1742f5106155d46a41eac5f730ee189bf92fde6ae109fbf2cdb67176726ca5d"
+checksum = "58bc48200a1a0fa6fba138b1802ad7def18ec1cdd92f7b2a04e21f1bd887f7b9"
 dependencies = [
  "cap-primitives",
  "cap-std",
@@ -273,9 +273,9 @@ dependencies = [
 
 [[package]]
 name = "cap-primitives"
-version = "1.0.14"
+version = "1.0.15"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "42068f579028e856717d61423645c85d2d216dde8eff62c9b30140e725c79177"
+checksum = "a4b6df5b295dca8d56f35560be8c391d59f0420f72e546997154e24e765e6451"
 dependencies = [
  "ambient-authority",
  "fs-set-times",
@@ -290,9 +290,9 @@ dependencies = [
 
 [[package]]
 name = "cap-rand"
-version = "1.0.14"
+version = "1.0.15"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "d3be2ededc13f42a5921c08e565b854cb5ff9b88753e2c6ec12c58a24e7e8d4e"
+checksum = "4d25555efacb0b5244cf1d35833d55d21abc916fff0eaad254b8e2453ea9b8ab"
 dependencies = [
  "ambient-authority",
  "rand 0.8.5",
@@ -300,9 +300,9 @@ dependencies = [
 
 [[package]]
 name = "cap-std"
-version = "1.0.14"
+version = "1.0.15"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "559ad6fab5fedcc9bd5877160e1433fcd481f8af615068d6ca49472b1201cc6c"
+checksum = "3373a62accd150b4fcba056d4c5f3b552127f0ec86d3c8c102d60b978174a012"
 dependencies = [
  "cap-primitives",
  "io-extras",
@@ -312,9 +312,9 @@ dependencies = [
 
 [[package]]
 name = "cap-tempfile"
-version = "1.0.14"
+version = "1.0.15"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "92372a5de78a858f20c22a8dbe3ea55e1cc2daeb82016a3150dab8cf51ea3235"
+checksum = "6fd9864347f55a9c31de436ec9d7d3577476f3e6eeb3cc44ae2204de9164f78d"
 dependencies = [
  "cap-std",
  "rand 0.8.5",
@@ -324,9 +324,9 @@ dependencies = [
 
 [[package]]
 name = "cap-time-ext"
-version = "1.0.14"
+version = "1.0.15"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "2a74e04cd32787bfa3a911af745b0fd5d99d4c3fc16c64449e1622c06fa27c8e"
+checksum = "e95002993b7baee6b66c8950470e59e5226a23b3af39fc59c47fe416dd39821a"
 dependencies = [
  "cap-primitives",
  "once_cell",
@@ -365,9 +365,9 @@ dependencies = [
 
 [[package]]
 name = "cargo_metadata"
-version = "0.15.3"
+version = "0.15.4"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "08a1ec454bc3eead8719cb56e15dbbfecdbc14e4b3a3ae4936cc6e31f5fc0d07"
+checksum = "eee4243f1f26fc7a42710e7439c149e2b10b05472f88090acce52632f231a73a"
 dependencies = [
  "camino",
  "cargo-platform",
@@ -385,9 +385,9 @@ checksum = "37b2a672a2cb129a2e41c10b1224bb368f9f37a2b16b612598138befd7b37eb5"
 
 [[package]]
 name = "cc"
-version = "1.0.73"
+version = "1.0.79"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "2fff2a6927b3bb87f9595d67196a70493f627687a71d87a0d692242c33f58c11"
+checksum = "50d30906286121d95be3d479533b458f87493b30a4b5f79a607db8f5d11aa91f"
 dependencies = [
  "jobserver",
 ]
@@ -400,9 +400,9 @@ checksum = "baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd"
 
 [[package]]
 name = "chacha20"
-version = "0.8.1"
+version = "0.8.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "01b72a433d0cf2aef113ba70f62634c56fddb0f244e6377185c56a7cadbd8f91"
+checksum = "5c80e5460aa66fe3b91d40bcbdab953a597b60053e34d684ac6903f863b680a6"
 dependencies = [
  "cfg-if",
  "cipher",
@@ -412,9 +412,9 @@ dependencies = [
 
 [[package]]
 name = "chacha20poly1305"
-version = "0.9.0"
+version = "0.9.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "3b84ed6d1d5f7aa9bdde921a5090e0ca4d934d250ea3b402a5fab3a994e28a2a"
+checksum = "a18446b09be63d457bbec447509e85f662f32952b035ce892290396bc0b0cff5"
 dependencies = [
  "aead",
  "chacha20",
@@ -425,9 +425,9 @@ dependencies = [
 
 [[package]]
 name = "ciborium"
-version = "0.2.0"
+version = "0.2.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "b0c137568cc60b904a7724001b35ce2630fd00d5d84805fbb608ab89509d788f"
+checksum = "effd91f6c78e5a4ace8a5d3c0b6bfaec9e2baaef55f3efc00e45fb2e477ee926"
 dependencies = [
  "ciborium-io",
  "ciborium-ll",
@@ -436,15 +436,15 @@ dependencies = [
 
 [[package]]
 name = "ciborium-io"
-version = "0.2.0"
+version = "0.2.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "346de753af073cc87b52b2083a506b38ac176a44cfb05497b622e27be899b369"
+checksum = "cdf919175532b369853f5d5e20b26b43112613fd6fe7aee757e35f7a44642656"
 
 [[package]]
 name = "ciborium-ll"
-version = "0.2.0"
+version = "0.2.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "213030a2b5a4e0c0892b6652260cf6ccac84827b83a85a534e178e3906c4cf1b"
+checksum = "defaa24ecc093c77630e6c15e17c51f5e187bf35ee514f4e2d67baaa96dae22b"
 dependencies = [
  "ciborium-io",
  "half",
@@ -461,15 +461,15 @@ dependencies = [
 
 [[package]]
 name = "clap"
-version = "3.2.8"
+version = "3.2.25"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "190814073e85d238f31ff738fcb0bf6910cedeb73376c87cd69291028966fd83"
+checksum = "4ea181bf566f71cb9a5d17a59e1871af638180a18fb0035c92ae62b705207123"
 dependencies = [
  "atty",
  "bitflags 1.3.2",
  "clap_derive",
  "clap_lex",
- "indexmap 1.9.1",
+ "indexmap",
  "once_cell",
  "strsim",
  "termcolor",
@@ -478,15 +478,15 @@ dependencies = [
 
 [[package]]
 name = "clap_derive"
-version = "3.2.7"
+version = "3.2.25"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "759bf187376e1afa7b85b959e6a664a3e7a95203415dba952ad19139e798f902"
+checksum = "ae6371b8bdc8b7d3959e9cf7b22d4435ef3e79e138688421ec654acf8c81b008"
 dependencies = [
  "heck",
  "proc-macro-error",
  "proc-macro2",
  "quote",
- "syn 1.0.92",
+ "syn 1.0.109",
 ]
 
 [[package]]
@@ -534,7 +534,7 @@ version = "0.0.0"
 dependencies = [
  "proc-macro2",
  "quote",
- "syn 1.0.92",
+ "syn 1.0.109",
 ]
 
 [[package]]
@@ -557,17 +557,15 @@ dependencies = [
 
 [[package]]
 name = "console"
-version = "0.15.0"
+version = "0.15.7"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "a28b32d32ca44b70c3e4acd7db1babf555fa026e385fb95f18028f88848b3c31"
+checksum = "c926e00cc70edefdc64d3a5ff31cc65bb97a3460097762bd23afb4d8145fccf8"
 dependencies = [
  "encode_unicode",
+ "lazy_static",
  "libc",
- "once_cell",
- "regex",
- "terminal_size",
  "unicode-width",
- "winapi",
+ "windows-sys 0.45.0",
 ]
 
 [[package]]
@@ -596,7 +594,7 @@ dependencies = [
 
 [[package]]
 name = "cranelift"
-version = "0.99.0"
+version = "0.98.0"
 dependencies = [
  "cranelift-codegen",
  "cranelift-frontend",
@@ -604,14 +602,14 @@ dependencies = [
 
 [[package]]
 name = "cranelift-bforest"
-version = "0.99.0"
+version = "0.98.0"
 dependencies = [
  "cranelift-entity",
 ]
 
 [[package]]
 name = "cranelift-codegen"
-version = "0.99.0"
+version = "0.98.0"
 dependencies = [
  "anyhow",
  "bincode",
@@ -629,7 +627,7 @@ dependencies = [
  "log",
  "regalloc2",
  "serde",
- "sha2 0.10.2",
+ "sha2 0.10.6",
  "similar",
  "smallvec",
  "souper-ir",
@@ -638,25 +636,25 @@ dependencies = [
 
 [[package]]
 name = "cranelift-codegen-meta"
-version = "0.99.0"
+version = "0.98.0"
 dependencies = [
  "cranelift-codegen-shared",
 ]
 
 [[package]]
 name = "cranelift-codegen-shared"
-version = "0.99.0"
+version = "0.98.0"
 
 [[package]]
 name = "cranelift-control"
-version = "0.99.0"
+version = "0.98.0"
 dependencies = [
  "arbitrary",
 ]
 
 [[package]]
 name = "cranelift-entity"
-version = "0.99.0"
+version = "0.98.0"
 dependencies = [
  "serde",
 ]
@@ -686,13 +684,14 @@ dependencies = [
  "target-lexicon",
  "thiserror",
  "toml",
- "wasmparser 0.108.0",
- "wat",
+ "wasmparser 0.107.0 (git+https://github.com/effect-handlers/wasm-tools?branch=typed-continuations)",
+ "wasmtime-types",
+ "wat 1.0.66 (git+https://github.com/effect-handlers/wasm-tools?branch=typed-continuations)",
 ]
 
 [[package]]
 name = "cranelift-frontend"
-version = "0.99.0"
+version = "0.98.0"
 dependencies = [
  "cranelift-codegen",
  "hashbrown 0.13.2",
@@ -716,7 +715,7 @@ dependencies = [
 
 [[package]]
 name = "cranelift-interpreter"
-version = "0.99.0"
+version = "0.98.0"
 dependencies = [
  "cranelift-codegen",
  "cranelift-entity",
@@ -730,7 +729,7 @@ dependencies = [
 
 [[package]]
 name = "cranelift-isle"
-version = "0.99.0"
+version = "0.98.0"
 dependencies = [
  "codespan-reporting",
  "log",
@@ -739,7 +738,7 @@ dependencies = [
 
 [[package]]
 name = "cranelift-jit"
-version = "0.99.0"
+version = "0.98.0"
 dependencies = [
  "anyhow",
  "cranelift",
@@ -760,7 +759,7 @@ dependencies = [
 
 [[package]]
 name = "cranelift-module"
-version = "0.99.0"
+version = "0.98.0"
 dependencies = [
  "anyhow",
  "cranelift-codegen",
@@ -771,7 +770,7 @@ dependencies = [
 
 [[package]]
 name = "cranelift-native"
-version = "0.99.0"
+version = "0.98.0"
 dependencies = [
  "cranelift-codegen",
  "libc",
@@ -780,7 +779,7 @@ dependencies = [
 
 [[package]]
 name = "cranelift-object"
-version = "0.99.0"
+version = "0.98.0"
 dependencies = [
  "anyhow",
  "cranelift-codegen",
@@ -795,7 +794,7 @@ dependencies = [
 
 [[package]]
 name = "cranelift-reader"
-version = "0.99.0"
+version = "0.98.0"
 dependencies = [
  "anyhow",
  "cranelift-codegen",
@@ -805,7 +804,7 @@ dependencies = [
 
 [[package]]
 name = "cranelift-serde"
-version = "0.99.0"
+version = "0.98.0"
 dependencies = [
  "clap",
  "cranelift-codegen",
@@ -847,12 +846,12 @@ dependencies = [
  "thiserror",
  "toml",
  "walkdir",
- "wat",
+ "wat 1.0.66 (git+https://github.com/effect-handlers/wasm-tools?branch=typed-continuations)",
 ]
 
 [[package]]
 name = "cranelift-wasm"
-version = "0.99.0"
+version = "0.98.0"
 dependencies = [
  "cranelift-codegen",
  "cranelift-entity",
@@ -863,9 +862,9 @@ dependencies = [
  "serde",
  "smallvec",
  "target-lexicon",
- "wasmparser 0.108.0",
+ "wasmparser 0.107.0 (git+https://github.com/effect-handlers/wasm-tools?branch=typed-continuations)",
  "wasmtime-types",
- "wat",
+ "wat 1.0.66 (git+https://github.com/effect-handlers/wasm-tools?branch=typed-continuations)",
 ]
 
 [[package]]
@@ -925,9 +924,9 @@ dependencies = [
 
 [[package]]
 name = "crossbeam-deque"
-version = "0.8.1"
+version = "0.8.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "6455c0ca19f0d2fbf751b908d5c55c1f5cbc65e03c4225427254b46890bdde1e"
+checksum = "ce6fd6f855243022dcecf8702fef0c297d4338e226845fe067f6341ad9fa0cef"
 dependencies = [
  "cfg-if",
  "crossbeam-epoch",
@@ -936,26 +935,24 @@ dependencies = [
 
 [[package]]
 name = "crossbeam-epoch"
-version = "0.9.9"
+version = "0.9.14"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "07db9d94cbd326813772c968ccd25999e5f8ae22f4f8d1b11effa37ef6ce281d"
+checksum = "46bd5f3f85273295a9d14aedfb86f6aadbff6d8f5295c4a9edb08e819dcf5695"
 dependencies = [
  "autocfg 1.1.0",
  "cfg-if",
  "crossbeam-utils",
- "memoffset 0.6.5",
- "once_cell",
+ "memoffset",
  "scopeguard",
 ]
 
 [[package]]
 name = "crossbeam-utils"
-version = "0.8.10"
+version = "0.8.15"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "7d82ee10ce34d7bc12c2122495e7593a9c41347ecdd64185af4ecf72cb1a7f83"
+checksum = "3c063cd8cc95f5c377ed0d4b49a4b21f632396ff690e8470c29b3359b346984b"
 dependencies = [
  "cfg-if",
- "once_cell",
 ]
 
 [[package]]
@@ -965,7 +962,7 @@ source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "f83bd3bb4314701c568e340cd8cf78c975aa0ca79e03d3f6d1677d5b0c9c0c03"
 dependencies = [
  "generic-array",
- "rand_core 0.6.3",
+ "rand_core 0.6.4",
  "subtle",
  "zeroize",
 ]
@@ -1045,18 +1042,18 @@ checksum = "fcc3dd5e9e9c0b295d6e1e4d811fb6f157d5ffd784b8d202fc62eac8035a770b"
 dependencies = [
  "proc-macro2",
  "quote",
- "syn 1.0.92",
+ "syn 1.0.109",
 ]
 
 [[package]]
 name = "derive_arbitrary"
-version = "1.3.0"
+version = "1.3.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "f3cdeb9ec472d588e539a818b2dee436825730da08ad0017c4b1a17676bdc8b7"
+checksum = "53e0efad4403bfc52dc201159c4b842a246a14b98c64b55dfd0f2d89729dfeb8"
 dependencies = [
  "proc-macro2",
  "quote",
- "syn 1.0.92",
+ "syn 2.0.18",
 ]
 
 [[package]]
@@ -1070,11 +1067,11 @@ dependencies = [
 
 [[package]]
 name = "digest"
-version = "0.10.3"
+version = "0.10.7"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "f2fb860ca6fafa5552fb6d0e816a69c8e49f0908bf524e30a90d97c85892d506"
+checksum = "9ed9a281f7bc9b7576e61468ba615a66a5c8cfdff42420a70aa82701a3b1e292"
 dependencies = [
- "block-buffer 0.10.2",
+ "block-buffer 0.10.4",
  "crypto-common",
 ]
 
@@ -1089,13 +1086,23 @@ dependencies = [
 ]
 
 [[package]]
-name = "dirs-next"
-version = "2.0.0"
+name = "dirs"
+version = "4.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "b98cf8ebf19c3d1b223e151f99a4f9f0690dca41414773390fc824184ac833e1"
+checksum = "ca3aa72a6f96ea37bbc5aa912f6788242832f75369bdfdadcb0e38423f100059"
 dependencies = [
- "cfg-if",
- "dirs-sys-next",
+ "dirs-sys",
+]
+
+[[package]]
+name = "dirs-sys"
+version = "0.3.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1b1d1d91c932ef41c0f2663aa8b0ca0342d444d842c06914aa0a7e352d0bada6"
+dependencies = [
+ "libc",
+ "redox_users",
+ "winapi",
 ]
 
 [[package]]
@@ -1117,9 +1124,9 @@ checksum = "9ea835d29036a4087793836fa931b08837ad5e957da9e23886b29586fb9b6650"
 
 [[package]]
 name = "dunce"
-version = "1.0.2"
+version = "1.0.4"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "453440c271cf5577fd2a40e4942540cb7d0d2f85e27c8d07dd0023c925a67541"
+checksum = "56ce8c6da7551ec6c462cbaf3bfbc75131ebbfa1c944aeaa9dab51ca1c5f0c3b"
 
 [[package]]
 name = "ecdsa"
@@ -1162,7 +1169,7 @@ version = "0.6.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "05a6c0bbc92278f84e742f08c0ab9cb16a987376cd2bc39d228ef9c74d98d6f7"
 dependencies = [
- "indexmap 1.9.1",
+ "indexmap",
  "instant",
  "log",
  "once_cell",
@@ -1172,9 +1179,9 @@ dependencies = [
 
 [[package]]
 name = "either"
-version = "1.6.1"
+version = "1.8.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "e78d4f1cc4ae33bbfc157ed5d5a5ef3bc29227303d595861deb238fcec4e9457"
+checksum = "7fcaabb2fef8c910e7f4c7ce9f67a1283a1715879a7c230ca9d6d1ae31f16d91"
 
 [[package]]
 name = "elliptic-curve"
@@ -1187,7 +1194,7 @@ dependencies = [
  "generic-array",
  "group",
  "pkcs8",
- "rand_core 0.6.3",
+ "rand_core 0.6.4",
  "subtle",
  "zeroize",
 ]
@@ -1200,9 +1207,9 @@ checksum = "a357d28ed41a50f9c765dbfe56cbc04a64e53e5fc58ba79fbc34c10ef3df831f"
 
 [[package]]
 name = "encoding_rs"
-version = "0.8.31"
+version = "0.8.32"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "9852635589dc9f9ea1b6fe9f05b50ef208c85c834a562f0c6abb1c475736ec2b"
+checksum = "071a31f4ee85403370b58aca746f01041ede6f0da2730960ad001edc2b71b394"
 dependencies = [
  "cfg-if",
 ]
@@ -1233,12 +1240,6 @@ dependencies = [
  "termcolor",
 ]
 
-[[package]]
-name = "equivalent"
-version = "1.0.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "5443807d6dff69373d433ab9ef5378ad8df50ca6298caf15de6e52e24aaf54d5"
-
 [[package]]
 name = "errno"
 version = "0.3.1"
@@ -1304,7 +1305,7 @@ version = "0.10.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "d0f40b2dcd8bc322217a5f6559ae5f9e9d1de202a2ecee2e9eafcbece7562a4f"
 dependencies = [
- "rand_core 0.6.3",
+ "rand_core 0.6.4",
  "subtle",
 ]
 
@@ -1330,14 +1331,14 @@ dependencies = [
 
 [[package]]
 name = "filetime"
-version = "0.2.16"
+version = "0.2.21"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "c0408e2626025178a6a7f7ffc05a25bc47103229f19c113755de7bf63816290c"
+checksum = "5cbc844cecaee9d4443931972e1289c8ff485cb4cc2767cb03ca139ed6885153"
 dependencies = [
  "cfg-if",
  "libc",
- "redox_syscall 0.2.13",
- "winapi",
+ "redox_syscall 0.2.16",
+ "windows-sys 0.48.0",
 ]
 
 [[package]]
@@ -1384,36 +1385,36 @@ dependencies = [
 
 [[package]]
 name = "futures-channel"
-version = "0.3.27"
+version = "0.3.28"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "164713a5a0dcc3e7b4b1ed7d3b433cabc18025386f9339346e8daf15963cf7ac"
+checksum = "955518d47e09b25bbebc7a18df10b81f0c766eaf4c4f1cccef2fca5f2a4fb5f2"
 dependencies = [
  "futures-core",
 ]
 
 [[package]]
 name = "futures-core"
-version = "0.3.27"
+version = "0.3.28"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "86d7a0c1aa76363dac491de0ee99faf6941128376f1cf96f07db7603b7de69dd"
+checksum = "4bca583b7e26f571124fe5b7561d49cb2868d79116cfa0eefce955557c6fee8c"
 
 [[package]]
 name = "futures-sink"
-version = "0.3.27"
+version = "0.3.28"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "ec93083a4aecafb2a80a885c9de1f0ccae9dbd32c2bb54b0c3a65690e0b8d2f2"
+checksum = "f43be4fe21a13b9781a69afa4985b0f6ee0e1afab2c6f454a8cf30e2b2237b6e"
 
 [[package]]
 name = "futures-task"
-version = "0.3.27"
+version = "0.3.28"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "fd65540d33b37b16542a0438c12e6aeead10d4ac5d05bd3f805b8f35ab592879"
+checksum = "76d3d132be6c0e6aa1534069c705a74a5997a356c0dc2f86a47765e5617c5b65"
 
 [[package]]
 name = "futures-util"
-version = "0.3.27"
+version = "0.3.28"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "3ef6b17e481503ec85211fed8f39d1970f128935ca1f814cd32ac4a6842e84ab"
+checksum = "26b01e40b772d54cf6c6d721c1d1abd0647a0106a12ecaa1c186273392a69533"
 dependencies = [
  "futures-core",
  "futures-task",
@@ -1436,7 +1437,7 @@ version = "0.6.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "27d12c0aed7f1e24276a241aadc4cb8ea9f83000f34bc062b7cc2d51e3b0fabd"
 dependencies = [
- "bitflags 2.2.1",
+ "bitflags 2.3.1",
  "debugid",
  "fxhash",
  "serde",
@@ -1445,9 +1446,9 @@ dependencies = [
 
 [[package]]
 name = "generic-array"
-version = "0.14.5"
+version = "0.14.7"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "fd48d33ec7f05fbfa152300fdad764757cbded343c1aa1cff2fbaf4134851803"
+checksum = "85649ca51fd72272d7821adaf274ad91c288277713d9c18820d8499a7ff69e9a"
 dependencies = [
  "typenum",
  "version_check",
@@ -1487,20 +1488,20 @@ dependencies = [
 
 [[package]]
 name = "gimli"
-version = "0.27.0"
+version = "0.27.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "dec7af912d60cdbd3677c1af9352ebae6fb8394d165568a2234df0fa00f87793"
+checksum = "ad0a93d233ebf96623465aad4046a8d3aa4da22d4f4beba5388838c8a434bbb4"
 dependencies = [
  "fallible-iterator",
- "indexmap 1.9.1",
+ "indexmap",
  "stable_deref_trait",
 ]
 
 [[package]]
 name = "glob"
-version = "0.3.0"
+version = "0.3.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "9b919933a397b79c37e33b77bb2aa3dc8eb6e165ad809e58ff75bc7db2e34574"
+checksum = "d2fabcfbdc87f4758337ca535fb41a6d701b65693ce38287d856d1674551ec9b"
 
 [[package]]
 name = "group"
@@ -1509,7 +1510,7 @@ source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "1c363a5301b8f153d80747126a04b3c82073b9fe3130571a9d170cacdeaf7912"
 dependencies = [
  "ff",
- "rand_core 0.6.3",
+ "rand_core 0.6.4",
  "subtle",
 ]
 
@@ -1525,7 +1526,7 @@ dependencies = [
  "futures-sink",
  "futures-util",
  "http",
- "indexmap 1.9.1",
+ "indexmap",
  "slab",
  "tokio",
  "tokio-util",
@@ -1553,17 +1554,11 @@ dependencies = [
  "ahash",
 ]
 
-[[package]]
-name = "hashbrown"
-version = "0.14.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "2c6201b9ff9fd90a5a3bac2e56a830d0caa509576f0e503818ee82c181b3437a"
-
 [[package]]
 name = "heck"
-version = "0.4.0"
+version = "0.4.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "2540771e65fc8cb83cd6e8a237f70c319bd5c29f78ed1084ba5d50eeac86f7f9"
+checksum = "95505c38b4572b2d910cecb0281560f54b440a19336cbbcb27bf6ce6adc6f5a8"
 dependencies = [
  "unicode-segmentation",
 ]
@@ -1588,9 +1583,9 @@ dependencies = [
 
 [[package]]
 name = "hermit-abi"
-version = "0.3.0"
+version = "0.3.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "856b5cb0902c2b6d65d5fd97dfa30f9b70c7538e770b98eab5ed52d8db923e01"
+checksum = "fed44880c466736ef9a5c5b5facefb5ed0785676d0c02d612db14e54f0d84286"
 
 [[package]]
 name = "hkdf"
@@ -1664,7 +1659,7 @@ version = "1.3.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "df004cfca50ef23c36850aaaa59ad52cc70d0e90243c3c7737a4dd32dc7a3c4f"
 dependencies = [
- "quick-error 1.2.3",
+ "quick-error",
 ]
 
 [[package]]
@@ -1713,26 +1708,15 @@ dependencies = [
 
 [[package]]
 name = "indexmap"
-version = "1.9.1"
+version = "1.9.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "10a35a97730320ffe8e2d410b5d3b69279b98d2c14bdb8b70ea89ecf7888d41e"
+checksum = "bd070e393353796e801d209ad339e89596eb4c8d430d18ede6a1cced8fafbd99"
 dependencies = [
  "autocfg 1.1.0",
  "hashbrown 0.12.3",
  "serde",
 ]
 
-[[package]]
-name = "indexmap"
-version = "2.0.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "d5477fe2230a79769d8dc68e0eabf5437907c0457a5614a9e8dddb67f65eb65d"
-dependencies = [
- "equivalent",
- "hashbrown 0.14.0",
- "serde",
-]
-
 [[package]]
 name = "indexmap-nostd"
 version = "0.4.0"
@@ -1772,20 +1756,20 @@ dependencies = [
 
 [[package]]
 name = "io-lifetimes"
-version = "1.0.10"
+version = "1.0.11"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "9c66c74d2ae7e79a5a8f7ac924adbe38ee42a859c6539ad869eb51f0b52dc220"
+checksum = "eae7b9aee968036d54dce06cebaefd919e4472e753296daccd6d344e3e2df0c2"
 dependencies = [
- "hermit-abi 0.3.0",
+ "hermit-abi 0.3.1",
  "libc",
  "windows-sys 0.48.0",
 ]
 
 [[package]]
 name = "ipnet"
-version = "2.5.0"
+version = "2.7.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "879d54834c8c76457ef4293a689b2a8c59b076067ad77b15efafbb05f92a592b"
+checksum = "12b6ee2129af8d4fb011108c73d99a1b83a85977f23b82460c0ae2e25bb4b57f"
 
 [[package]]
 name = "is-terminal"
@@ -1793,7 +1777,7 @@ version = "0.4.7"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "adcf93614601c8129ddf72e2d5633df827ba6551541c6d8c59520a371475be1f"
 dependencies = [
- "hermit-abi 0.3.0",
+ "hermit-abi 0.3.1",
  "io-lifetimes",
  "rustix",
  "windows-sys 0.48.0",
@@ -1820,18 +1804,18 @@ dependencies = [
 
 [[package]]
 name = "itertools"
-version = "0.10.3"
+version = "0.10.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "a9a9d19fa1e79b6215ff29b9d6880b706147f16e9b1dbb1e4e5947b5b02bc5e3"
+checksum = "b0fd2260e829bddf4cb6ea802289de2f86d6a7a690192fbe91b3f46e0f2c8473"
 dependencies = [
  "either",
 ]
 
 [[package]]
 name = "itoa"
-version = "1.0.1"
+version = "1.0.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "1aab8fc367588b89dcee83ab0fd66b72b50b72fa1904d7095045ace2b0c81c35"
+checksum = "453ad9f582a441959e5f0d088b02ce04cfe8d51a8eaf077f12ac6d3e94164ca6"
 
 [[package]]
 name = "ittapi"
@@ -1855,18 +1839,18 @@ dependencies = [
 
 [[package]]
 name = "jobserver"
-version = "0.1.24"
+version = "0.1.26"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "af25a77299a7f711a01975c35a6a424eb6862092cc2d6c72c4ed6cbc56dfc1fa"
+checksum = "936cfd212a0155903bcbc060e316fb6cc7cbf2e1907329391ebadc1fe0ce77c2"
 dependencies = [
  "libc",
 ]
 
 [[package]]
 name = "js-sys"
-version = "0.3.57"
+version = "0.3.63"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "671a26f820db17c2a2750743f1dd03bafd15b98c9f30c7c2628c024c05d73397"
+checksum = "2f37a4a5928311ac501dee68b3c7613a1037d0edb30c8e5427bd832d55d1b790"
 dependencies = [
  "wasm-bindgen",
 ]
@@ -1900,15 +1884,15 @@ checksum = "884e2677b40cc8c339eaefcb701c32ef1fd2493d71118dc0ca4b6a736c93bd67"
 
 [[package]]
 name = "libc"
-version = "0.2.141"
+version = "0.2.145"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "3304a64d199bb964be99741b7a14d26972741915b3649639149b2479bb46f4b5"
+checksum = "fc86cde3ff845662b8f4ef6cb50ea0e20c524eb3d29ae048287e06a1b3fa6a81"
 
 [[package]]
 name = "libfuzzer-sys"
-version = "0.4.5"
+version = "0.4.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "c8fff891139ee62800da71b7fd5b508d570b9ad95e614a53c6f453ca08366038"
+checksum = "beb09950ae85a0a94b27676cccf37da5ff13f27076aa1adbc6545dd0d0e1bd4e"
 dependencies = [
  "arbitrary",
  "cc",
@@ -1917,9 +1901,9 @@ dependencies = [
 
 [[package]]
 name = "libloading"
-version = "0.7.3"
+version = "0.7.4"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "efbc0f03f9a775e9f6aed295c6a1ba2253c5757a9e03d55c6caa46a681abcddd"
+checksum = "b67380fd3b2fbe7527a606e18729d21c6f3951633d0500574c4dc22d2d638b9f"
 dependencies = [
  "cfg-if",
  "winapi",
@@ -1933,15 +1917,15 @@ checksum = "f7012b1bbb0719e1097c47611d3898568c546d597c2e74d66f6087edd5233ff4"
 
 [[package]]
 name = "linux-raw-sys"
-version = "0.3.3"
+version = "0.3.8"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "9b085a4f2cde5781fc4b1717f2e86c62f5cda49de7ba99a7c2eae02b61c9064c"
+checksum = "ef53942eb7bf7ff43a617b3e2c1c4a5ecf5944a7c1bc12d7ee39bbb15e5c1519"
 
 [[package]]
 name = "listenfd"
-version = "1.0.0"
+version = "1.0.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "14e4fcc00ff6731d94b70e16e71f43bda62883461f31230742e3bc6dddf12988"
+checksum = "e0500463acd96259d219abb05dc57e5a076ef04b2db9a2112846929b5f174c96"
 dependencies = [
  "libc",
  "uuid",
@@ -1950,9 +1934,9 @@ dependencies = [
 
 [[package]]
 name = "lock_api"
-version = "0.4.7"
+version = "0.4.9"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "327fa5b6a6940e4699ec49a9beae1ea4845c6bab9314e4f84ac68742139d8c53"
+checksum = "435011366fe56583b16cf956f9df0095b405b82d76425bc8981c0e22e60ec4df"
 dependencies = [
  "autocfg 1.1.0",
  "scopeguard",
@@ -1960,12 +1944,9 @@ dependencies = [
 
 [[package]]
 name = "log"
-version = "0.4.17"
+version = "0.4.18"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "abb12e687cfb44aa40f41fc3978ef76448f9b6038cad6aef4259d3c095a2382e"
-dependencies = [
- "cfg-if",
-]
+checksum = "518ef76f2f87365916b142844c16d8fefd85039bc5699050210a7778ee1cd1de"
 
 [[package]]
 name = "mach"
@@ -2015,15 +1996,6 @@ dependencies = [
  "libc",
 ]
 
-[[package]]
-name = "memoffset"
-version = "0.6.5"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "5aa361d4faea93603064a027415f07bd8e1d5c88c9fbf68bf56a285428fd79ce"
-dependencies = [
- "autocfg 1.1.0",
-]
-
 [[package]]
 name = "memoffset"
 version = "0.8.0"
@@ -2044,14 +2016,13 @@ dependencies = [
 
 [[package]]
 name = "mio"
-version = "0.8.6"
+version = "0.8.8"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "5b9d9a46eff5b4ff64b45a9e316a6d1e0bc719ef429cbec4dc630684212bfdf9"
+checksum = "927a765cd3fc26206e66b296465fa9d3e5ab003e651c1b3c060e7956d96b19d2"
 dependencies = [
  "libc",
- "log",
  "wasi 0.11.0+wasi-snapshot-preview1",
- "windows-sys 0.45.0",
+ "windows-sys 0.48.0",
 ]
 
 [[package]]
@@ -2128,7 +2099,7 @@ checksum = "ea86265d3d3dcb6a27fc51bd29a4bf387fae9d2986b823079d4986af253eb439"
 dependencies = [
  "crc32fast",
  "hashbrown 0.13.2",
- "indexmap 1.9.1",
+ "indexmap",
  "memchr",
 ]
 
@@ -2214,9 +2185,9 @@ dependencies = [
 
 [[package]]
 name = "os_str_bytes"
-version = "6.0.0"
+version = "6.5.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "8e22443d1643a904602595ba1cd8f7d896afe56d26712531c5ff73a15b2fbf64"
+checksum = "ceedf44fb00f2d1984b0bc98102627ce622e083e49a5bacdb3e514fa4238e267"
 
 [[package]]
 name = "p256"
@@ -2242,23 +2213,23 @@ dependencies = [
 
 [[package]]
 name = "parking_lot_core"
-version = "0.8.5"
+version = "0.8.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "d76e8e1493bcac0d2766c42737f34458f1c8c50c0d23bcb24ea953affb273216"
+checksum = "60a2cfe6f0ad2bfc16aefa463b497d5c7a5ecd44a23efa72aa342d90177356dc"
 dependencies = [
  "cfg-if",
  "instant",
  "libc",
- "redox_syscall 0.2.13",
+ "redox_syscall 0.2.16",
  "smallvec",
  "winapi",
 ]
 
 [[package]]
 name = "paste"
-version = "1.0.7"
+version = "1.0.12"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "0c520e05135d6e763148b6426a837e239041653ba7becd2e538c076c738025fc"
+checksum = "9f746c4065a8fa3fe23974dd82f15431cc8d40779821001404d10d2e79ca7d79"
 
 [[package]]
 name = "pem-rfc7468"
@@ -2311,11 +2282,17 @@ dependencies = [
  "zeroize",
 ]
 
+[[package]]
+name = "pkg-config"
+version = "0.3.27"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "26072860ba924cbfa98ea39c8c19b4dd6a4a25423dbdf219c1eca91aa0cf6964"
+
 [[package]]
 name = "plotters"
-version = "0.3.1"
+version = "0.3.4"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "32a3fd9ec30b9749ce28cd91f255d569591cdf937fe280c312143e3c4bad6f2a"
+checksum = "2538b639e642295546c50fcd545198c9d64ee2a38620a628724a3b266d5fbf97"
 dependencies = [
  "num-traits",
  "plotters-backend",
@@ -2326,15 +2303,15 @@ dependencies = [
 
 [[package]]
 name = "plotters-backend"
-version = "0.3.2"
+version = "0.3.4"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "d88417318da0eaf0fdcdb51a0ee6c3bed624333bff8f946733049380be67ac1c"
+checksum = "193228616381fecdc1224c62e96946dfbc73ff4384fba576e052ff8c1bea8142"
 
 [[package]]
 name = "plotters-svg"
-version = "0.3.1"
+version = "0.3.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "521fa9638fa597e1dc53e9412a4f9cefb01187ee1f7413076f9e6749e2885ba9"
+checksum = "f9a81d2759aae1dae668f783c308bc5c8ebd191ff4184aaa1b37f65a6ae5a56f"
 dependencies = [
  "plotters-backend",
 ]
@@ -2364,9 +2341,9 @@ dependencies = [
 
 [[package]]
 name = "ppv-lite86"
-version = "0.2.16"
+version = "0.2.17"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "eb9f9e6e233e5c4a35559a617bf40a4ec447db2e84c20b55a6f83167b7e57872"
+checksum = "5b40af805b3121feab8a3c29f04d8ad262fa8e0561883e7653e024ae4479e6de"
 
 [[package]]
 name = "pqcrypto"
@@ -2392,9 +2369,9 @@ dependencies = [
 
 [[package]]
 name = "pqcrypto-kyber"
-version = "0.7.5"
+version = "0.7.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "8a17989a978f7d7c1496e38806ad9ff11f36eb8e419c562eafddbbf176af4a8a"
+checksum = "fe9d9695c19e525d5366c913562a331fbeef9a2ad801d9a9ded61a0e4c2fe0fb"
 dependencies = [
  "cc",
  "glob",
@@ -2428,7 +2405,7 @@ dependencies = [
  "proc-macro-error-attr",
  "proc-macro2",
  "quote",
- "syn 1.0.92",
+ "syn 1.0.109",
  "version_check",
 ]
 
@@ -2445,38 +2422,38 @@ dependencies = [
 
 [[package]]
 name = "proc-macro2"
-version = "1.0.63"
+version = "1.0.59"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "7b368fba921b0dce7e60f5e04ec15e565b3303972b42bcfde1d0713b881959eb"
+checksum = "6aeca18b86b413c660b781aa319e4e2648a3e6f9eadc9b47e9038e6fe9f3451b"
 dependencies = [
  "unicode-ident",
 ]
 
 [[package]]
 name = "proptest"
-version = "1.0.0"
+version = "1.2.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "1e0d9cc07f18492d879586c92b485def06bc850da3118075cd45d50e9c95b0e5"
+checksum = "4e35c06b98bf36aba164cc17cb25f7e232f5c4aeea73baa14b8a9f0d92dbfa65"
 dependencies = [
  "bit-set",
  "bitflags 1.3.2",
  "byteorder",
  "lazy_static",
  "num-traits",
- "quick-error 2.0.1",
  "rand 0.8.5",
  "rand_chacha 0.3.1",
  "rand_xorshift",
- "regex-syntax",
+ "regex-syntax 0.6.29",
  "rusty-fork",
  "tempfile",
+ "unarray",
 ]
 
 [[package]]
 name = "psm"
-version = "0.1.18"
+version = "0.1.21"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "871372391786ccec00d3c5d3d6608905b3d4db263639cfe075d3b60a736d115a"
+checksum = "5787f7cda34e3033a72192c018bc5883100330f362ef279a8cbccfce8bb4e874"
 dependencies = [
  "cc",
 ]
@@ -2492,34 +2469,17 @@ dependencies = [
  "unicase",
 ]
 
-[[package]]
-name = "pulldown-cmark"
-version = "0.9.3"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "77a1a2f1f0a7ecff9c31abbe177637be0e97a0aef46cf8738ece09327985d998"
-dependencies = [
- "bitflags 1.3.2",
- "memchr",
- "unicase",
-]
-
 [[package]]
 name = "quick-error"
 version = "1.2.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "a1d01941d82fa2ab50be1e79e6714289dd7cde78eba4c074bc5a4374f650dfe0"
 
-[[package]]
-name = "quick-error"
-version = "2.0.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "a993555f31e5a609f617c12db6250dedcac1b0a85076912c436e6fc9b2c8e6a3"
-
 [[package]]
 name = "quote"
-version = "1.0.29"
+version = "1.0.28"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "573015e8ab27661678357f27dc26460738fd2b6c86e46f386fde94cb5d913105"
+checksum = "1b9ab9c7eadfd8df19006f1cf1a4aed13540ed5cbc047010ece5826e10825488"
 dependencies = [
  "proc-macro2",
 ]
@@ -2545,7 +2505,7 @@ checksum = "34af8d1a0e25924bc5b7c43c079c942339d8f0a8b57c39049bef581b46327404"
 dependencies = [
  "libc",
  "rand_chacha 0.3.1",
- "rand_core 0.6.3",
+ "rand_core 0.6.4",
 ]
 
 [[package]]
@@ -2565,7 +2525,7 @@ source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "e6c10a63a0fa32252be49d21e7709d4d4baf8d231c2dbce1eaa8141b9b127d88"
 dependencies = [
  "ppv-lite86",
- "rand_core 0.6.3",
+ "rand_core 0.6.4",
 ]
 
 [[package]]
@@ -2579,9 +2539,9 @@ dependencies = [
 
 [[package]]
 name = "rand_core"
-version = "0.6.3"
+version = "0.6.4"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "d34f1408f55294453790c48b2f1ebbb1c5b4b7563eb1f418bcfcfdbb06ebb4e7"
+checksum = "ec0be4795e2f6a28069bec0b5ff3e2ac9bafc99e6a9a7dc3547996c5c816922c"
 dependencies = [
  "getrandom 0.2.9",
 ]
@@ -2601,7 +2561,7 @@ version = "0.3.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "d25bf25ec5ae4a3f1b92f929810509a2f53d7dca2f50b794ff57e3face536c8f"
 dependencies = [
- "rand_core 0.6.3",
+ "rand_core 0.6.4",
 ]
 
 [[package]]
@@ -2612,21 +2572,19 @@ checksum = "04d0088f16afb86d12c7f239d8de4637fa68ecc99a3db227e1ab58a294713e60"
 
 [[package]]
 name = "rayon"
-version = "1.5.3"
+version = "1.7.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "bd99e5772ead8baa5215278c9b15bf92087709e9c1b2d1f97cdb5a183c933a7d"
+checksum = "1d2df5196e37bcc87abebc0053e20787d73847bb33134a69841207dd0a47f03b"
 dependencies = [
- "autocfg 1.1.0",
- "crossbeam-deque",
  "either",
  "rayon-core",
 ]
 
 [[package]]
 name = "rayon-core"
-version = "1.9.3"
+version = "1.11.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "258bcdb5ac6dad48491bb2992db6b7cf74878b0384908af124823d118c99683f"
+checksum = "4b8f95bd6966f5c87776639160a66bd8ab9895d9d4ab01ddba9fc60661aebe8d"
 dependencies = [
  "crossbeam-channel",
  "crossbeam-deque",
@@ -2643,9 +2601,9 @@ dependencies = [
 
 [[package]]
 name = "redox_syscall"
-version = "0.2.13"
+version = "0.2.16"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "62f25bc4c7e55e0b0b7a1d43fb893f4fa1361d0abe38b9ce4f323c2adfe6ef42"
+checksum = "fb5a58c1855b4b6819d59012155603f0b22ad30cad752600aadfcb695265519a"
 dependencies = [
  "bitflags 1.3.2",
 ]
@@ -2666,7 +2624,7 @@ source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "b033d837a7cf162d7993aded9304e30a83213c648b6e389db233191f891e5c2b"
 dependencies = [
  "getrandom 0.2.9",
- "redox_syscall 0.2.13",
+ "redox_syscall 0.2.16",
  "thiserror",
 ]
 
@@ -2686,13 +2644,13 @@ dependencies = [
 
 [[package]]
 name = "regex"
-version = "1.5.5"
+version = "1.8.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "1a11647b6b25ff05a515cb92c365cec08801e83423a235b51e231e1808747286"
+checksum = "81ca098a9821bd52d6b24fd8b10bd081f47d39c22778cafaa75a2857a62c6390"
 dependencies = [
  "aho-corasick",
  "memchr",
- "regex-syntax",
+ "regex-syntax 0.7.2",
 ]
 
 [[package]]
@@ -2701,14 +2659,20 @@ version = "0.1.10"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "6c230d73fb8d8c1b9c0b3135c5142a8acee3a0558fb8db5cf1cb65f8d7862132"
 dependencies = [
- "regex-syntax",
+ "regex-syntax 0.6.29",
 ]
 
 [[package]]
 name = "regex-syntax"
-version = "0.6.25"
+version = "0.6.29"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f162c6dd7b008981e4d40210aca20b4bd0f9b60ca9271061b07f78537722f2e1"
+
+[[package]]
+name = "regex-syntax"
+version = "0.7.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "f497285884f3fcff424ffc933e56d7cbca511def0c9831a7f9b5f6153e3cc89b"
+checksum = "436b050e76ed2903236f032a59761c1eb99e1b0aead2c257922771dab1fc8c78"
 
 [[package]]
 name = "region"
@@ -2760,9 +2724,9 @@ dependencies = [
 
 [[package]]
 name = "rustc-demangle"
-version = "0.1.21"
+version = "0.1.23"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "7ef03e0a2b150c7a90d01faf6254c9c48a41e95fb2a8c2ac1c6f0d2b9aefc342"
+checksum = "d626bb9dae77e28219937af045c257c28bfd3f69333c512553507f5f9798cb76"
 
 [[package]]
 name = "rustc-hash"
@@ -2772,9 +2736,9 @@ checksum = "08d43f7aa6b08d49f382cde6a7982047c3426db949b1424bc4b7ec9ae12c6ce2"
 
 [[package]]
 name = "rustix"
-version = "0.37.13"
+version = "0.37.19"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "f79bef90eb6d984c72722595b5b1348ab39275a5e5123faca6863bf07d75a4e0"
+checksum = "acf8729d8542766f1b2cf77eb034d52f40d375bb8b615d0b147089946e16613d"
 dependencies = [
  "bitflags 1.3.2",
  "errno",
@@ -2788,9 +2752,9 @@ dependencies = [
 
 [[package]]
 name = "rustls"
-version = "0.21.0"
+version = "0.21.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "07180898a28ed6a7f7ba2311594308f595e3dd2e3c3812fa0a80a47b45f17e5d"
+checksum = "c911ba11bc8433e811ce56fde130ccf32f5127cab0e0194e9c68c5a5b671791e"
 dependencies = [
  "log",
  "ring",
@@ -2815,16 +2779,16 @@ source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "cb3dcc6e454c328bb824492db107ab7c0ae8fcffe4ad210136ef014458c1bc4f"
 dependencies = [
  "fnv",
- "quick-error 1.2.3",
+ "quick-error",
  "tempfile",
  "wait-timeout",
 ]
 
 [[package]]
 name = "ryu"
-version = "1.0.9"
+version = "1.0.13"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "73b4b750c782965c211b42f022f59af1fbceabdd026623714f104152f1ec149f"
+checksum = "f91339c0467de62360649f8d3e185ca8de4224ff281f66000de5eb2a77a79041"
 
 [[package]]
 name = "same-file"
@@ -2862,29 +2826,29 @@ dependencies = [
 
 [[package]]
 name = "serde"
-version = "1.0.171"
+version = "1.0.163"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "30e27d1e4fd7659406c492fd6cfaf2066ba8773de45ca75e855590f856dc34a9"
+checksum = "2113ab51b87a539ae008b5c6c02dc020ffa39afd2d83cffcb3f4eb2722cebec2"
 dependencies = [
  "serde_derive",
 ]
 
 [[package]]
 name = "serde_derive"
-version = "1.0.171"
+version = "1.0.163"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "389894603bd18c46fa56231694f8d827779c0951a667087194cf9de94ed24682"
+checksum = "8c805777e3930c8883389c602315a24224bcc738b63905ef87cd1420353ea93e"
 dependencies = [
  "proc-macro2",
  "quote",
- "syn 2.0.25",
+ "syn 2.0.18",
 ]
 
 [[package]]
 name = "serde_json"
-version = "1.0.80"
+version = "1.0.96"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "f972498cf015f7c0746cac89ebe1d6ef10c293b94175a243a2d9442c163d9944"
+checksum = "057d394a50403bcac12672b2b18fb387ab6d289d957dab67dd201875391e52f1"
 dependencies = [
  "itoa",
  "ryu",
@@ -2906,13 +2870,13 @@ dependencies = [
 
 [[package]]
 name = "sha2"
-version = "0.10.2"
+version = "0.10.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "55deaec60f81eefe3cce0dc50bda92d6d8e88f2a27df7c5033b42afeb1ed2676"
+checksum = "82e6b795fe2e3b1e845bafcb27aa35405c4d47cdfc92af5fc8d3002f76cebdc0"
 dependencies = [
  "cfg-if",
  "cpufeatures",
- "digest 0.10.3",
+ "digest 0.10.7",
 ]
 
 [[package]]
@@ -2926,11 +2890,11 @@ dependencies = [
 
 [[package]]
 name = "shellexpand"
-version = "2.1.0"
+version = "2.1.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "83bdb7831b2d85ddf4a7b148aa19d0587eddbe8671a436b7bd1182eaad0f2829"
+checksum = "7ccc8076840c4da029af4f87e4e8daeb0fca6b87bbb02e10cb60b791450e11e4"
 dependencies = [
- "dirs-next",
+ "dirs",
 ]
 
 [[package]]
@@ -2952,20 +2916,20 @@ source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "f2807892cfa58e081aa1f1111391c7a0649d4fa127a4ffbe34bcbfb35a1171a4"
 dependencies = [
  "digest 0.9.0",
- "rand_core 0.6.3",
+ "rand_core 0.6.4",
 ]
 
 [[package]]
 name = "similar"
-version = "2.2.0"
+version = "2.2.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "62ac7f900db32bf3fd12e0117dd3dc4da74bc52ebaac97f39668446d89694803"
+checksum = "420acb44afdae038210c99e69aae24109f32f15500aa708e81d46c9f29d55fcf"
 
 [[package]]
 name = "slab"
-version = "0.4.7"
+version = "0.4.8"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "4614a76b2a8be0058caa9dbbaf66d988527d86d003c11a94fbd335d7661edcef"
+checksum = "6528351c9bc8ab22353f9d776db39a20288e8d6c37ef8cfe3317cf875eecfc2d"
 dependencies = [
  "autocfg 1.1.0",
 ]
@@ -2978,18 +2942,18 @@ checksum = "826167069c09b99d56f31e9ae5c99049e932a98c9dc2dac47645b08dbbf76ba7"
 
 [[package]]
 name = "smallvec"
-version = "1.8.0"
+version = "1.10.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "f2dd574626839106c320a323308629dcb1acfc96e32a8cba364ddc61ac23ee83"
+checksum = "a507befe795404456341dfab10cef66ead4c041f62b8b11bbb92bffe5d0953e0"
 dependencies = [
  "serde",
 ]
 
 [[package]]
 name = "socket2"
-version = "0.4.7"
+version = "0.4.9"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "02e2d2db9033d13a1567121ddd7a095ee144db4e1ca1b1bda3419bc0da294ebd"
+checksum = "64a4a911eed85daf18834cfaa86a79b7d266ff93ff5ba14005426219480ed662"
 dependencies = [
  "libc",
  "winapi",
@@ -3004,15 +2968,6 @@ dependencies = [
  "id-arena",
 ]
 
-[[package]]
-name = "spdx"
-version = "0.10.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "2971cb691ca629f46174f73b1f95356c5617f89b4167f04107167c3dccb8dd89"
-dependencies = [
- "smallvec",
-]
-
 [[package]]
 name = "spin"
 version = "0.5.2"
@@ -3021,9 +2976,9 @@ checksum = "6e63cff320ae2c57904679ba7cb63280a3dc4613885beafb148ee7bf9aa9042d"
 
 [[package]]
 name = "spin"
-version = "0.9.4"
+version = "0.9.8"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "7f6002a767bff9e83f8eeecf883ecb8011875a21ae8da43bffb817a57e78cc09"
+checksum = "6980e8d7511241f8acf4aebddbb1ff938df5eebe98691418c4468d0b72a96a67"
 
 [[package]]
 name = "spki"
@@ -3072,38 +3027,26 @@ checksum = "7c68d531d83ec6c531150584c42a4290911964d5f0d79132b193b67252a23b71"
 
 [[package]]
 name = "syn"
-version = "1.0.92"
+version = "1.0.109"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "7ff7c592601f11445996a06f8ad0c27f094a58857c2f89e97974ab9235b92c52"
+checksum = "72b64191b275b66ffe2469e8af2c1cfe3bafa67b529ead792a6d0160888b4237"
 dependencies = [
  "proc-macro2",
  "quote",
- "unicode-xid",
+ "unicode-ident",
 ]
 
 [[package]]
 name = "syn"
-version = "2.0.25"
+version = "2.0.18"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "15e3fc8c0c74267e2df136e5e5fb656a464158aa57624053375eb9c8c6e25ae2"
+checksum = "32d41677bcbe24c20c52e7c70b0d8db04134c5d1066bf98662e2871ad200ea3e"
 dependencies = [
  "proc-macro2",
  "quote",
  "unicode-ident",
 ]
 
-[[package]]
-name = "synstructure"
-version = "0.12.6"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "f36bdaa60a83aca3921b5259d5400cbf5e90fc51931376a9bd4a0eb79aa7210f"
-dependencies = [
- "proc-macro2",
- "quote",
- "syn 1.0.92",
- "unicode-xid",
-]
-
 [[package]]
 name = "system-interface"
 version = "0.25.7"
@@ -3122,9 +3065,9 @@ dependencies = [
 
 [[package]]
 name = "target-lexicon"
-version = "0.12.3"
+version = "0.12.7"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "d7fa7e55043acb85fca6b3c01485a2eeb6b69c5d21002e273c79e465f43b7ac1"
+checksum = "fd1ba337640d60c3e96bc6f0638a939b9c9a7f2c316a1598c279828b3d1dc8c5"
 
 [[package]]
 name = "tempfile"
@@ -3141,23 +3084,13 @@ dependencies = [
 
 [[package]]
 name = "termcolor"
-version = "1.1.3"
+version = "1.2.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "bab24d30b911b2376f3a13cc2cd443142f0c81dda04c118693e35b3835757755"
+checksum = "be55cf8942feac5c765c2c993422806843c9a9a45d4d5c407ad6dd2ea95eb9b6"
 dependencies = [
  "winapi-util",
 ]
 
-[[package]]
-name = "terminal_size"
-version = "0.1.17"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "633c1a546cee861a1a6d0dc69ebeca693bf4296661ba7852b9d21d159e0506df"
-dependencies = [
- "libc",
- "winapi",
-]
-
 [[package]]
 name = "test-log"
 version = "0.2.11"
@@ -3166,7 +3099,7 @@ checksum = "38f0c854faeb68a048f0f2dc410c5ddae3bf83854ef0e4977d58306a5edef50e"
 dependencies = [
  "proc-macro2",
  "quote",
- "syn 1.0.92",
+ "syn 1.0.109",
 ]
 
 [[package]]
@@ -3194,41 +3127,42 @@ dependencies = [
  "wasmtime",
  "wasmtime-wasi",
  "wasmtime-wasi-http",
- "wit-component 0.12.0",
+ "wit-component",
 ]
 
 [[package]]
 name = "textwrap"
-version = "0.15.0"
+version = "0.16.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "b1141d4d61095b28419e22cb0bbf02755f5e54e0526f97f1e3d1d160e60885fb"
+checksum = "222a222a5bfe1bba4a77b45ec488a741b3cb8872e5e499451fd7d0129c9c7c3d"
 
 [[package]]
 name = "thiserror"
-version = "1.0.31"
+version = "1.0.40"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "bd829fe32373d27f76265620b5309d0340cb8550f523c1dda251d6298069069a"
+checksum = "978c9a314bd8dc99be594bc3c175faaa9794be04a5a5e153caba6915336cebac"
 dependencies = [
  "thiserror-impl",
 ]
 
 [[package]]
 name = "thiserror-impl"
-version = "1.0.31"
+version = "1.0.40"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "0396bc89e626244658bef819e22d0cc459e795a5ebe878e6ec336d1674a8d79a"
+checksum = "f9456a42c5b0d803c8cd86e73dd7cc9edd429499f37a3550d286d5e86720569f"
 dependencies = [
  "proc-macro2",
  "quote",
- "syn 1.0.92",
+ "syn 2.0.18",
 ]
 
 [[package]]
 name = "thread_local"
-version = "1.1.4"
+version = "1.1.7"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "5516c27b78311c50bf42c071425c560ac799b11c30b31f87e3081965fe5e0180"
+checksum = "3fdd6f064ccff2d6567adcb3873ca630700f00b5ad3f060c25b5dcfd9a4ce152"
 dependencies = [
+ "cfg-if",
  "once_cell",
 ]
 
@@ -3253,37 +3187,36 @@ dependencies = [
 
 [[package]]
 name = "tinyvec_macros"
-version = "0.1.0"
+version = "0.1.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "cda74da7e1a664f795bb1f8a87ec406fb89a02522cf6e50620d016add6dbbf5c"
+checksum = "1f3ccbac311fea05f86f61904b462b55fb3df8837a366dfc601a0161d0532f20"
 
 [[package]]
 name = "tokio"
-version = "1.26.0"
+version = "1.28.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "03201d01c3c27a29c8a5cee5b55a93ddae1ccf6f08f65365c2c918f8c1b76f64"
+checksum = "94d7b1cfd2aa4011f2de74c2c4c63665e27a71006b0a192dcd2710272e73dfa2"
 dependencies = [
  "autocfg 1.1.0",
  "bytes",
  "libc",
- "memchr",
  "mio",
  "num_cpus",
  "pin-project-lite",
  "socket2",
  "tokio-macros",
- "windows-sys 0.45.0",
+ "windows-sys 0.48.0",
 ]
 
 [[package]]
 name = "tokio-macros"
-version = "1.7.0"
+version = "2.1.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "b557f72f448c511a979e2564e55d74e6c4432fc96ff4f6241bc6bded342643b7"
+checksum = "630bdcf245f78637c13ec01ffae6187cca34625e8c63150d424b59e55af2675e"
 dependencies = [
  "proc-macro2",
  "quote",
- "syn 1.0.92",
+ "syn 2.0.18",
 ]
 
 [[package]]
@@ -3298,9 +3231,9 @@ dependencies = [
 
 [[package]]
 name = "tokio-util"
-version = "0.7.4"
+version = "0.7.8"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "0bb2e075f03b3d66d8d8785356224ba688d2906a371015e225beeb65ca92c740"
+checksum = "806fe8c2c87eccc8b3267cbae29ed3ab2d0bd37fca70ab622e46aaa9375ddb7d"
 dependencies = [
  "bytes",
  "futures-core",
@@ -3312,18 +3245,18 @@ dependencies = [
 
 [[package]]
 name = "toml"
-version = "0.5.9"
+version = "0.5.11"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "8d82e1a7758622a465f8cee077614c73484dac5b836c02ff6a40d5d1010324d7"
+checksum = "f4f7f0dd8d50a853a531c426359045b1998f04219d88799810762cd4ad314234"
 dependencies = [
  "serde",
 ]
 
 [[package]]
 name = "tracing"
-version = "0.1.34"
+version = "0.1.37"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "5d0ecdcb44a79f0fe9844f0c4f33a342cbcbb5117de8001e6ba0dc2351327d09"
+checksum = "8ce8c33a8d48bd45d624a6e523445fd21ec13d3653cd51f681abf67418f54eb8"
 dependencies = [
  "cfg-if",
  "log",
@@ -3334,33 +3267,32 @@ dependencies = [
 
 [[package]]
 name = "tracing-attributes"
-version = "0.1.21"
+version = "0.1.24"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "cc6b8ad3567499f98a1db7a752b07a7c8c7c7c34c332ec00effb2b0027974b7c"
+checksum = "0f57e3ca2a01450b1a921183a9c9cbfda207fd822cef4ccb00a65402cbba7a74"
 dependencies = [
  "proc-macro2",
  "quote",
- "syn 1.0.92",
+ "syn 2.0.18",
 ]
 
 [[package]]
 name = "tracing-core"
-version = "0.1.28"
+version = "0.1.31"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "7b7358be39f2f274f322d2aaed611acc57f382e8eb1e5b48cb9ae30933495ce7"
+checksum = "0955b8137a1df6f1a2e9a37d8a6656291ff0297c1a97c24e0d8425fe2312f79a"
 dependencies = [
  "once_cell",
- "valuable",
 ]
 
 [[package]]
 name = "tracing-subscriber"
-version = "0.3.11"
+version = "0.3.17"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "4bc28f93baff38037f64e6f43d34cfa1605f27a49c34e8a04c5e78b0babf2596"
+checksum = "30a651bc37f915e81f087d86e62a18eec5f79550c7faff886f7090b4ea757c77"
 dependencies = [
- "lazy_static",
  "matchers",
+ "once_cell",
  "regex",
  "sharded-slab",
  "thread_local",
@@ -3376,9 +3308,15 @@ checksum = "3528ecfd12c466c6f163363caf2d02a71161dd5e1cc6ae7b34207ea2d42d81ed"
 
 [[package]]
 name = "typenum"
-version = "1.15.0"
+version = "1.16.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "497961ef93d974e23eb6f433eb5fe1b7930b659f06d12dec6fc44a8f554c0bba"
+
+[[package]]
+name = "unarray"
+version = "0.1.4"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "dcf81ac59edc17cc8697ff311e8f5ef2d99fcbd9817b34cec66f90b6c3dfd987"
+checksum = "eaea85b334db583fe3274d12b4cd1880032beab409c0d774be044d4480ab9a94"
 
 [[package]]
 name = "unicase"
@@ -3391,21 +3329,21 @@ dependencies = [
 
 [[package]]
 name = "unicode-bidi"
-version = "0.3.8"
+version = "0.3.13"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "099b7128301d285f79ddd55b9a83d5e6b9e97c92e0ea0daebee7263e932de992"
+checksum = "92888ba5573ff080736b3648696b70cafad7d250551175acbaa4e0385b3e1460"
 
 [[package]]
 name = "unicode-ident"
-version = "1.0.8"
+version = "1.0.9"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "e5464a87b239f13a63a501f2701565754bae92d243d4bb7eb12f6d57d2269bf4"
+checksum = "b15811caf2415fb889178633e7724bad2509101cde276048e013b9def5e51fa0"
 
 [[package]]
 name = "unicode-normalization"
-version = "0.1.21"
+version = "0.1.22"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "854cbdc4f7bc6ae19c820d44abdc3277ac3e1b2b93db20a636825d9322fb60e6"
+checksum = "5c5713f0fc4b5db668a2ac63cdb7bb4469d8c9fed047b1d0292cc7b0ce2ba921"
 dependencies = [
  "tinyvec",
 ]
@@ -3418,15 +3356,15 @@ checksum = "1dd624098567895118886609431a7c3b8f516e41d30e0643f03d94592a147e36"
 
 [[package]]
 name = "unicode-width"
-version = "0.1.9"
+version = "0.1.10"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "3ed742d4ea2bd1176e236172c8429aaf54486e7ac098db29ffe6529e0ce50973"
+checksum = "c0edd1e5b14653f783770bce4a4dabb4a5108a5370a5f5d8cfe8710c361f6c8b"
 
 [[package]]
 name = "unicode-xid"
-version = "0.2.3"
+version = "0.2.4"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "957e51f3646910546462e67d5f7599b9e4fb8acdd304b087a6494730f9eebf04"
+checksum = "f962df74c8c05a667b5ee8bcf162993134c104e96440b663c8daa176dc772d8c"
 
 [[package]]
 name = "universal-hash"
@@ -3457,38 +3395,33 @@ dependencies = [
 
 [[package]]
 name = "uuid"
-version = "1.0.0"
+version = "1.3.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "8cfcd319456c4d6ea10087ed423473267e1a071f3bc0aa89f80d60997843c6f0"
+checksum = "345444e32442451b267fc254ae85a209c64be56d2890e601a0c37ff0c3c5ecd2"
 dependencies = [
  "getrandom 0.2.9",
 ]
 
 [[package]]
 name = "v8"
-version = "0.74.1"
+version = "0.44.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "1202e0bd078112bf8d521491560645e1fd6955c4afd975c75b05596a7e7e4eea"
+checksum = "f3f92c29dd66c7342443280695afc5bb79d773c3aa3eb02978cf24f058ae2b3d"
 dependencies = [
  "bitflags 1.3.2",
  "fslock",
- "once_cell",
+ "lazy_static",
+ "libc",
  "which",
 ]
 
-[[package]]
-name = "valuable"
-version = "0.1.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "830b7e5d4d90034032940e4ace0d9a9a057e7a45cd94e6c007832e39edb82f6d"
-
 [[package]]
 name = "verify-component-adapter"
-version = "12.0.0"
+version = "11.0.0"
 dependencies = [
  "anyhow",
  "wasmparser 0.92.0",
- "wat",
+ "wat 1.0.66 (registry+https://github.com/rust-lang/crates.io-index)",
 ]
 
 [[package]]
@@ -3540,7 +3473,7 @@ checksum = "9c8d87e72b64a3b4db28d11ce29237c246188f4f51057d65a7eab63b7987e423"
 
 [[package]]
 name = "wasi-cap-std-sync"
-version = "12.0.0"
+version = "11.0.0"
 dependencies = [
  "anyhow",
  "async-trait",
@@ -3563,7 +3496,7 @@ dependencies = [
 
 [[package]]
 name = "wasi-common"
-version = "12.0.0"
+version = "11.0.0"
 dependencies = [
  "anyhow",
  "bitflags 1.3.2",
@@ -3598,7 +3531,7 @@ dependencies = [
  "parking_lot",
  "pqcrypto",
  "rand_core 0.5.1",
- "rand_core 0.6.3",
+ "rand_core 0.6.4",
  "rsa",
  "serde",
  "sha2 0.9.9",
@@ -3618,7 +3551,7 @@ dependencies = [
 
 [[package]]
 name = "wasi-preview1-component-adapter"
-version = "12.0.0"
+version = "11.0.0"
 dependencies = [
  "byte-array-literals",
  "object",
@@ -3638,7 +3571,7 @@ dependencies = [
 
 [[package]]
 name = "wasi-tokio"
-version = "12.0.0"
+version = "11.0.0"
 dependencies = [
  "anyhow",
  "cap-std",
@@ -3655,9 +3588,9 @@ dependencies = [
 
 [[package]]
 name = "wasm-bindgen"
-version = "0.2.80"
+version = "0.2.86"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "27370197c907c55e3f1a9fbe26f44e937fe6451368324e009cba39e139dc08ad"
+checksum = "5bba0e8cb82ba49ff4e229459ff22a191bbe9a1cb3a341610c9c33efc27ddf73"
 dependencies = [
  "cfg-if",
  "wasm-bindgen-macro",
@@ -3665,24 +3598,24 @@ dependencies = [
 
 [[package]]
 name = "wasm-bindgen-backend"
-version = "0.2.80"
+version = "0.2.86"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "53e04185bfa3a779273da532f5025e33398409573f348985af9a1cbf3774d3f4"
+checksum = "19b04bc93f9d6bdee709f6bd2118f57dd6679cf1176a1af464fca3ab0d66d8fb"
 dependencies = [
  "bumpalo",
- "lazy_static",
  "log",
+ "once_cell",
  "proc-macro2",
  "quote",
- "syn 1.0.92",
+ "syn 2.0.18",
  "wasm-bindgen-shared",
 ]
 
 [[package]]
 name = "wasm-bindgen-macro"
-version = "0.2.80"
+version = "0.2.86"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "17cae7ff784d7e83a2fe7611cfe766ecf034111b49deb850a3dc7699c08251f5"
+checksum = "14d6b024f1a526bb0234f52840389927257beb670610081360e5a03c5df9c258"
 dependencies = [
  "quote",
  "wasm-bindgen-macro-support",
@@ -3690,22 +3623,22 @@ dependencies = [
 
 [[package]]
 name = "wasm-bindgen-macro-support"
-version = "0.2.80"
+version = "0.2.86"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "99ec0dc7a4756fffc231aab1b9f2f578d23cd391390ab27f952ae0c9b3ece20b"
+checksum = "e128beba882dd1eb6200e1dc92ae6c5dbaa4311aa7bb211ca035779e5efc39f8"
 dependencies = [
  "proc-macro2",
  "quote",
- "syn 1.0.92",
+ "syn 2.0.18",
  "wasm-bindgen-backend",
  "wasm-bindgen-shared",
 ]
 
 [[package]]
 name = "wasm-bindgen-shared"
-version = "0.2.80"
+version = "0.2.86"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "d554b7f530dee5964d9a9468d95c1f8b8acae4f282807e7d27d4b03099a46744"
+checksum = "ed9d5b4305409d1fc9482fee2d7f9bcbf24b3972bf59817ef757e23982242a93"
 
 [[package]]
 name = "wasm-encoder"
@@ -3727,9 +3660,8 @@ dependencies = [
 
 [[package]]
 name = "wasm-encoder"
-version = "0.30.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "b2f8e9778e04cbf44f58acc301372577375a666b966c50b03ef46144f80436a8"
+version = "0.29.0"
+source = "git+https://github.com/effect-handlers/wasm-tools?branch=typed-continuations#403d7946f07feab87ed4b4b58a8b2130487f488f"
 dependencies = [
  "leb128",
 ]
@@ -3741,53 +3673,38 @@ source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "36e5156581ff4a302405c44ca7c85347563ca431d15f1a773f12c9c7b9a6cdc9"
 dependencies = [
  "anyhow",
- "indexmap 1.9.1",
- "serde",
- "wasm-encoder 0.29.0",
- "wasmparser 0.107.0",
-]
-
-[[package]]
-name = "wasm-metadata"
-version = "0.9.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "d51db59397fc650b5f2fc778e4a5c4456cd856bed7fc1ec15f8d3e28229dc463"
-dependencies = [
- "anyhow",
- "indexmap 2.0.0",
+ "indexmap",
  "serde",
- "serde_json",
- "spdx",
- "wasm-encoder 0.30.0",
- "wasmparser 0.108.0",
+ "wasm-encoder 0.29.0 (registry+https://github.com/rust-lang/crates.io-index)",
+ "wasmparser 0.107.0 (registry+https://github.com/rust-lang/crates.io-index)",
 ]
 
 [[package]]
 name = "wasm-mutate"
-version = "0.2.28"
+version = "0.2.27"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "97aa47493e9a6d9615d99866bc13cbf0ae38fb5b9c4846a13feeb68191d6051a"
+checksum = "f354beb7e2ccaf66dd263328486240899755ae0df3ac4b76305dace67fbd2169"
 dependencies = [
  "egg",
  "log",
  "rand 0.8.5",
  "thiserror",
- "wasm-encoder 0.30.0",
- "wasmparser 0.108.0",
+ "wasm-encoder 0.29.0 (registry+https://github.com/rust-lang/crates.io-index)",
+ "wasmparser 0.107.0 (registry+https://github.com/rust-lang/crates.io-index)",
 ]
 
 [[package]]
 name = "wasm-smith"
-version = "0.12.11"
+version = "0.12.10"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "09a683710b09c4d35e9bf711a0f116cabde0f13a505ea6d7b5aea74b5a150367"
+checksum = "027ec1c470cd5d56c43b8e02040250b136ddb5975dd76a1c16915137f5f17e76"
 dependencies = [
  "arbitrary",
  "flagset",
- "indexmap 2.0.0",
+ "indexmap",
  "leb128",
- "wasm-encoder 0.30.0",
- "wasmparser 0.108.0",
+ "wasm-encoder 0.29.0 (registry+https://github.com/rust-lang/crates.io-index)",
+ "wasmparser 0.107.0 (registry+https://github.com/rust-lang/crates.io-index)",
 ]
 
 [[package]]
@@ -3796,7 +3713,7 @@ version = "0.0.0"
 dependencies = [
  "ocaml-interop",
  "once_cell",
- "wat",
+ "wat 1.0.66 (git+https://github.com/effect-handlers/wasm-tools?branch=typed-continuations)",
 ]
 
 [[package]]
@@ -3805,7 +3722,7 @@ version = "0.20.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "01bf50edb2ea9d922aa75a7bf3c15e26a6c9e2d18c56e862b49737a582901729"
 dependencies = [
- "spin 0.9.4",
+ "spin 0.9.8",
  "wasmi_arena",
  "wasmi_core",
  "wasmparser-nostd",
@@ -3834,7 +3751,7 @@ version = "0.92.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "7da34cec2a8c23db906cdf8b26e988d7a7f0d549eb5d51299129647af61a1b37"
 dependencies = [
- "indexmap 1.9.1",
+ "indexmap",
 ]
 
 [[package]]
@@ -3843,17 +3760,16 @@ version = "0.107.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "29e3ac9b780c7dda0cac7a52a5d6d2d6707cc6e3451c9db209b6c758f40d7acb"
 dependencies = [
- "indexmap 1.9.1",
+ "indexmap",
  "semver",
 ]
 
 [[package]]
 name = "wasmparser"
-version = "0.108.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "76c956109dcb41436a39391139d9b6e2d0a5e0b158e1293ef352ec977e5e36c5"
+version = "0.107.0"
+source = "git+https://github.com/effect-handlers/wasm-tools?branch=typed-continuations#403d7946f07feab87ed4b4b58a8b2130487f488f"
 dependencies = [
- "indexmap 2.0.0",
+ "indexmap",
  "semver",
 ]
 
@@ -3868,17 +3784,16 @@ dependencies = [
 
 [[package]]
 name = "wasmprinter"
-version = "0.2.60"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "b76cb909fe3d9b0de58cee1f4072247e680ff5cc1558ccad2790a9de14a23993"
+version = "0.2.59"
+source = "git+https://github.com/effect-handlers/wasm-tools?branch=typed-continuations#403d7946f07feab87ed4b4b58a8b2130487f488f"
 dependencies = [
  "anyhow",
- "wasmparser 0.108.0",
+ "wasmparser 0.107.0 (git+https://github.com/effect-handlers/wasm-tools?branch=typed-continuations)",
 ]
 
 [[package]]
 name = "wasmtime"
-version = "12.0.0"
+version = "11.0.0"
 dependencies = [
  "anyhow",
  "async-trait",
@@ -3887,7 +3802,7 @@ dependencies = [
  "cfg-if",
  "encoding_rs",
  "fxprof-processed-profile",
- "indexmap 2.0.0",
+ "indexmap",
  "libc",
  "log",
  "object",
@@ -3900,31 +3815,32 @@ dependencies = [
  "target-lexicon",
  "tempfile",
  "wasi-cap-std-sync",
- "wasmparser 0.108.0",
+ "wasmparser 0.107.0 (git+https://github.com/effect-handlers/wasm-tools?branch=typed-continuations)",
  "wasmtime-cache",
  "wasmtime-component-macro",
  "wasmtime-component-util",
  "wasmtime-cranelift",
  "wasmtime-environ",
  "wasmtime-fiber",
+ "wasmtime-fibre",
  "wasmtime-jit",
  "wasmtime-runtime",
  "wasmtime-wasi",
  "wasmtime-winch",
- "wat",
+ "wat 1.0.66 (git+https://github.com/effect-handlers/wasm-tools?branch=typed-continuations)",
  "windows-sys 0.48.0",
 ]
 
 [[package]]
 name = "wasmtime-asm-macros"
-version = "12.0.0"
+version = "11.0.0"
 dependencies = [
  "cfg-if",
 ]
 
 [[package]]
 name = "wasmtime-bench-api"
-version = "12.0.0"
+version = "11.0.0"
 dependencies = [
  "anyhow",
  "cap-std",
@@ -3937,12 +3853,12 @@ dependencies = [
  "wasmtime-wasi",
  "wasmtime-wasi-crypto",
  "wasmtime-wasi-nn",
- "wat",
+ "wat 1.0.66 (git+https://github.com/effect-handlers/wasm-tools?branch=typed-continuations)",
 ]
 
 [[package]]
 name = "wasmtime-c-api"
-version = "12.0.0"
+version = "11.0.0"
 dependencies = [
  "anyhow",
  "cap-std",
@@ -3953,7 +3869,7 @@ dependencies = [
  "wasmtime",
  "wasmtime-c-api-macros",
  "wasmtime-wasi",
- "wat",
+ "wat 1.0.66 (git+https://github.com/effect-handlers/wasm-tools?branch=typed-continuations)",
 ]
 
 [[package]]
@@ -3966,7 +3882,7 @@ dependencies = [
 
 [[package]]
 name = "wasmtime-cache"
-version = "12.0.0"
+version = "11.0.0"
 dependencies = [
  "anyhow",
  "base64",
@@ -3979,7 +3895,7 @@ dependencies = [
  "pretty_env_logger",
  "rustix",
  "serde",
- "sha2 0.10.2",
+ "sha2 0.10.6",
  "tempfile",
  "toml",
  "windows-sys 0.48.0",
@@ -3988,7 +3904,7 @@ dependencies = [
 
 [[package]]
 name = "wasmtime-cli"
-version = "12.0.0"
+version = "11.0.0"
 dependencies = [
  "anyhow",
  "async-trait",
@@ -4015,8 +3931,8 @@ dependencies = [
  "test-programs",
  "tokio",
  "walkdir",
- "wasm-encoder 0.30.0",
- "wasmparser 0.108.0",
+ "wasm-encoder 0.29.0 (git+https://github.com/effect-handlers/wasm-tools?branch=typed-continuations)",
+ "wasmparser 0.107.0 (git+https://github.com/effect-handlers/wasm-tools?branch=typed-continuations)",
  "wasmtime",
  "wasmtime-cache",
  "wasmtime-cli-flags",
@@ -4031,14 +3947,14 @@ dependencies = [
  "wasmtime-wasi-nn",
  "wasmtime-wasi-threads",
  "wasmtime-wast",
- "wast 61.0.0",
- "wat",
+ "wast 60.0.0 (git+https://github.com/effect-handlers/wasm-tools?branch=typed-continuations)",
+ "wat 1.0.66 (git+https://github.com/effect-handlers/wasm-tools?branch=typed-continuations)",
  "windows-sys 0.48.0",
 ]
 
 [[package]]
 name = "wasmtime-cli-flags"
-version = "12.0.0"
+version = "11.0.0"
 dependencies = [
  "anyhow",
  "clap",
@@ -4050,27 +3966,27 @@ dependencies = [
 
 [[package]]
 name = "wasmtime-component-macro"
-version = "12.0.0"
+version = "11.0.0"
 dependencies = [
  "anyhow",
  "component-macro-test-helpers",
  "proc-macro2",
  "quote",
- "syn 1.0.92",
+ "syn 1.0.109",
  "tracing",
  "wasmtime",
  "wasmtime-component-util",
  "wasmtime-wit-bindgen",
- "wit-parser 0.9.0",
+ "wit-parser",
 ]
 
 [[package]]
 name = "wasmtime-component-util"
-version = "12.0.0"
+version = "11.0.0"
 
 [[package]]
 name = "wasmtime-cranelift"
-version = "12.0.0"
+version = "11.0.0"
 dependencies = [
  "anyhow",
  "cranelift-codegen",
@@ -4084,15 +4000,14 @@ dependencies = [
  "object",
  "target-lexicon",
  "thiserror",
- "wasmparser 0.108.0",
+ "wasmparser 0.107.0 (git+https://github.com/effect-handlers/wasm-tools?branch=typed-continuations)",
  "wasmtime-cranelift-shared",
  "wasmtime-environ",
- "wasmtime-versioned-export-macros",
 ]
 
 [[package]]
 name = "wasmtime-cranelift-shared"
-version = "12.0.0"
+version = "11.0.0"
 dependencies = [
  "anyhow",
  "cranelift-codegen",
@@ -4106,7 +4021,7 @@ dependencies = [
 
 [[package]]
 name = "wasmtime-environ"
-version = "12.0.0"
+version = "11.0.0"
 dependencies = [
  "anyhow",
  "atty",
@@ -4114,18 +4029,18 @@ dependencies = [
  "cranelift-entity",
  "env_logger 0.10.0",
  "gimli",
- "indexmap 2.0.0",
+ "indexmap",
  "log",
  "object",
  "serde",
  "target-lexicon",
  "thiserror",
- "wasm-encoder 0.30.0",
- "wasmparser 0.108.0",
+ "wasm-encoder 0.29.0 (git+https://github.com/effect-handlers/wasm-tools?branch=typed-continuations)",
+ "wasmparser 0.107.0 (git+https://github.com/effect-handlers/wasm-tools?branch=typed-continuations)",
  "wasmprinter",
  "wasmtime-component-util",
  "wasmtime-types",
- "wat",
+ "wat 1.0.66 (git+https://github.com/effect-handlers/wasm-tools?branch=typed-continuations)",
 ]
 
 [[package]]
@@ -4136,15 +4051,15 @@ dependencies = [
  "component-fuzz-util",
  "env_logger 0.10.0",
  "libfuzzer-sys",
- "wasmparser 0.108.0",
+ "wasmparser 0.107.0 (git+https://github.com/effect-handlers/wasm-tools?branch=typed-continuations)",
  "wasmprinter",
  "wasmtime-environ",
- "wat",
+ "wat 1.0.66 (git+https://github.com/effect-handlers/wasm-tools?branch=typed-continuations)",
 ]
 
 [[package]]
 name = "wasmtime-explorer"
-version = "12.0.0"
+version = "11.0.0"
 dependencies = [
  "anyhow",
  "capstone",
@@ -4157,14 +4072,25 @@ dependencies = [
 
 [[package]]
 name = "wasmtime-fiber"
-version = "12.0.0"
+version = "11.0.0"
+dependencies = [
+ "backtrace",
+ "cc",
+ "cfg-if",
+ "rustix",
+ "wasmtime-asm-macros",
+ "windows-sys 0.48.0",
+]
+
+[[package]]
+name = "wasmtime-fibre"
+version = "11.0.0"
 dependencies = [
  "backtrace",
  "cc",
  "cfg-if",
  "rustix",
  "wasmtime-asm-macros",
- "wasmtime-versioned-export-macros",
  "windows-sys 0.48.0",
 ]
 
@@ -4191,7 +4117,7 @@ dependencies = [
  "rand 0.8.5",
  "smallvec",
  "target-lexicon",
- "wasmparser 0.108.0",
+ "wasmparser 0.107.0 (git+https://github.com/effect-handlers/wasm-tools?branch=typed-continuations)",
  "wasmtime",
  "wasmtime-fuzzing",
 ]
@@ -4211,21 +4137,21 @@ dependencies = [
  "target-lexicon",
  "tempfile",
  "v8",
- "wasm-encoder 0.30.0",
+ "wasm-encoder 0.29.0 (git+https://github.com/effect-handlers/wasm-tools?branch=typed-continuations)",
  "wasm-mutate",
  "wasm-smith",
  "wasm-spec-interpreter",
  "wasmi",
- "wasmparser 0.108.0",
+ "wasmparser 0.107.0 (git+https://github.com/effect-handlers/wasm-tools?branch=typed-continuations)",
  "wasmprinter",
  "wasmtime",
  "wasmtime-wast",
- "wat",
+ "wat 1.0.66 (git+https://github.com/effect-handlers/wasm-tools?branch=typed-continuations)",
 ]
 
 [[package]]
 name = "wasmtime-jit"
-version = "12.0.0"
+version = "11.0.0"
 dependencies = [
  "addr2line",
  "anyhow",
@@ -4249,17 +4175,16 @@ dependencies = [
 
 [[package]]
 name = "wasmtime-jit-debug"
-version = "12.0.0"
+version = "11.0.0"
 dependencies = [
  "object",
  "once_cell",
  "rustix",
- "wasmtime-versioned-export-macros",
 ]
 
 [[package]]
 name = "wasmtime-jit-icache-coherence"
-version = "12.0.0"
+version = "11.0.0"
 dependencies = [
  "cfg-if",
  "libc",
@@ -4268,18 +4193,18 @@ dependencies = [
 
 [[package]]
 name = "wasmtime-runtime"
-version = "12.0.0"
+version = "11.0.0"
 dependencies = [
  "anyhow",
  "cc",
  "cfg-if",
  "encoding_rs",
- "indexmap 2.0.0",
+ "indexmap",
  "libc",
  "log",
  "mach",
  "memfd",
- "memoffset 0.8.0",
+ "memoffset",
  "once_cell",
  "paste",
  "rand 0.8.5",
@@ -4288,33 +4213,24 @@ dependencies = [
  "wasmtime-asm-macros",
  "wasmtime-environ",
  "wasmtime-fiber",
+ "wasmtime-fibre",
  "wasmtime-jit-debug",
- "wasmtime-versioned-export-macros",
  "windows-sys 0.48.0",
 ]
 
 [[package]]
 name = "wasmtime-types"
-version = "12.0.0"
+version = "11.0.0"
 dependencies = [
  "cranelift-entity",
  "serde",
  "thiserror",
- "wasmparser 0.108.0",
-]
-
-[[package]]
-name = "wasmtime-versioned-export-macros"
-version = "12.0.0"
-dependencies = [
- "proc-macro2",
- "quote",
- "syn 2.0.25",
+ "wasmparser 0.107.0 (git+https://github.com/effect-handlers/wasm-tools?branch=typed-continuations)",
 ]
 
 [[package]]
 name = "wasmtime-wasi"
-version = "12.0.0"
+version = "11.0.0"
 dependencies = [
  "anyhow",
  "async-trait",
@@ -4340,7 +4256,7 @@ dependencies = [
 
 [[package]]
 name = "wasmtime-wasi-crypto"
-version = "12.0.0"
+version = "11.0.0"
 dependencies = [
  "anyhow",
  "wasi-crypto",
@@ -4350,7 +4266,7 @@ dependencies = [
 
 [[package]]
 name = "wasmtime-wasi-http"
-version = "12.0.0"
+version = "11.0.0"
 dependencies = [
  "anyhow",
  "bytes",
@@ -4368,7 +4284,7 @@ dependencies = [
 
 [[package]]
 name = "wasmtime-wasi-nn"
-version = "12.0.0"
+version = "11.0.0"
 dependencies = [
  "anyhow",
  "openvino",
@@ -4379,7 +4295,7 @@ dependencies = [
 
 [[package]]
 name = "wasmtime-wasi-threads"
-version = "12.0.0"
+version = "11.0.0"
 dependencies = [
  "anyhow",
  "log",
@@ -4391,24 +4307,24 @@ dependencies = [
 
 [[package]]
 name = "wasmtime-wast"
-version = "12.0.0"
+version = "11.0.0"
 dependencies = [
  "anyhow",
  "log",
  "wasmtime",
- "wast 61.0.0",
+ "wast 60.0.0 (git+https://github.com/effect-handlers/wasm-tools?branch=typed-continuations)",
 ]
 
 [[package]]
 name = "wasmtime-winch"
-version = "12.0.0"
+version = "11.0.0"
 dependencies = [
  "anyhow",
  "cranelift-codegen",
  "gimli",
  "object",
  "target-lexicon",
- "wasmparser 0.108.0",
+ "wasmparser 0.107.0 (git+https://github.com/effect-handlers/wasm-tools?branch=typed-continuations)",
  "wasmtime-cranelift-shared",
  "wasmtime-environ",
  "winch-codegen",
@@ -4416,11 +4332,11 @@ dependencies = [
 
 [[package]]
 name = "wasmtime-wit-bindgen"
-version = "12.0.0"
+version = "11.0.0"
 dependencies = [
  "anyhow",
  "heck",
- "wit-parser 0.9.0",
+ "wit-parser",
 ]
 
 [[package]]
@@ -4434,30 +4350,49 @@ dependencies = [
 
 [[package]]
 name = "wast"
-version = "61.0.0"
+version = "60.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "dc6b347851b52fd500657d301155c79e8c67595501d179cef87b6f04ebd25ac4"
+checksum = "bd06cc744b536e30387e72a48fdd492105b9c938bb4f415c39c616a7a0a697ad"
 dependencies = [
  "leb128",
  "memchr",
  "unicode-width",
- "wasm-encoder 0.30.0",
+ "wasm-encoder 0.29.0 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "wast"
+version = "60.0.0"
+source = "git+https://github.com/effect-handlers/wasm-tools?branch=typed-continuations#403d7946f07feab87ed4b4b58a8b2130487f488f"
+dependencies = [
+ "leb128",
+ "memchr",
+ "unicode-width",
+ "wasm-encoder 0.29.0 (git+https://github.com/effect-handlers/wasm-tools?branch=typed-continuations)",
 ]
 
 [[package]]
 name = "wat"
-version = "1.0.67"
+version = "1.0.66"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "459e764d27c3ab7beba1ebd617cc025c7e76dea6e7c5ce3189989a970aea3491"
+checksum = "5abe520f0ab205366e9ac7d3e6b2fc71de44e32a2b58f2ec871b6b575bdcea3b"
 dependencies = [
- "wast 61.0.0",
+ "wast 60.0.0 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "wat"
+version = "1.0.66"
+source = "git+https://github.com/effect-handlers/wasm-tools?branch=typed-continuations#403d7946f07feab87ed4b4b58a8b2130487f488f"
+dependencies = [
+ "wast 60.0.0 (git+https://github.com/effect-handlers/wasm-tools?branch=typed-continuations)",
 ]
 
 [[package]]
 name = "web-sys"
-version = "0.3.57"
+version = "0.3.63"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "7b17e741662c70c8bd24ac5c5b18de314a2c26c32bf8346ee1e6f53de919c283"
+checksum = "3bdd9ef4e984da1187bf8110c5cf5b845fbc87a23602cdf912386a76fcd3a7c2"
 dependencies = [
  "js-sys",
  "wasm-bindgen",
@@ -4465,27 +4400,27 @@ dependencies = [
 
 [[package]]
 name = "webpki-roots"
-version = "0.23.0"
+version = "0.23.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "aa54963694b65584e170cf5dc46aeb4dcaa5584e652ff5f3952e56d66aff0125"
+checksum = "b03058f88386e5ff5310d9111d53f48b17d732b401aeb83a8d5190f2ac459338"
 dependencies = [
  "rustls-webpki",
 ]
 
 [[package]]
 name = "which"
-version = "4.2.5"
+version = "4.4.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "5c4fb54e6113b6a8772ee41c3404fb0301ac79604489467e0a9ce1f3e97c24ae"
+checksum = "2441c784c52b289a054b7201fc93253e288f094e2f4be9058343127c4226a269"
 dependencies = [
  "either",
- "lazy_static",
  "libc",
+ "once_cell",
 ]
 
 [[package]]
 name = "wiggle"
-version = "12.0.0"
+version = "11.0.0"
 dependencies = [
  "anyhow",
  "async-trait",
@@ -4502,24 +4437,24 @@ dependencies = [
 
 [[package]]
 name = "wiggle-generate"
-version = "12.0.0"
+version = "11.0.0"
 dependencies = [
  "anyhow",
  "heck",
  "proc-macro2",
  "quote",
  "shellexpand",
- "syn 1.0.92",
+ "syn 1.0.109",
  "witx",
 ]
 
 [[package]]
 name = "wiggle-macro"
-version = "12.0.0"
+version = "11.0.0"
 dependencies = [
  "proc-macro2",
  "quote",
- "syn 1.0.92",
+ "syn 1.0.109",
  "wiggle",
  "wiggle-generate",
 ]
@@ -4570,7 +4505,7 @@ checksum = "712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f"
 
 [[package]]
 name = "winch-codegen"
-version = "0.10.0"
+version = "0.9.0"
 dependencies = [
  "anyhow",
  "cranelift-codegen",
@@ -4578,7 +4513,7 @@ dependencies = [
  "regalloc2",
  "smallvec",
  "target-lexicon",
- "wasmparser 0.108.0",
+ "wasmparser 0.107.0 (git+https://github.com/effect-handlers/wasm-tools?branch=typed-continuations)",
  "wasmtime-environ",
 ]
 
@@ -4594,7 +4529,7 @@ dependencies = [
  "target-lexicon",
  "toml",
  "wasmtime-environ",
- "wat",
+ "wat 1.0.66 (git+https://github.com/effect-handlers/wasm-tools?branch=typed-continuations)",
  "winch-codegen",
  "winch-test-macros",
 ]
@@ -4606,7 +4541,7 @@ dependencies = [
  "glob",
  "proc-macro2",
  "quote",
- "syn 1.0.92",
+ "syn 1.0.109",
 ]
 
 [[package]]
@@ -4622,9 +4557,9 @@ dependencies = [
  "similar",
  "target-lexicon",
  "toml",
- "wasmparser 0.108.0",
+ "wasmparser 0.107.0 (git+https://github.com/effect-handlers/wasm-tools?branch=typed-continuations)",
  "wasmtime-environ",
- "wat",
+ "wat 1.0.66 (git+https://github.com/effect-handlers/wasm-tools?branch=typed-continuations)",
  "winch-codegen",
  "winch-filetests",
  "winch-test-macros",
@@ -4636,7 +4571,7 @@ version = "0.45.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "75283be5efb2831d37ea142365f009c02ec203cd29a3ebecbc093d52315b66d0"
 dependencies = [
- "windows-targets 0.42.1",
+ "windows-targets 0.42.2",
 ]
 
 [[package]]
@@ -4650,17 +4585,17 @@ dependencies = [
 
 [[package]]
 name = "windows-targets"
-version = "0.42.1"
+version = "0.42.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "8e2522491fbfcd58cc84d47aeb2958948c4b8982e9a2d8a2a35bbaed431390e7"
+checksum = "8e5180c00cd44c9b1c88adb3693291f1cd93605ded80c250a75d472756b4d071"
 dependencies = [
- "windows_aarch64_gnullvm 0.42.1",
- "windows_aarch64_msvc 0.42.1",
- "windows_i686_gnu 0.42.1",
- "windows_i686_msvc 0.42.1",
- "windows_x86_64_gnu 0.42.1",
- "windows_x86_64_gnullvm 0.42.1",
- "windows_x86_64_msvc 0.42.1",
+ "windows_aarch64_gnullvm 0.42.2",
+ "windows_aarch64_msvc 0.42.2",
+ "windows_i686_gnu 0.42.2",
+ "windows_i686_msvc 0.42.2",
+ "windows_x86_64_gnu 0.42.2",
+ "windows_x86_64_gnullvm 0.42.2",
+ "windows_x86_64_msvc 0.42.2",
 ]
 
 [[package]]
@@ -4680,9 +4615,9 @@ dependencies = [
 
 [[package]]
 name = "windows_aarch64_gnullvm"
-version = "0.42.1"
+version = "0.42.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "8c9864e83243fdec7fc9c5444389dcbbfd258f745e7853198f365e3c4968a608"
+checksum = "597a5118570b68bc08d8d59125332c54f1ba9d9adeedeef5b99b02ba2b0698f8"
 
 [[package]]
 name = "windows_aarch64_gnullvm"
@@ -4692,9 +4627,9 @@ checksum = "91ae572e1b79dba883e0d315474df7305d12f569b400fcf90581b06062f7e1bc"
 
 [[package]]
 name = "windows_aarch64_msvc"
-version = "0.42.1"
+version = "0.42.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "4c8b1b673ffc16c47a9ff48570a9d85e25d265735c503681332589af6253c6c7"
+checksum = "e08e8864a60f06ef0d0ff4ba04124db8b0fb3be5776a5cd47641e942e58c4d43"
 
 [[package]]
 name = "windows_aarch64_msvc"
@@ -4704,9 +4639,9 @@ checksum = "b2ef27e0d7bdfcfc7b868b317c1d32c641a6fe4629c171b8928c7b08d98d7cf3"
 
 [[package]]
 name = "windows_i686_gnu"
-version = "0.42.1"
+version = "0.42.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "de3887528ad530ba7bdbb1faa8275ec7a1155a45ffa57c37993960277145d640"
+checksum = "c61d927d8da41da96a81f029489353e68739737d3beca43145c8afec9a31a84f"
 
 [[package]]
 name = "windows_i686_gnu"
@@ -4716,9 +4651,9 @@ checksum = "622a1962a7db830d6fd0a69683c80a18fda201879f0f447f065a3b7467daa241"
 
 [[package]]
 name = "windows_i686_msvc"
-version = "0.42.1"
+version = "0.42.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "bf4d1122317eddd6ff351aa852118a2418ad4214e6613a50e0191f7004372605"
+checksum = "44d840b6ec649f480a41c8d80f9c65108b92d89345dd94027bfe06ac444d1060"
 
 [[package]]
 name = "windows_i686_msvc"
@@ -4728,9 +4663,9 @@ checksum = "4542c6e364ce21bf45d69fdd2a8e455fa38d316158cfd43b3ac1c5b1b19f8e00"
 
 [[package]]
 name = "windows_x86_64_gnu"
-version = "0.42.1"
+version = "0.42.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "c1040f221285e17ebccbc2591ffdc2d44ee1f9186324dd3e84e99ac68d699c45"
+checksum = "8de912b8b8feb55c064867cf047dda097f92d51efad5b491dfb98f6bbb70cb36"
 
 [[package]]
 name = "windows_x86_64_gnu"
@@ -4740,9 +4675,9 @@ checksum = "ca2b8a661f7628cbd23440e50b05d705db3686f894fc9580820623656af974b1"
 
 [[package]]
 name = "windows_x86_64_gnullvm"
-version = "0.42.1"
+version = "0.42.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "628bfdf232daa22b0d64fdb62b09fcc36bb01f05a3939e20ab73aaf9470d0463"
+checksum = "26d41b46a36d453748aedef1486d5c7a85db22e56aff34643984ea85514e94a3"
 
 [[package]]
 name = "windows_x86_64_gnullvm"
@@ -4752,9 +4687,9 @@ checksum = "7896dbc1f41e08872e9d5e8f8baa8fdd2677f29468c4e156210174edc7f7b953"
 
 [[package]]
 name = "windows_x86_64_msvc"
-version = "0.42.1"
+version = "0.42.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "447660ad36a13288b1db4d4248e857b510e8c3a225c822ba4fb748c0aafecffd"
+checksum = "9aec5da331524158c6d1a4ac0ab1541149c0b9505fde06423b02f5ef0106b9f0"
 
 [[package]]
 name = "windows_x86_64_msvc"
@@ -4779,7 +4714,7 @@ version = "0.7.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "a628591b3905328e886462f75de3b2af1e546b19af5f4c359086b26bec29c4bd"
 dependencies = [
- "bitflags 2.2.1",
+ "bitflags 2.3.1",
  "wit-bindgen-rust-macro",
 ]
 
@@ -4790,8 +4725,8 @@ source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "34a19aa69c4f33cb5ac10e55880a899f4d52ec85d4cde4d593b575e7a97e2b08"
 dependencies = [
  "anyhow",
- "wit-component 0.11.0",
- "wit-parser 0.8.0",
+ "wit-component",
+ "wit-parser",
 ]
 
 [[package]]
@@ -4801,10 +4736,10 @@ source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "9a50274c0cf2f8e33fc967825cef0114cdfe222d474c1d78aa77a6a801abaadf"
 dependencies = [
  "heck",
- "wasm-metadata 0.8.0",
+ "wasm-metadata",
  "wit-bindgen-core",
  "wit-bindgen-rust-lib",
- "wit-component 0.11.0",
+ "wit-component",
 ]
 
 [[package]]
@@ -4825,10 +4760,10 @@ checksum = "78cce32dd08007af45dbaa00e225eb73d05524096f93933d7ecba852d50d8af3"
 dependencies = [
  "anyhow",
  "proc-macro2",
- "syn 2.0.25",
+ "syn 2.0.18",
  "wit-bindgen-core",
  "wit-bindgen-rust",
- "wit-component 0.11.0",
+ "wit-component",
 ]
 
 [[package]]
@@ -4839,28 +4774,12 @@ checksum = "7cbd4c7f8f400327c482c88571f373844b7889e61460650d650fc5881bb3575c"
 dependencies = [
  "anyhow",
  "bitflags 1.3.2",
- "indexmap 1.9.1",
+ "indexmap",
  "log",
- "wasm-encoder 0.29.0",
- "wasm-metadata 0.8.0",
- "wasmparser 0.107.0",
- "wit-parser 0.8.0",
-]
-
-[[package]]
-name = "wit-component"
-version = "0.12.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "253bd426c532f1cae8c633c517c63719920535f3a7fada3589de40c5b734e393"
-dependencies = [
- "anyhow",
- "bitflags 1.3.2",
- "indexmap 2.0.0",
- "log",
- "wasm-encoder 0.30.0",
- "wasm-metadata 0.9.0",
- "wasmparser 0.108.0",
- "wit-parser 0.9.0",
+ "wasm-encoder 0.29.0 (registry+https://github.com/rust-lang/crates.io-index)",
+ "wasm-metadata",
+ "wasmparser 0.107.0 (registry+https://github.com/rust-lang/crates.io-index)",
+ "wit-parser",
 ]
 
 [[package]]
@@ -4871,25 +4790,9 @@ checksum = "6daec9f093dbaea0e94043eeb92ece327bbbe70c86b1f41aca9bbfefd7f050f0"
 dependencies = [
  "anyhow",
  "id-arena",
- "indexmap 1.9.1",
+ "indexmap",
  "log",
- "pulldown-cmark 0.8.0",
- "semver",
- "unicode-xid",
- "url",
-]
-
-[[package]]
-name = "wit-parser"
-version = "0.9.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "82f2afd756820d516d4973f67a739ca5529cc872d80114be17d4bba79375981c"
-dependencies = [
- "anyhow",
- "id-arena",
- "indexmap 2.0.0",
- "log",
- "pulldown-cmark 0.9.3",
+ "pulldown-cmark",
  "semver",
  "unicode-xid",
  "url",
@@ -4927,30 +4830,29 @@ dependencies = [
 
 [[package]]
 name = "zeroize_derive"
-version = "1.3.2"
+version = "1.4.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "3f8f187641dad4f680d25c4bfc4225b418165984179f26ca76ec4fb6441d3a17"
+checksum = "ce36e65b0d2999d2aafac989fb249189a141aee1f53c612c1f37d72631959f69"
 dependencies = [
  "proc-macro2",
  "quote",
- "syn 1.0.92",
- "synstructure",
+ "syn 2.0.18",
 ]
 
 [[package]]
 name = "zstd"
-version = "0.11.1+zstd.1.5.2"
+version = "0.11.2+zstd.1.5.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "77a16b8414fde0414e90c612eba70985577451c4c504b99885ebed24762cb81a"
+checksum = "20cc960326ece64f010d2d2107537f26dc589a6573a316bd5b1dba685fa5fde4"
 dependencies = [
  "zstd-safe",
 ]
 
 [[package]]
 name = "zstd-safe"
-version = "5.0.1+zstd.1.5.2"
+version = "5.0.2+zstd.1.5.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "7c12659121420dd6365c5c3de4901f97145b79651fb1d25814020ed2ed0585ae"
+checksum = "1d2a5585e04f9eea4b2a3d1eca508c4dee9592a89ef6f450c11719da0726f4db"
 dependencies = [
  "libc",
  "zstd-sys",
@@ -4958,10 +4860,11 @@ dependencies = [
 
 [[package]]
 name = "zstd-sys"
-version = "2.0.1+zstd.1.5.2"
+version = "2.0.8+zstd.1.5.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "9fd07cbbc53846d9145dbffdf6dd09a7a0aa52be46741825f5c97bdd4f73f12b"
+checksum = "5556e6ee25d32df2586c098bbfa278803692a20d0ab9565e049480d52707ec8c"
 dependencies = [
  "cc",
  "libc",
+ "pkg-config",
 ]
diff --git a/Cargo.toml b/Cargo.toml
index f0ec10438..6b538ee3d 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -117,64 +117,64 @@ exclude = [
 ]
 
 [workspace.package]
-version = "12.0.0"
+version = "11.0.0"
 authors = ["The Wasmtime Project Developers"]
 edition = "2021"
 rust-version = "1.66.0"
 
 [workspace.dependencies]
-wasmtime = { path = "crates/wasmtime", version = "12.0.0", default-features = false }
-wasmtime-cache = { path = "crates/cache", version = "=12.0.0" }
-wasmtime-cli-flags = { path = "crates/cli-flags", version = "=12.0.0" }
-wasmtime-cranelift = { path = "crates/cranelift", version = "=12.0.0" }
-wasmtime-cranelift-shared = { path = "crates/cranelift-shared", version = "=12.0.0" }
-wasmtime-winch = { path = "crates/winch", version = "=12.0.0" }
-wasmtime-environ = { path = "crates/environ", version = "=12.0.0" }
-wasmtime-explorer = { path = "crates/explorer", version = "=12.0.0" }
-wasmtime-fiber = { path = "crates/fiber", version = "=12.0.0" }
-wasmtime-types = { path = "crates/types", version = "12.0.0" }
-wasmtime-jit = { path = "crates/jit", version = "=12.0.0" }
-wasmtime-jit-debug = { path = "crates/jit-debug", version = "=12.0.0" }
-wasmtime-runtime = { path = "crates/runtime", version = "=12.0.0" }
-wasmtime-wast = { path = "crates/wast", version = "=12.0.0" }
-wasmtime-wasi = { path = "crates/wasi", version = "12.0.0" }
-wasmtime-wasi-crypto = { path = "crates/wasi-crypto", version = "12.0.0" }
-wasmtime-wasi-http = { path = "crates/wasi-http", version = "=12.0.0" }
-wasmtime-wasi-nn = { path = "crates/wasi-nn", version = "12.0.0" }
-wasmtime-wasi-threads = { path = "crates/wasi-threads", version = "12.0.0" }
-wasmtime-component-util = { path = "crates/component-util", version = "=12.0.0" }
-wasmtime-component-macro = { path = "crates/component-macro", version = "=12.0.0" }
-wasmtime-asm-macros = { path = "crates/asm-macros", version = "=12.0.0" }
-wasmtime-versioned-export-macros = { path = "crates/versioned-export-macros", version = "=12.0.0" }
+wasmtime = { path = "crates/wasmtime", version = "11.0.0", default-features = false }
+wasmtime-cache = { path = "crates/cache", version = "=11.0.0" }
+wasmtime-cli-flags = { path = "crates/cli-flags", version = "=11.0.0" }
+wasmtime-cranelift = { path = "crates/cranelift", version = "=11.0.0" }
+wasmtime-cranelift-shared = { path = "crates/cranelift-shared", version = "=11.0.0" }
+wasmtime-winch = { path = "crates/winch", version = "=11.0.0" }
+wasmtime-environ = { path = "crates/environ", version = "=11.0.0" }
+wasmtime-explorer = { path = "crates/explorer", version = "=11.0.0" }
+wasmtime-fiber = { path = "crates/fiber", version = "=11.0.0" }
+wasmtime-fibre = { path = "crates/fibre", version = "=11.0.0" }
+wasmtime-types = { path = "crates/types", version = "11.0.0" }
+wasmtime-jit = { path = "crates/jit", version = "=11.0.0" }
+wasmtime-jit-debug = { path = "crates/jit-debug", version = "=11.0.0" }
+wasmtime-runtime = { path = "crates/runtime", version = "=11.0.0" }
+wasmtime-wast = { path = "crates/wast", version = "=11.0.0" }
+wasmtime-wasi = { path = "crates/wasi", version = "11.0.0" }
+wasmtime-wasi-crypto = { path = "crates/wasi-crypto", version = "11.0.0" }
+wasmtime-wasi-http = { path = "crates/wasi-http", version = "=11.0.0" }
+wasmtime-wasi-nn = { path = "crates/wasi-nn", version = "11.0.0" }
+wasmtime-wasi-threads = { path = "crates/wasi-threads", version = "11.0.0" }
+wasmtime-component-util = { path = "crates/component-util", version = "=11.0.0" }
+wasmtime-component-macro = { path = "crates/component-macro", version = "=11.0.0" }
+wasmtime-asm-macros = { path = "crates/asm-macros", version = "=11.0.0" }
 component-test-util = { path = "crates/misc/component-test-util" }
 component-fuzz-util = { path = "crates/misc/component-fuzz-util" }
-wiggle = { path = "crates/wiggle", version = "=12.0.0", default-features = false }
-wiggle-macro = { path = "crates/wiggle/macro", version = "=12.0.0" }
-wiggle-generate = { path = "crates/wiggle/generate", version = "=12.0.0" }
-wasi-common = { path = "crates/wasi-common", version = "=12.0.0" }
-wasi-tokio = { path = "crates/wasi-common/tokio", version = "=12.0.0" }
-wasi-cap-std-sync = { path = "crates/wasi-common/cap-std-sync", version = "=12.0.0" }
+wiggle = { path = "crates/wiggle", version = "=11.0.0", default-features = false }
+wiggle-macro = { path = "crates/wiggle/macro", version = "=11.0.0" }
+wiggle-generate = { path = "crates/wiggle/generate", version = "=11.0.0" }
+wasi-common = { path = "crates/wasi-common", version = "=11.0.0" }
+wasi-tokio = { path = "crates/wasi-common/tokio", version = "=11.0.0" }
+wasi-cap-std-sync = { path = "crates/wasi-common/cap-std-sync", version = "=11.0.0" }
 wasmtime-fuzzing = { path = "crates/fuzzing" }
-wasmtime-jit-icache-coherence = { path = "crates/jit-icache-coherence", version = "=12.0.0" }
-wasmtime-wit-bindgen = { path = "crates/wit-bindgen", version = "=12.0.0" }
+wasmtime-jit-icache-coherence = { path = "crates/jit-icache-coherence", version = "=11.0.0" }
+wasmtime-wit-bindgen = { path = "crates/wit-bindgen", version = "=11.0.0" }
 
-cranelift-wasm = { path = "cranelift/wasm", version = "0.99.0" }
-cranelift-codegen = { path = "cranelift/codegen", version = "0.99.0" }
-cranelift-frontend = { path = "cranelift/frontend", version = "0.99.0" }
-cranelift-entity = { path = "cranelift/entity", version = "0.99.0" }
-cranelift-native = { path = "cranelift/native", version = "0.99.0" }
-cranelift-module = { path = "cranelift/module", version = "0.99.0" }
-cranelift-interpreter = { path = "cranelift/interpreter", version = "0.99.0" }
-cranelift-reader = { path = "cranelift/reader", version = "0.99.0" }
+cranelift-wasm = { path = "cranelift/wasm", version = "0.98.0" }
+cranelift-codegen = { path = "cranelift/codegen", version = "0.98.0" }
+cranelift-frontend = { path = "cranelift/frontend", version = "0.98.0" }
+cranelift-entity = { path = "cranelift/entity", version = "0.98.0" }
+cranelift-native = { path = "cranelift/native", version = "0.98.0" }
+cranelift-module = { path = "cranelift/module", version = "0.98.0" }
+cranelift-interpreter = { path = "cranelift/interpreter", version = "0.98.0" }
+cranelift-reader = { path = "cranelift/reader", version = "0.98.0" }
 cranelift-filetests = { path = "cranelift/filetests" }
-cranelift-object = { path = "cranelift/object", version = "0.99.0" }
-cranelift-jit = { path = "cranelift/jit", version = "0.99.0" }
+cranelift-object = { path = "cranelift/object", version = "0.98.0" }
+cranelift-jit = { path = "cranelift/jit", version = "0.98.0" }
 cranelift-fuzzgen = { path = "cranelift/fuzzgen" }
-cranelift-bforest = { path = "cranelift/bforest", version = "0.99.0" }
-cranelift-control = { path = "cranelift/control", version = "0.99.0" }
-cranelift = { path = "cranelift/umbrella", version = "0.99.0" }
+cranelift-bforest = { path = "cranelift/bforest", version = "0.98.0" }
+cranelift-control = { path = "cranelift/control", version = "0.98.0" }
+cranelift = { path = "cranelift/umbrella", version = "0.98.0" }
 
-winch-codegen = { path = "winch/codegen", version = "=0.10.0" }
+winch-codegen = { path = "winch/codegen", version = "=0.9.0" }
 winch-filetests = { path = "winch/filetests" }
 winch-test-macros = { path = "winch/test-macros" }
 
@@ -200,15 +200,15 @@ rustix = "0.37.13"
 wit-bindgen = { version = "0.7.0", default-features = false }
 
 # wasm-tools family:
-wasmparser = "0.108.0"
-wat = "1.0.67"
-wast = "61.0.0"
-wasmprinter = "0.2.60"
-wasm-encoder = "0.30.0"
-wasm-smith = "0.12.11"
-wasm-mutate = "0.2.28"
-wit-parser = "0.9.0"
-wit-component = "0.12.0"
+wasmparser = { git = "https://github.com/effect-handlers/wasm-tools", branch = "typed-continuations" }
+wat = { git = "https://github.com/effect-handlers/wasm-tools", branch = "typed-continuations" }
+wast = { git = "https://github.com/effect-handlers/wasm-tools", branch = "typed-continuations" }
+wasmprinter = { git = "https://github.com/effect-handlers/wasm-tools", branch = "typed-continuations" }
+wasm-encoder = { git = "https://github.com/effect-handlers/wasm-tools", branch = "typed-continuations" }
+wasm-smith = "0.12.10"
+wasm-mutate = "0.2.27"
+wit-parser = "0.8.0"
+wit-component = "0.11.0"
 
 # Non-Bytecode Alliance maintained dependencies:
 # --------------------------
@@ -240,7 +240,6 @@ tempfile = "3.1.0"
 filecheck = "0.5.0"
 libc = "0.2.60"
 file-per-thread-logger = "0.2.0"
-indexmap = "2.0.0"
 
 [features]
 default = [
@@ -269,6 +268,18 @@ component-model = [
 ]
 winch = ["wasmtime/winch"]
 
+# Until we implement proper reference counting for `ContinuationReference` objects,
+# we may use this flag to bypass the creation of ContinuationReference objects,
+# directly using the corresponding ContinuationObject instead.
+# This is to allow running benchmarks that may create a lot of such objects and
+# may otherwise run out of memory.
+# Note that enabling this is highly unsafe, as it makes it impossible to detect
+# at runtime when an already taken continuation is used again.
+unsafe_disable_continuation_linearity_check = [
+  "wasmtime-cranelift/unsafe_disable_continuation_linearity_check",
+  "wasmtime-runtime/unsafe_disable_continuation_linearity_check"
+]
+
 [[test]]
 name = "host_segfault"
 harness = false
diff --git a/RELEASES.md b/RELEASES.md
index d25f65627..ef05439d9 100644
--- a/RELEASES.md
+++ b/RELEASES.md
@@ -1,6 +1,6 @@
 --------------------------------------------------------------------------------
 
-## 12.0.0
+## 11.0.0
 
 Unreleased.
 
@@ -8,72 +8,16 @@ Unreleased.
 
 ### Changed
 
---------------------------------------------------------------------------------
-
-## 11.0.0
-
-Unreleased.
-
-### Changed
-
-* The WASI Preview 2 `WasiCtxBuilder` type has been refactored, and `WasiCtx` now has private
-  fields.
-  [#6652](https://github.com/bytecodealliance/wasmtime/pull/6652)
-
-* Component `bindgen!` now generates owned types by default instead of based on
-  how they're used
-  [#6648](https://github.com/bytecodealliance/wasmtime/pull/6648)
-
-* Wasmtime/Cranelift on x86-64 can now execute Wasm-SIMD on baseline SSE2, which
-  all x86-64 processors support (as part of the base x86-64 spec). Previously,
-  SSE4.2 extensions were required. This new work allows Wasm with SIMD
-  extensions to execute on processors produced back to 2003.
-  [#6625](https://github.com/bytecodealliance/wasmtime/pull/6625)
-
-
 ### Fixed
 
 * Only export the top-level preview2 module from wasmtime-wasi when the
   `preview2` feature is enabled.
   [#6615](https://github.com/bytecodealliance/wasmtime/pull/6615)
 
-
-### Cranelift changes
-
-* Tail call implementation has begun in Cranelift
-  [#6641](https://github.com/bytecodealliance/wasmtime/pull/6641)
-  [#6666](https://github.com/bytecodealliance/wasmtime/pull/6666)
-  [#6650](https://github.com/bytecodealliance/wasmtime/pull/6650)
-  [#6635](https://github.com/bytecodealliance/wasmtime/pull/6635)
-  [#6608](https://github.com/bytecodealliance/wasmtime/pull/6608)
-  [#6586](https://github.com/bytecodealliance/wasmtime/pull/6586)
-
-* Work continues on SIMD support for the riscv64 backend
-  [#6657](https://github.com/bytecodealliance/wasmtime/pull/6657)
-  [#6643](https://github.com/bytecodealliance/wasmtime/pull/6643)
-  [#6601](https://github.com/bytecodealliance/wasmtime/pull/6601)
-  [#6609](https://github.com/bytecodealliance/wasmtime/pull/6609)
-  [#6602](https://github.com/bytecodealliance/wasmtime/pull/6602)
-  [#6598](https://github.com/bytecodealliance/wasmtime/pull/6598)
-  [#6599](https://github.com/bytecodealliance/wasmtime/pull/6599)
-  [#6587](https://github.com/bytecodealliance/wasmtime/pull/6587)
-  [#6568](https://github.com/bytecodealliance/wasmtime/pull/6568)
-  [#6515](https://github.com/bytecodealliance/wasmtime/pull/6515)
-
-* Fix `AuthenticatedRet` when stack bytes are popped in the aarch64 backend
-  [#6634](https://github.com/bytecodealliance/wasmtime/pull/6634)
-
-* The `fcvt_low_from_sint` instruction has been removed, as it its current
-  behavior can be recovered through a combination of `swiden_low` and
-  `fcvt_from_sint`
-  [#6565](https://github.com/bytecodealliance/wasmtime/pull/6565)
-
 --------------------------------------------------------------------------------
 
 ## 10.0.1
 
-Released 2023-06-21
-
 ### Fixed
 
 * Only export the top-level preview2 module from wasmtime-wasi when the
diff --git a/build.rs b/build.rs
index a2a4628ec..f8cec9fc4 100644
--- a/build.rs
+++ b/build.rs
@@ -18,13 +18,9 @@ fn main() -> anyhow::Result<()> {
     );
     let mut out = String::new();
 
-    for strategy in &["Cranelift", "Winch"] {
+    for strategy in &["Cranelift"] {
         writeln!(out, "#[cfg(test)]")?;
         writeln!(out, "#[allow(non_snake_case)]")?;
-        if *strategy == "Winch" {
-            // We only test Winch on x86_64, for now.
-            writeln!(out, "{}", "#[cfg(all(target_arch = \"x86_64\"))]")?;
-        }
         writeln!(out, "mod {} {{", strategy)?;
 
         with_test_module(&mut out, "misc", |out| {
@@ -35,7 +31,7 @@ fn main() -> anyhow::Result<()> {
             test_directory_module(out, "tests/misc_testsuite/memory64", strategy)?;
             test_directory_module(out, "tests/misc_testsuite/component-model", strategy)?;
             test_directory_module(out, "tests/misc_testsuite/function-references", strategy)?;
-            test_directory_module(out, "tests/misc_testsuite/winch", strategy)?;
+            test_directory_module(out, "tests/misc_testsuite/typed-continuations", strategy)?;
             Ok(())
         })?;
 
@@ -191,22 +187,7 @@ fn write_testsuite_tests(
 
 /// Ignore tests that aren't supported yet.
 fn ignore(testsuite: &str, testname: &str, strategy: &str) -> bool {
-    assert!(strategy == "Cranelift" || strategy == "Winch");
-
-    // Ignore everything except the winch misc test suite.
-    // We ignore tests that assert for traps on windows, given
-    // that Winch doesn't encode unwind information for Windows, yet.
-    if strategy == "Winch" {
-        if testsuite != "winch" {
-            return true;
-        }
-
-        let assert_trap = ["i32", "i64"].contains(&testname);
-
-        if assert_trap && env::var("CARGO_CFG_TARGET_OS").unwrap().as_str() == "windows" {
-            return true;
-        }
-    }
+    assert_eq!(strategy, "Cranelift");
 
     // This is an empty file right now which the `wast` crate doesn't parse
     if testname.contains("memory_copy1") {
diff --git a/cranelift/bforest/Cargo.toml b/cranelift/bforest/Cargo.toml
index 008e295bf..f452fe336 100644
--- a/cranelift/bforest/Cargo.toml
+++ b/cranelift/bforest/Cargo.toml
@@ -1,7 +1,7 @@
 [package]
 authors = ["The Cranelift Project Developers"]
 name = "cranelift-bforest"
-version = "0.99.0"
+version = "0.98.0"
 description = "A forest of B+-trees"
 license = "Apache-2.0 WITH LLVM-exception"
 documentation = "https://docs.rs/cranelift-bforest"
diff --git a/cranelift/codegen/Cargo.toml b/cranelift/codegen/Cargo.toml
index 7ad2f9226..1a9c3b9da 100644
--- a/cranelift/codegen/Cargo.toml
+++ b/cranelift/codegen/Cargo.toml
@@ -1,7 +1,7 @@
 [package]
 authors = ["The Cranelift Project Developers"]
 name = "cranelift-codegen"
-version = "0.99.0"
+version = "0.98.0"
 description = "Low-level code generator library"
 license = "Apache-2.0 WITH LLVM-exception"
 documentation = "https://docs.rs/cranelift-codegen"
@@ -16,7 +16,7 @@ edition.workspace = true
 anyhow = { workspace = true, optional = true }
 bumpalo = "3"
 capstone = { workspace = true, optional = true }
-cranelift-codegen-shared = { path = "./shared", version = "0.99.0" }
+cranelift-codegen-shared = { path = "./shared", version = "0.98.0" }
 cranelift-entity = { workspace = true }
 cranelift-bforest = { workspace = true }
 cranelift-control = { workspace = true }
@@ -40,8 +40,8 @@ criterion = { version = "0.4.0", features = ["html_reports"] }
 similar = "2.1.0"
 
 [build-dependencies]
-cranelift-codegen-meta = { path = "meta", version = "0.99.0" }
-cranelift-isle = { path = "../isle/isle", version = "=0.99.0" }
+cranelift-codegen-meta = { path = "meta", version = "0.98.0" }
+cranelift-isle = { path = "../isle/isle", version = "=0.98.0" }
 
 [features]
 default = ["std", "unwind", "host-arch"]
diff --git a/cranelift/codegen/meta/Cargo.toml b/cranelift/codegen/meta/Cargo.toml
index 9c6b1bbf9..499f141da 100644
--- a/cranelift/codegen/meta/Cargo.toml
+++ b/cranelift/codegen/meta/Cargo.toml
@@ -1,7 +1,7 @@
 [package]
 name = "cranelift-codegen-meta"
 authors = ["The Cranelift Project Developers"]
-version = "0.99.0"
+version = "0.98.0"
 description = "Metaprogram for cranelift-codegen code generator library"
 license = "Apache-2.0 WITH LLVM-exception"
 repository = "https://github.com/bytecodealliance/wasmtime"
@@ -13,4 +13,4 @@ edition.workspace = true
 # rustdoc-args = [ "--document-private-items" ]
 
 [dependencies]
-cranelift-codegen-shared = { path = "../shared", version = "0.99.0" }
+cranelift-codegen-shared = { path = "../shared", version = "0.98.0" }
diff --git a/cranelift/codegen/shared/Cargo.toml b/cranelift/codegen/shared/Cargo.toml
index 6137d0d2f..b4c4ee7e1 100644
--- a/cranelift/codegen/shared/Cargo.toml
+++ b/cranelift/codegen/shared/Cargo.toml
@@ -1,7 +1,7 @@
 [package]
 authors = ["The Cranelift Project Developers"]
 name = "cranelift-codegen-shared"
-version = "0.99.0"
+version = "0.98.0"
 description = "For code shared between cranelift-codegen-meta and cranelift-codegen"
 license = "Apache-2.0 WITH LLVM-exception"
 repository = "https://github.com/bytecodealliance/wasmtime"
diff --git a/cranelift/codegen/src/isa/riscv64/inst.isle b/cranelift/codegen/src/isa/riscv64/inst.isle
index 498086e7e..e4ab3354e 100644
--- a/cranelift/codegen/src/isa/riscv64/inst.isle
+++ b/cranelift/codegen/src/isa/riscv64/inst.isle
@@ -1717,40 +1717,6 @@
   (rv_or (value_regs_get x 0) (value_regs_get y 0)))
 
 
-
-(decl gen_bswap (Type XReg) XReg)
-
-;; This is only here to make the rule below work. bswap.i8 isn't valid
-(rule 0 (gen_bswap $I8 x) x)
-
-(rule 1 (gen_bswap (ty_int_ref_16_to_64 ty) x)
-  (if-let half_ty (ty_half_width ty))
-  (if-let half_size (u64_to_imm12 (ty_bits half_ty)))
-  (let (;; This swaps the top bytes and zeroes the bottom bytes, so that
-        ;; we can or it with the bottom bytes later.
-        (swap_top XReg (gen_bswap half_ty x))
-        (top XReg (rv_slli swap_top half_size))
-
-        ;; Get the top half, swap it, and zero extend it so we can `or` it
-        ;; with the bottom half.
-        (shifted XReg (rv_srli x half_size))
-        (swap_bot XReg (gen_bswap half_ty shifted))
-        (bot XReg (zext swap_bot half_ty $I64)))
-    (rv_or top bot)))
-
-;; With `zbb` we can use `rev8` and shift the result
-(rule 2 (gen_bswap (int_fits_in_32 ty) x)
-  (if-let $true (has_zbb))
-  (if-let shift_amt (u64_to_imm12 (u64_sub 64 (ty_bits ty))))
-  (rv_srli (rv_rev8 x) shift_amt))
-
-;; With `zbb` we can use `rev8` that does this
-(rule 3 (gen_bswap $I64 x)
-  (if-let $true (has_zbb))
-  (rv_rev8 x))
-
-
-
 (decl lower_bit_reverse (Reg Type) Reg)
 
 (rule
diff --git a/cranelift/codegen/src/isa/riscv64/lower.isle b/cranelift/codegen/src/isa/riscv64/lower.isle
index 74adb15d8..ae65b21a4 100644
--- a/cranelift/codegen/src/isa/riscv64/lower.isle
+++ b/cranelift/codegen/src/isa/riscv64/lower.isle
@@ -679,15 +679,6 @@
     (hi_rev XReg (lower_bit_reverse (value_regs_get val 1) $I64)))
     (value_regs hi_rev lo_rev)))
 
-;;;; Rules for `bswap` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
-(rule 1 (lower (has_type (fits_in_64 (ty_int ty)) (bswap x)))
-  (gen_bswap ty x))
-
-(rule 2 (lower (has_type $I128 (bswap x)))
-  (value_regs
-    (gen_bswap $I64 (value_regs_get x 1))
-    (gen_bswap $I64 (value_regs_get x 0))))
-
 
 ;;;; Rules for `ctz` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 (rule (lower (has_type (fits_in_64 ty) (ctz x)))
diff --git a/cranelift/codegen/src/isa/x64/lower.isle b/cranelift/codegen/src/isa/x64/lower.isle
index 3c36f64c4..250397f9a 100644
--- a/cranelift/codegen/src/isa/x64/lower.isle
+++ b/cranelift/codegen/src/isa/x64/lower.isle
@@ -4395,7 +4395,6 @@
         (x64_vpbroadcastb (bitcast_gpr_to_xmm $I32 src)))
 (rule 3 (lower (has_type $I8X16 (splat (sinkable_load_exact addr))))
         (if-let $true (use_sse41))
-        (if-let $true (use_ssse3))
         (x64_pshufb (x64_pinsrb (xmm_uninit_value) addr 0) (xmm_zero $I8X16)))
 (rule 4 (lower (has_type $I8X16 (splat (sinkable_load_exact addr))))
         (if-let $true (use_avx2))
diff --git a/cranelift/codegen/src/machinst/abi.rs b/cranelift/codegen/src/machinst/abi.rs
index 1ffbb7cbd..1697c700c 100644
--- a/cranelift/codegen/src/machinst/abi.rs
+++ b/cranelift/codegen/src/machinst/abi.rs
@@ -494,10 +494,10 @@ pub trait ABIMachineSpec {
     ///   temporary as this one.
     fn get_stacklimit_reg(call_conv: isa::CallConv) -> Reg;
 
-    /// Generate a load to the given [base+offset] address.
+    /// Generate a store to the given [base+offset] address.
     fn gen_load_base_offset(into_reg: Writable<Reg>, base: Reg, offset: i32, ty: Type) -> Self::I;
 
-    /// Generate a store from the given [base+offset] address.
+    /// Generate a load from the given [base+offset] address.
     fn gen_store_base_offset(base: Reg, offset: i32, from_reg: Reg, ty: Type) -> Self::I;
 
     /// Adjust the stack pointer up or down.
diff --git a/cranelift/codegen/src/opts/cprop.isle b/cranelift/codegen/src/opts/cprop.isle
index 338c694b0..79c88d8a3 100644
--- a/cranelift/codegen/src/opts/cprop.isle
+++ b/cranelift/codegen/src/opts/cprop.isle
@@ -70,9 +70,6 @@
                       (iconst _ k2)))
       (subsume (iconst ty (imm64_sshr ty k1 k2))))
 
-(rule (simplify (ireduce narrow (iconst (fits_in_64 _) (u64_from_imm64 imm))))
-      (subsume (iconst narrow (imm64_masked narrow imm))))
-
 (rule (simplify (uextend (fits_in_64 wide) (iconst narrow imm)))
       (subsume (iconst wide (imm64 (u64_uextend_imm64 narrow imm)))))
 
diff --git a/cranelift/control/Cargo.toml b/cranelift/control/Cargo.toml
index 0cd32a457..1ca59d9af 100644
--- a/cranelift/control/Cargo.toml
+++ b/cranelift/control/Cargo.toml
@@ -1,7 +1,7 @@
 [package]
 authors = ["The Cranelift Project Developers"]
 name = "cranelift-control"
-version = "0.99.0"
+version = "0.98.0"
 description = "White-box fuzz testing framework"
 license = "Apache-2.0 WITH LLVM-exception"
 repository = "https://github.com/bytecodealliance/wasmtime"
diff --git a/cranelift/entity/Cargo.toml b/cranelift/entity/Cargo.toml
index b1383a03d..ac15a4e72 100644
--- a/cranelift/entity/Cargo.toml
+++ b/cranelift/entity/Cargo.toml
@@ -1,7 +1,7 @@
 [package]
 authors = ["The Cranelift Project Developers"]
 name = "cranelift-entity"
-version = "0.99.0"
+version = "0.98.0"
 description = "Data structures using entity references as mapping keys"
 license = "Apache-2.0 WITH LLVM-exception"
 documentation = "https://docs.rs/cranelift-entity"
diff --git a/cranelift/filetests/Cargo.toml b/cranelift/filetests/Cargo.toml
index 04b4a57ed..70f6cf039 100644
--- a/cranelift/filetests/Cargo.toml
+++ b/cranelift/filetests/Cargo.toml
@@ -33,3 +33,4 @@ serde = { workspace = true }
 cranelift-wasm.workspace = true
 wasmparser.workspace = true
 cranelift.workspace = true
+wasmtime-types = { workspace = true }
\ No newline at end of file
diff --git a/cranelift/filetests/filetests/egraph/cprop.clif b/cranelift/filetests/filetests/egraph/cprop.clif
index e9fef8ca8..dc781a79a 100644
--- a/cranelift/filetests/filetests/egraph/cprop.clif
+++ b/cranelift/filetests/filetests/egraph/cprop.clif
@@ -230,33 +230,3 @@ block0:
 
 ; check: v3 = iconst.i8 0
 ; nextln: return v3
-
-function %ireduce_iconst() -> i8 {
-block0:
-    v1 = iconst.i16 -10
-    v2 = ireduce.i8 v1
-    return v2
-}
-
-; check: v3 = iconst.i8 246
-; nextln: return v3
-
-function %sextend_iconst() -> i32 {
-block0:
-    v1 = iconst.i16 -10
-    v2 = sextend.i32 v1
-    return v2
-}
-
-; check: v3 = iconst.i32 0xffff_fff6
-; nextln: return v3
-
-function %uextend_iconst() -> i32 {
-block0:
-    v1 = iconst.i16 0xfff6
-    v2 = uextend.i32 v1
-    return v2
-}
-
-; check: v3 = iconst.i32 0xfff6
-; nextln: return v3
diff --git a/cranelift/filetests/filetests/isa/riscv64/bswap-zbb.clif b/cranelift/filetests/filetests/isa/riscv64/bswap-zbb.clif
deleted file mode 100644
index 1de389278..000000000
--- a/cranelift/filetests/filetests/isa/riscv64/bswap-zbb.clif
+++ /dev/null
@@ -1,76 +0,0 @@
-test compile precise-output
-set unwind_info=false
-target riscv64 has_zbb
-
-function %bswap_i16(i16) -> i16 {
-block0(v0: i16):
-    v1 = bswap v0
-    return v1
-}
-
-; VCode:
-; block0:
-;   rev8 t2,a0
-;   srli a0,t2,48
-;   ret
-;
-; Disassembled:
-; block0: ; offset 0x0
-;   .byte 0x93, 0x53, 0x85, 0x6b
-;   srli a0, t2, 0x30
-;   ret
-
-function %bswap_i32(i32) -> i32 {
-block0(v0: i32):
-    v1 = bswap v0
-    return v1
-}
-
-; VCode:
-; block0:
-;   rev8 t2,a0
-;   srli a0,t2,32
-;   ret
-;
-; Disassembled:
-; block0: ; offset 0x0
-;   .byte 0x93, 0x53, 0x85, 0x6b
-;   srli a0, t2, 0x20
-;   ret
-
-function %bswap_i64(i64) -> i64 {
-block0(v0: i64):
-    v1 = bswap v0
-    return v1
-}
-
-; VCode:
-; block0:
-;   rev8 a0,a0
-;   ret
-;
-; Disassembled:
-; block0: ; offset 0x0
-;   .byte 0x13, 0x55, 0x85, 0x6b
-;   ret
-
-function %bswap_i128(i128) -> i128 {
-block0(v0: i128):
-    v1 = bswap v0
-    return v1
-}
-
-; VCode:
-; block0:
-;   mv a3,a0
-;   rev8 a0,a1
-;   rev8 a1,a3
-;   ret
-;
-; Disassembled:
-; block0: ; offset 0x0
-;   ori a3, a0, 0
-;   .byte 0x13, 0xd5, 0x85, 0x6b
-;   .byte 0x93, 0xd5, 0x86, 0x6b
-;   ret
-
diff --git a/cranelift/filetests/filetests/isa/riscv64/bswap.clif b/cranelift/filetests/filetests/isa/riscv64/bswap.clif
deleted file mode 100644
index 05e74875b..000000000
--- a/cranelift/filetests/filetests/isa/riscv64/bswap.clif
+++ /dev/null
@@ -1,307 +0,0 @@
-test compile precise-output
-set unwind_info=false
-target riscv64
-
-function %bswap_i16(i16) -> i16 {
-block0(v0: i16):
-    v1 = bswap v0
-    return v1
-}
-
-; VCode:
-; block0:
-;   slli t2,a0,8
-;   srli a1,a0,8
-;   andi a3,a1,255
-;   or a0,t2,a3
-;   ret
-;
-; Disassembled:
-; block0: ; offset 0x0
-;   slli t2, a0, 8
-;   srli a1, a0, 8
-;   andi a3, a1, 0xff
-;   or a0, t2, a3
-;   ret
-
-function %bswap_i32(i32) -> i32 {
-block0(v0: i32):
-    v1 = bswap v0
-    return v1
-}
-
-; VCode:
-; block0:
-;   slli t2,a0,8
-;   srli a1,a0,8
-;   andi a3,a1,255
-;   or a5,t2,a3
-;   slli a7,a5,16
-;   srli t4,a0,16
-;   slli t1,t4,8
-;   srli a0,t4,8
-;   andi a2,a0,255
-;   or a4,t1,a2
-;   slli a6,a4,48
-;   srli t3,a6,48
-;   or a0,a7,t3
-;   ret
-;
-; Disassembled:
-; block0: ; offset 0x0
-;   slli t2, a0, 8
-;   srli a1, a0, 8
-;   andi a3, a1, 0xff
-;   or a5, t2, a3
-;   slli a7, a5, 0x10
-;   srli t4, a0, 0x10
-;   slli t1, t4, 8
-;   srli a0, t4, 8
-;   andi a2, a0, 0xff
-;   or a4, t1, a2
-;   slli a6, a4, 0x30
-;   srli t3, a6, 0x30
-;   or a0, a7, t3
-;   ret
-
-function %bswap_i64(i64) -> i64 {
-block0(v0: i64):
-    v1 = bswap v0
-    return v1
-}
-
-; VCode:
-; block0:
-;   slli t2,a0,8
-;   srli a1,a0,8
-;   andi a3,a1,255
-;   or a5,t2,a3
-;   slli a7,a5,16
-;   srli t4,a0,16
-;   slli t1,t4,8
-;   srli a1,t4,8
-;   andi a2,a1,255
-;   or a4,t1,a2
-;   slli a6,a4,48
-;   srli t3,a6,48
-;   or t0,a7,t3
-;   slli t2,t0,32
-;   srli a1,a0,32
-;   slli a3,a1,8
-;   srli a5,a1,8
-;   andi a7,a5,255
-;   or t4,a3,a7
-;   slli t1,t4,16
-;   srli a0,a1,16
-;   slli a2,a0,8
-;   srli a4,a0,8
-;   andi a6,a4,255
-;   or t3,a2,a6
-;   slli t0,t3,48
-;   srli a0,t0,48
-;   or a1,t1,a0
-;   slli a3,a1,32
-;   srli a5,a3,32
-;   or a0,t2,a5
-;   ret
-;
-; Disassembled:
-; block0: ; offset 0x0
-;   slli t2, a0, 8
-;   srli a1, a0, 8
-;   andi a3, a1, 0xff
-;   or a5, t2, a3
-;   slli a7, a5, 0x10
-;   srli t4, a0, 0x10
-;   slli t1, t4, 8
-;   srli a1, t4, 8
-;   andi a2, a1, 0xff
-;   or a4, t1, a2
-;   slli a6, a4, 0x30
-;   srli t3, a6, 0x30
-;   or t0, a7, t3
-;   slli t2, t0, 0x20
-;   srli a1, a0, 0x20
-;   slli a3, a1, 8
-;   srli a5, a1, 8
-;   andi a7, a5, 0xff
-;   or t4, a3, a7
-;   slli t1, t4, 0x10
-;   srli a0, a1, 0x10
-;   slli a2, a0, 8
-;   srli a4, a0, 8
-;   andi a6, a4, 0xff
-;   or t3, a2, a6
-;   slli t0, t3, 0x30
-;   srli a0, t0, 0x30
-;   or a1, t1, a0
-;   slli a3, a1, 0x20
-;   srli a5, a3, 0x20
-;   or a0, t2, a5
-;   ret
-
-function %bswap_i128(i128) -> i128 {
-block0(v0: i128):
-    v1 = bswap v0
-    return v1
-}
-
-; VCode:
-;   add sp,-16
-;   sd ra,8(sp)
-;   sd fp,0(sp)
-;   mv fp,sp
-;   sd s11,-8(sp)
-;   add sp,-16
-; block0:
-;   slli a2,a1,8
-;   srli a3,a1,8
-;   andi a4,a3,255
-;   or a6,a2,a4
-;   slli t3,a6,16
-;   srli t0,a1,16
-;   slli t2,t0,8
-;   srli a2,t0,8
-;   andi a3,a2,255
-;   or a5,t2,a3
-;   slli a7,a5,48
-;   srli t4,a7,48
-;   or t1,t3,t4
-;   slli a2,t1,32
-;   srli a3,a1,32
-;   slli a4,a3,8
-;   srli a6,a3,8
-;   andi t3,a6,255
-;   or t0,a4,t3
-;   slli t2,t0,16
-;   srli a1,a3,16
-;   slli a3,a1,8
-;   srli a5,a1,8
-;   andi a7,a5,255
-;   or t4,a3,a7
-;   slli t1,t4,48
-;   srli a1,t1,48
-;   or a3,t2,a1
-;   slli a4,a3,32
-;   srli a6,a4,32
-;   or t3,a2,a6
-;   mv s11,t3
-;   slli t0,a0,8
-;   srli t2,a0,8
-;   andi a1,t2,255
-;   or a3,t0,a1
-;   slli a5,a3,16
-;   srli a7,a0,16
-;   slli t4,a7,8
-;   srli t1,a7,8
-;   andi a1,t1,255
-;   or a2,t4,a1
-;   slli a4,a2,48
-;   srli a6,a4,48
-;   or t3,a5,a6
-;   slli t0,t3,32
-;   srli t2,a0,32
-;   slli a1,t2,8
-;   srli a3,t2,8
-;   andi a5,a3,255
-;   or a7,a1,a5
-;   slli t4,a7,16
-;   srli t1,t2,16
-;   slli a0,t1,8
-;   srli a2,t1,8
-;   andi a4,a2,255
-;   or a6,a0,a4
-;   slli t3,a6,48
-;   srli t1,t3,48
-;   or t2,t4,t1
-;   slli a1,t2,32
-;   srli a3,a1,32
-;   or a1,t0,a3
-;   mv a0,s11
-;   add sp,+16
-;   ld s11,-8(sp)
-;   ld ra,8(sp)
-;   ld fp,0(sp)
-;   add sp,+16
-;   ret
-;
-; Disassembled:
-; block0: ; offset 0x0
-;   addi sp, sp, -0x10
-;   sd ra, 8(sp)
-;   sd s0, 0(sp)
-;   ori s0, sp, 0
-;   sd s11, -8(sp)
-;   addi sp, sp, -0x10
-; block1: ; offset 0x18
-;   slli a2, a1, 8
-;   srli a3, a1, 8
-;   andi a4, a3, 0xff
-;   or a6, a2, a4
-;   slli t3, a6, 0x10
-;   srli t0, a1, 0x10
-;   slli t2, t0, 8
-;   srli a2, t0, 8
-;   andi a3, a2, 0xff
-;   or a5, t2, a3
-;   slli a7, a5, 0x30
-;   srli t4, a7, 0x30
-;   or t1, t3, t4
-;   slli a2, t1, 0x20
-;   srli a3, a1, 0x20
-;   slli a4, a3, 8
-;   srli a6, a3, 8
-;   andi t3, a6, 0xff
-;   or t0, a4, t3
-;   slli t2, t0, 0x10
-;   srli a1, a3, 0x10
-;   slli a3, a1, 8
-;   srli a5, a1, 8
-;   andi a7, a5, 0xff
-;   or t4, a3, a7
-;   slli t1, t4, 0x30
-;   srli a1, t1, 0x30
-;   or a3, t2, a1
-;   slli a4, a3, 0x20
-;   srli a6, a4, 0x20
-;   or t3, a2, a6
-;   ori s11, t3, 0
-;   slli t0, a0, 8
-;   srli t2, a0, 8
-;   andi a1, t2, 0xff
-;   or a3, t0, a1
-;   slli a5, a3, 0x10
-;   srli a7, a0, 0x10
-;   slli t4, a7, 8
-;   srli t1, a7, 8
-;   andi a1, t1, 0xff
-;   or a2, t4, a1
-;   slli a4, a2, 0x30
-;   srli a6, a4, 0x30
-;   or t3, a5, a6
-;   slli t0, t3, 0x20
-;   srli t2, a0, 0x20
-;   slli a1, t2, 8
-;   srli a3, t2, 8
-;   andi a5, a3, 0xff
-;   or a7, a1, a5
-;   slli t4, a7, 0x10
-;   srli t1, t2, 0x10
-;   slli a0, t1, 8
-;   srli a2, t1, 8
-;   andi a4, a2, 0xff
-;   or a6, a0, a4
-;   slli t3, a6, 0x30
-;   srli t1, t3, 0x30
-;   or t2, t4, t1
-;   slli a1, t2, 0x20
-;   srli a3, a1, 0x20
-;   or a1, t0, a3
-;   ori a0, s11, 0
-;   addi sp, sp, 0x10
-;   ld s11, -8(sp)
-;   ld ra, 8(sp)
-;   ld s0, 0(sp)
-;   addi sp, sp, 0x10
-;   ret
-
diff --git a/cranelift/filetests/filetests/runtests/bswap.clif b/cranelift/filetests/filetests/runtests/bswap.clif
index d8f168242..066cf59d0 100644
--- a/cranelift/filetests/filetests/runtests/bswap.clif
+++ b/cranelift/filetests/filetests/runtests/bswap.clif
@@ -3,8 +3,6 @@ test run
 target x86_64
 target aarch64
 target s390x
-target riscv64
-target riscv64 has_zbb
 
 function %bswap_i16(i16) -> i16 {
 block0(v0: i16):
diff --git a/cranelift/filetests/filetests/runtests/i128-bswap.clif b/cranelift/filetests/filetests/runtests/i128-bswap.clif
index 33b030004..62651992c 100644
--- a/cranelift/filetests/filetests/runtests/i128-bswap.clif
+++ b/cranelift/filetests/filetests/runtests/i128-bswap.clif
@@ -4,8 +4,6 @@ set enable_llvm_abi_extensions
 target x86_64
 target aarch64
 target s390x
-target riscv64
-target riscv64 has_zbb
 
 function %bswap_i128(i128) -> i128 {
 block0(v0: i128):
diff --git a/cranelift/filetests/filetests/runtests/simd-valltrue.clif b/cranelift/filetests/filetests/runtests/simd-valltrue.clif
index 870687b77..a1cc51488 100644
--- a/cranelift/filetests/filetests/runtests/simd-valltrue.clif
+++ b/cranelift/filetests/filetests/runtests/simd-valltrue.clif
@@ -16,12 +16,7 @@ block0(v0: i8x16):
 ; run: %vall_true_i8x16([0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]) == 0
 ; run: %vall_true_i8x16([-1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]) == 0
 ; run: %vall_true_i8x16([-1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1]) == 1
-; run: %vall_true_i8x16(0xffffffffffffffffffffffffffffff00) == 0
-; run: %vall_true_i8x16(0x00ffffffffffffffffffffffffffffff) == 0
-; run: %vall_true_i8x16(0xffffffffffffff00ffffffffffffffff) == 0
-; run: %vall_true_i8x16(0x01010101010101010101010101010101) == 1
-; run: %vall_true_i8x16(0xffffffffffffffffffffffffffffffff) == 1
-; run: %vall_true_i8x16(0xe66021830506f2fffdfebfc8c8c8c8c8) == 1
+
 
 function %vall_true_i16x8(i16x8) -> i8 {
 block0(v0: i16x8):
@@ -51,4 +46,3 @@ block0(v0: i64x2):
 ; run: %vall_true_i64x2([0 0]) == 0
 ; run: %vall_true_i64x2([-1 0]) == 0
 ; run: %vall_true_i64x2([-1 -1]) == 1
-; run: %vall_true_i64x2([0xffffffff_00000000 -1]) == 1
diff --git a/cranelift/filetests/src/function_runner.rs b/cranelift/filetests/src/function_runner.rs
index 5f034fc51..dff1fda6c 100644
--- a/cranelift/filetests/src/function_runner.rs
+++ b/cranelift/filetests/src/function_runner.rs
@@ -90,7 +90,7 @@ impl TestFileCompiler {
     /// [TestFileCompiler::with_host_isa]).
     pub fn new(isa: OwnedTargetIsa) -> Self {
         let mut builder = JITBuilder::with_isa(isa, cranelift_module::default_libcall_names());
-        let _ = &mut builder; // require mutability on all architectures
+        drop(&mut builder); // require mutability on all architectures
         #[cfg(target_arch = "x86_64")]
         {
             builder.symbol_lookup_fn(Box::new(|name| {
diff --git a/cranelift/filetests/src/runtest_environment.rs b/cranelift/filetests/src/runtest_environment.rs
new file mode 100644
index 000000000..8a32e8161
--- /dev/null
+++ b/cranelift/filetests/src/runtest_environment.rs
@@ -0,0 +1,36 @@
+use anyhow::anyhow;
+use cranelift_codegen::ir::{ArgumentPurpose, Function};
+use cranelift_reader::Comment;
+
+/// Stores info about the expected environment for a test function.
+#[derive(Debug, Clone)]
+pub struct RuntestEnvironment {}
+
+impl RuntestEnvironment {
+    /// Parse the environment from a set of comments
+    pub fn parse(comments: &[Comment]) -> anyhow::Result<Self> {
+        let mut env = RuntestEnvironment {};
+        Ok(env)
+    }
+
+    /// Validates the signature of a [Function] ensuring that if this environment is active, the
+    /// function has a `vmctx` argument
+    pub fn validate_signature(&self, func: &Function) -> Result<(), String> {
+        let first_arg_is_vmctx = func
+            .signature
+            .params
+            .first()
+            .map(|p| p.purpose == ArgumentPurpose::VMContext)
+            .unwrap_or(false);
+
+        if !first_arg_is_vmctx && self.is_active() {
+            return Err(concat!(
+                "This test requests a heap, but the first argument is not `i64 vmctx`.\n",
+                "See docs/testing.md for more info on using heap annotations."
+            )
+            .to_string());
+        }
+
+        Ok(())
+    }
+}
diff --git a/cranelift/filetests/src/test_wasm/env.rs b/cranelift/filetests/src/test_wasm/env.rs
index c96fa2009..b17a8b9d1 100644
--- a/cranelift/filetests/src/test_wasm/env.rs
+++ b/cranelift/filetests/src/test_wasm/env.rs
@@ -649,4 +649,173 @@ impl<'a> FuncEnvironment for FuncEnv<'a> {
     ) -> cranelift_wasm::WasmResult<ir::Inst> {
         unimplemented!()
     }
+
+    /// TODO(dhil): write documentation.
+    fn translate_cont_new(
+        &mut self,
+        builder: &mut cranelift_frontend::FunctionBuilder,
+        state: &cranelift_wasm::FuncTranslationState,
+        func: ir::Value,
+        arg_types: &[wasmtime_types::WasmType],
+        return_types: &[wasmtime_types::WasmType],
+    ) -> cranelift_wasm::WasmResult<ir::Value> {
+        self.inner
+            .translate_cont_new(builder, state, func, arg_types, return_types)
+    }
+
+    /// Translates a resume instruction and returns a triple (vmctx,
+    /// signal, tag), where vmctx is the base address of the VM
+    /// context, signal is high bit of the resume result, and tag is
+    /// the index of the control tag supplied to suspend (if the
+    /// signal is 1).
+    fn translate_resume(
+        &mut self,
+        builder: &mut cranelift_frontend::FunctionBuilder,
+        state: &cranelift_wasm::FuncTranslationState,
+        cont: ir::Value,
+        call_arg_types: &[wasmtime_types::WasmType],
+        call_args: &[ir::Value],
+    ) -> cranelift_wasm::WasmResult<(ir::Value, ir::Value, ir::Value)> {
+        self.inner
+            .translate_resume(builder, state, cont, call_arg_types, call_args)
+    }
+
+    /// TODO(dhil): write documentation.
+    fn translate_resume_throw(
+        &mut self,
+        pos: cranelift_codegen::cursor::FuncCursor,
+        state: &cranelift_wasm::FuncTranslationState,
+        tag_index: u32,
+        cont: ir::Value,
+    ) -> cranelift_wasm::WasmResult<ir::Value> {
+        self.inner
+            .translate_resume_throw(pos, state, tag_index, cont)
+    }
+
+    /// TODO(dhil): write documentation.
+    fn translate_suspend(
+        &mut self,
+        builder: &mut cranelift_frontend::FunctionBuilder,
+        state: &cranelift_wasm::FuncTranslationState,
+        tag_index: u32,
+    ) -> ir::Value {
+        return self.inner.translate_suspend(builder, state, tag_index);
+    }
+
+    /// TODO
+    fn continuation_arguments(&self, type_index: u32) -> &[wasmtime_types::WasmType] {
+        self.inner.continuation_arguments(type_index)
+    }
+
+    /// TODO
+    fn continuation_returns(&self, type_index: u32) -> &[wasmtime_types::WasmType] {
+        self.inner.continuation_returns(type_index)
+    }
+
+    /// TODO
+    fn typed_continuations_load_payloads(
+        &mut self,
+        builder: &mut cranelift_frontend::FunctionBuilder,
+        valtypes: &[wasmtime_types::WasmType],
+    ) -> std::vec::Vec<ir::Value> {
+        self.inner
+            .typed_continuations_load_payloads(builder, valtypes)
+    }
+
+    /// TODO
+    fn typed_continuations_store_payloads(
+        &mut self,
+        builder: &mut cranelift_frontend::FunctionBuilder,
+        valtypes: &[wasmtime_types::WasmType],
+        values: &[ir::Value],
+    ) {
+        self.inner
+            .typed_continuations_store_payloads(builder, valtypes, values)
+    }
+
+    /// TODO
+    fn tag_params(&self, tag_index: u32) -> &[wasmtime_types::WasmType] {
+        self.inner.tag_params(tag_index)
+    }
+
+    /// TODO
+    fn tag_returns(&self, tag_index: u32) -> &[wasmtime_types::WasmType] {
+        self.inner.tag_returns(tag_index)
+    }
+
+    /// TODO
+    fn typed_continuations_load_continuation_object(
+        &self,
+        builder: &mut cranelift_frontend::FunctionBuilder,
+        base_addr: ir::Value,
+    ) -> ir::Value {
+        self.inner
+            .typed_continuations_load_continuation_object(builder, base_addr)
+    }
+
+    fn typed_continuations_load_return_values(
+        &mut self,
+        builder: &mut cranelift_frontend::FunctionBuilder,
+        valtypes: &[wasmtime_types::WasmType],
+        contobj: ir::Value,
+    ) -> std::vec::Vec<ir::Value> {
+        self.inner
+            .typed_continuations_load_return_values(builder, valtypes, contobj)
+    }
+
+    fn typed_continuations_store_resume_args(
+        &mut self,
+        builder: &mut cranelift_frontend::FunctionBuilder,
+        values: &[ir::Value],
+        remaining_arg_count: ir::Value,
+        contobj: ir::Value,
+    ) {
+        self.inner.typed_continuations_store_resume_args(
+            builder,
+            values,
+            remaining_arg_count,
+            contobj,
+        )
+    }
+
+    /// TODO
+    fn typed_continuations_new_cont_ref(
+        &mut self,
+        builder: &mut cranelift_frontend::FunctionBuilder,
+        contobj_addr: ir::Value,
+    ) -> ir::Value {
+        self.inner
+            .typed_continuations_new_cont_ref(builder, contobj_addr)
+    }
+
+    /// TODO
+    fn typed_continuations_cont_ref_get_cont_obj(
+        &mut self,
+        builder: &mut cranelift_frontend::FunctionBuilder,
+        contref: ir::Value,
+    ) -> ir::Value {
+        self.inner
+            .typed_continuations_cont_ref_get_cont_obj(builder, contref)
+    }
+
+    /// TODO
+    fn typed_continuations_drop_cont_obj(
+        &mut self,
+        builder: &mut cranelift_frontend::FunctionBuilder,
+        contobj: ir::Value,
+    ) {
+        self.inner
+            .typed_continuations_drop_cont_obj(builder, contobj)
+    }
+
+    fn typed_continuations_load_tag_return_values(
+        &mut self,
+        builder: &mut cranelift_frontend::FunctionBuilder,
+        contobj: ir::Value,
+        valtypes: &[wasmtime_types::WasmType],
+    ) -> Vec<ir::Value> {
+        return self
+            .inner
+            .typed_continuations_load_tag_return_values(builder, contobj, valtypes);
+    }
 }
diff --git a/cranelift/frontend/Cargo.toml b/cranelift/frontend/Cargo.toml
index 68f29ec72..b08e14375 100644
--- a/cranelift/frontend/Cargo.toml
+++ b/cranelift/frontend/Cargo.toml
@@ -1,7 +1,7 @@
 [package]
 authors = ["The Cranelift Project Developers"]
 name = "cranelift-frontend"
-version = "0.99.0"
+version = "0.98.0"
 description = "Cranelift IR builder helper"
 license = "Apache-2.0 WITH LLVM-exception"
 documentation = "https://docs.rs/cranelift-frontend"
diff --git a/cranelift/fuzzgen/src/function_generator.rs b/cranelift/fuzzgen/src/function_generator.rs
index dbc8d3d67..f4d0746e5 100644
--- a/cranelift/fuzzgen/src/function_generator.rs
+++ b/cranelift/fuzzgen/src/function_generator.rs
@@ -714,6 +714,8 @@ fn valid_for_target(triple: &Triple, op: Opcode, args: &[Type], rets: &[Type]) -
                 (Opcode::Iabs, &[I128]),
                 // TODO
                 (Opcode::Bitselect, &[I128, I128, I128]),
+                // TODO
+                (Opcode::Bswap),
                 // https://github.com/bytecodealliance/wasmtime/issues/5528
                 (
                     Opcode::FcvtToUint | Opcode::FcvtToSint,
diff --git a/cranelift/interpreter/Cargo.toml b/cranelift/interpreter/Cargo.toml
index 9648a7ccb..3e9e7a968 100644
--- a/cranelift/interpreter/Cargo.toml
+++ b/cranelift/interpreter/Cargo.toml
@@ -1,6 +1,6 @@
 [package]
 name = "cranelift-interpreter"
-version = "0.99.0"
+version = "0.98.0"
 authors = ["The Cranelift Project Developers"]
 description = "Interpret Cranelift IR"
 repository = "https://github.com/bytecodealliance/wasmtime"
diff --git a/cranelift/interpreter/src/step.rs b/cranelift/interpreter/src/step.rs
index 3ee76362c..8c8e19c26 100644
--- a/cranelift/interpreter/src/step.rs
+++ b/cranelift/interpreter/src/step.rs
@@ -1040,13 +1040,12 @@ where
             let any = fold_vector(arg(0), ctrl_ty, init.clone(), |acc, lane| acc.or(lane))?;
             assign(DataValue::bool(any != init, false, types::I8)?)
         }
-        Opcode::VallTrue => assign(DataValue::bool(
-            !(arg(0).iter_lanes(ctrl_ty)?.try_fold(false, |acc, lane| {
-                Ok::<bool, ValueError>(acc | lane.is_zero()?)
-            })?),
-            false,
-            types::I8,
-        )?),
+        Opcode::VallTrue => {
+            let lane_ty = ctrl_ty.lane_type();
+            let init = DataValue::bool(true, true, lane_ty)?;
+            let all = fold_vector(arg(0), ctrl_ty, init.clone(), |acc, lane| acc.and(lane))?;
+            assign(DataValue::bool(all == init, false, types::I8)?)
+        }
         Opcode::SwidenLow | Opcode::SwidenHigh | Opcode::UwidenLow | Opcode::UwidenHigh => {
             let new_type = ctrl_ty.merge_lanes().unwrap();
             let conv_type = match inst.opcode() {
@@ -1435,14 +1434,11 @@ fn fcmp(code: FloatCC, left: &DataValue, right: &DataValue) -> ValueResult<bool>
     })
 }
 
-pub type SimdVec<DataValue> = SmallVec<[DataValue; 4]>;
+type SimdVec<DataValue> = SmallVec<[DataValue; 4]>;
 
 /// Converts a SIMD vector value into a Rust array of [Value] for processing.
 /// If `x` is a scalar, it will be returned as a single-element array.
-pub(crate) fn extractlanes(
-    x: &DataValue,
-    vector_type: types::Type,
-) -> ValueResult<SimdVec<DataValue>> {
+fn extractlanes(x: &DataValue, vector_type: types::Type) -> ValueResult<SimdVec<DataValue>> {
     let lane_type = vector_type.lane_type();
     let mut lanes = SimdVec::new();
     // Wrap scalar values as a single-element vector and return.
diff --git a/cranelift/interpreter/src/value.rs b/cranelift/interpreter/src/value.rs
index abde5302d..d75307fdd 100644
--- a/cranelift/interpreter/src/value.rs
+++ b/cranelift/interpreter/src/value.rs
@@ -8,8 +8,6 @@ use cranelift_codegen::ir::immediates::{Ieee32, Ieee64};
 use cranelift_codegen::ir::{types, Type};
 use thiserror::Error;
 
-use crate::step::{extractlanes, SimdVec};
-
 pub type ValueResult<T> = Result<T, ValueError>;
 
 pub trait DataValueExt: Sized {
@@ -91,9 +89,6 @@ pub trait DataValueExt: Sized {
     fn trailing_zeros(self) -> ValueResult<Self>;
     fn reverse_bits(self) -> ValueResult<Self>;
     fn swap_bytes(self) -> ValueResult<Self>;
-
-    // An iterator over the lanes of a SIMD type
-    fn iter_lanes(&self, ty: Type) -> ValueResult<DataValueIterator>;
 }
 
 #[derive(Error, Debug, PartialEq)]
@@ -489,16 +484,9 @@ impl DataValueExt for DataValue {
 
     fn is_zero(&self) -> ValueResult<bool> {
         match self {
-            DataValue::I8(f) => Ok(*f == 0),
-            DataValue::I16(f) => Ok(*f == 0),
-            DataValue::I32(f) => Ok(*f == 0),
-            DataValue::I64(f) => Ok(*f == 0),
-            DataValue::I128(f) => Ok(*f == 0),
             DataValue::F32(f) => Ok(f.is_zero()),
             DataValue::F64(f) => Ok(f.is_zero()),
-            DataValue::V64(_) | DataValue::V128(_) => {
-                Err(ValueError::InvalidType(ValueTypeClass::Float, self.ty()))
-            }
+            _ => Err(ValueError::InvalidType(ValueTypeClass::Float, self.ty())),
         }
     }
 
@@ -820,90 +808,4 @@ impl DataValueExt for DataValue {
     fn swap_bytes(self) -> ValueResult<Self> {
         unary_match!(swap_bytes(&self); [I16, I32, I64, I128])
     }
-
-    fn iter_lanes(&self, ty: Type) -> ValueResult<DataValueIterator> {
-        DataValueIterator::new(self, ty)
-    }
-}
-
-/// Iterator for DataValue's
-pub struct DataValueIterator {
-    ty: Type,
-    v: SimdVec<DataValue>,
-    idx: usize,
-}
-
-impl DataValueIterator {
-    fn new(dv: &DataValue, ty: Type) -> Result<Self, ValueError> {
-        match extractlanes(dv, ty) {
-            Ok(v) => return Ok(Self { ty, v, idx: 0 }),
-            Err(err) => return Err(err),
-        }
-    }
-}
-
-impl Iterator for DataValueIterator {
-    type Item = DataValue;
-
-    fn next(&mut self) -> Option<Self::Item> {
-        if self.idx >= self.ty.lane_count() as usize {
-            return None;
-        }
-
-        let dv = self.v[self.idx].clone();
-        self.idx += 1;
-        Some(dv)
-    }
-}
-
-#[cfg(test)]
-mod test {
-    use super::*;
-
-    #[test]
-    fn test_iterator_v128() {
-        let dv = DataValue::V128([99, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);
-        assert_eq!(simd_sum(dv, types::I8X16), 219);
-    }
-
-    #[test]
-    fn test_iterator_v128_empty() {
-        let dv = DataValue::V128([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
-        assert_eq!(simd_sum(dv, types::I8X16), 0);
-    }
-
-    #[test]
-    fn test_iterator_v128_ones() {
-        let dv = DataValue::V128([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]);
-        assert_eq!(simd_sum(dv, types::I8X16), 16);
-    }
-
-    #[test]
-    fn test_iterator_v64_empty() {
-        let dv = DataValue::V64([0, 0, 0, 0, 0, 0, 0, 0]);
-        assert_eq!(simd_sum(dv, types::I8X8), 0);
-    }
-    #[test]
-    fn test_iterator_v64_ones() {
-        let dv = DataValue::V64([1, 1, 1, 1, 1, 1, 1, 1]);
-        assert_eq!(simd_sum(dv, types::I8X8), 8);
-    }
-    #[test]
-    fn test_iterator_v64() {
-        let dv = DataValue::V64([10, 20, 30, 40, 50, 60, 70, 80]);
-        assert_eq!(simd_sum(dv, types::I8X8), 360);
-    }
-
-    fn simd_sum(dv: DataValue, ty: types::Type) -> i128 {
-        let itr = dv.iter_lanes(ty).unwrap();
-
-        itr.map(|e| {
-            if let Some(v) = e.into_int_signed().ok() {
-                v
-            } else {
-                0
-            }
-        })
-        .sum()
-    }
 }
diff --git a/cranelift/isle/isle/Cargo.toml b/cranelift/isle/isle/Cargo.toml
index dfd84f84d..3bedc884c 100644
--- a/cranelift/isle/isle/Cargo.toml
+++ b/cranelift/isle/isle/Cargo.toml
@@ -6,7 +6,7 @@ license = "Apache-2.0 WITH LLVM-exception"
 name = "cranelift-isle"
 readme = "../README.md"
 repository = "https://github.com/bytecodealliance/wasmtime/tree/main/cranelift/isle"
-version = "0.99.0"
+version = "0.98.0"
 
 [dependencies]
 codespan-reporting = { version = "0.11.1", optional = true }
diff --git a/cranelift/jit/Cargo.toml b/cranelift/jit/Cargo.toml
index 73905f908..88dcf7b2b 100644
--- a/cranelift/jit/Cargo.toml
+++ b/cranelift/jit/Cargo.toml
@@ -1,6 +1,6 @@
 [package]
 name = "cranelift-jit"
-version = "0.99.0"
+version = "0.98.0"
 authors = ["The Cranelift Project Developers"]
 description = "A JIT library backed by Cranelift"
 repository = "https://github.com/bytecodealliance/wasmtime"
diff --git a/cranelift/jit/src/backend.rs b/cranelift/jit/src/backend.rs
index b564b82b6..1bf34cc1f 100644
--- a/cranelift/jit/src/backend.rs
+++ b/cranelift/jit/src/backend.rs
@@ -434,7 +434,7 @@ impl JITModule {
         // are profiling with perf and saving binaries to PERF_BUILDID_DIR
         // for post-profile analysis, write information about each function
         // we define.
-        if cfg!(unix) && ::std::env::var_os("PERF_BUILDID_DIR").is_some() {
+        if cfg!(target_os = "linux") && ::std::env::var_os("PERF_BUILDID_DIR").is_some() {
             let mut map_file = ::std::fs::OpenOptions::new()
                 .create(true)
                 .append(true)
diff --git a/cranelift/module/Cargo.toml b/cranelift/module/Cargo.toml
index b5c850f3b..e571012b9 100644
--- a/cranelift/module/Cargo.toml
+++ b/cranelift/module/Cargo.toml
@@ -1,6 +1,6 @@
 [package]
 name = "cranelift-module"
-version = "0.99.0"
+version = "0.98.0"
 authors = ["The Cranelift Project Developers"]
 description = "Support for linking functions and data with Cranelift"
 repository = "https://github.com/bytecodealliance/wasmtime"
diff --git a/cranelift/native/Cargo.toml b/cranelift/native/Cargo.toml
index e37e998ee..69aa890a9 100644
--- a/cranelift/native/Cargo.toml
+++ b/cranelift/native/Cargo.toml
@@ -1,6 +1,6 @@
 [package]
 name = "cranelift-native"
-version = "0.99.0"
+version = "0.98.0"
 authors = ["The Cranelift Project Developers"]
 description = "Support for targeting the host with Cranelift"
 documentation = "https://docs.rs/cranelift-native"
diff --git a/cranelift/object/Cargo.toml b/cranelift/object/Cargo.toml
index c576f310e..d22a5156e 100644
--- a/cranelift/object/Cargo.toml
+++ b/cranelift/object/Cargo.toml
@@ -1,6 +1,6 @@
 [package]
 name = "cranelift-object"
-version = "0.99.0"
+version = "0.98.0"
 authors = ["The Cranelift Project Developers"]
 description = "Emit Cranelift output to native object files with `object`"
 repository = "https://github.com/bytecodealliance/wasmtime"
diff --git a/cranelift/reader/Cargo.toml b/cranelift/reader/Cargo.toml
index 3ec07ce9c..7d38a05ec 100644
--- a/cranelift/reader/Cargo.toml
+++ b/cranelift/reader/Cargo.toml
@@ -1,7 +1,7 @@
 [package]
 authors = ["The Cranelift Project Developers"]
 name = "cranelift-reader"
-version = "0.99.0"
+version = "0.98.0"
 description = "Cranelift textual IR reader"
 license = "Apache-2.0 WITH LLVM-exception"
 documentation = "https://docs.rs/cranelift-reader"
diff --git a/cranelift/serde/Cargo.toml b/cranelift/serde/Cargo.toml
index 2846623ec..a94f7762d 100644
--- a/cranelift/serde/Cargo.toml
+++ b/cranelift/serde/Cargo.toml
@@ -1,6 +1,6 @@
 [package]
 name = "cranelift-serde"
-version = "0.99.0"
+version = "0.98.0"
 authors = ["The Cranelift Project Developers"]
 description = "Serializer/Deserializer for Cranelift IR"
 repository = "https://github.com/bytecodealliance/wasmtime"
diff --git a/cranelift/umbrella/Cargo.toml b/cranelift/umbrella/Cargo.toml
index 2fdd8afde..793dfde8c 100644
--- a/cranelift/umbrella/Cargo.toml
+++ b/cranelift/umbrella/Cargo.toml
@@ -1,7 +1,7 @@
 [package]
 authors = ["The Cranelift Project Developers"]
 name = "cranelift"
-version = "0.99.0"
+version = "0.98.0"
 description = "Umbrella for commonly-used cranelift crates"
 license = "Apache-2.0 WITH LLVM-exception"
 documentation = "https://docs.rs/cranelift"
diff --git a/cranelift/wasm/Cargo.toml b/cranelift/wasm/Cargo.toml
index 4657744ab..c594584a7 100644
--- a/cranelift/wasm/Cargo.toml
+++ b/cranelift/wasm/Cargo.toml
@@ -1,6 +1,6 @@
 [package]
 name = "cranelift-wasm"
-version = "0.99.0"
+version = "0.98.0"
 authors = ["The Cranelift Project Developers"]
 description = "Translator from WebAssembly to Cranelift IR"
 documentation = "https://docs.rs/cranelift-wasm"
diff --git a/cranelift/wasm/src/code_translator.rs b/cranelift/wasm/src/code_translator.rs
index c1c928397..512e164de 100644
--- a/cranelift/wasm/src/code_translator.rs
+++ b/cranelift/wasm/src/code_translator.rs
@@ -89,7 +89,7 @@ use cranelift_codegen::ir::{
     self, AtomicRmwOp, ConstantData, InstBuilder, JumpTableData, MemFlags, Value, ValueLabel,
 };
 use cranelift_codegen::packed_option::ReservedValue;
-use cranelift_frontend::{FunctionBuilder, Variable};
+use cranelift_frontend::{FunctionBuilder, Switch, Variable};
 use itertools::Itertools;
 use smallvec::SmallVec;
 use std::convert::TryFrom;
@@ -2412,6 +2412,222 @@ pub fn translate_operator<FE: FuncEnvironment + ?Sized>(
         Operator::I31New | Operator::I31GetS | Operator::I31GetU => {
             unimplemented!("GC operators not yet implemented")
         }
+
+        Operator::ContNew { type_index } => {
+            let arg_types = environ.continuation_arguments(*type_index).to_vec();
+            let result_types = environ.continuation_returns(*type_index).to_vec();
+            let r = state.pop1();
+            let contobj =
+                environ.translate_cont_new(builder, state, r, &arg_types, &result_types)?;
+            let contref = environ.typed_continuations_new_cont_ref(builder, contobj);
+            state.push1(contref);
+        }
+        Operator::Resume {
+            type_index,
+            resumetable,
+        } => {
+            // Idea create wrapper block for handling suspends:
+            // (resume ...)
+            // (if returned_normally then return code else resumetable code)
+
+            // First we pop the arguments off the stack and bundle
+            // them up. The arguments are laid out on the stack as
+            // follows.
+            //
+            //  [ arg1 ... argN cont ]
+            let arity = environ.continuation_arguments(*type_index).len();
+            let (original_contref, call_args) = state.peekn(arity + 1).split_last().unwrap();
+            let original_contobj =
+                environ.typed_continuations_cont_ref_get_cont_obj(builder, *original_contref);
+            let call_arg_types = environ.continuation_arguments(*type_index).to_vec();
+
+            // Now, we generate the call instruction.
+            let (base_addr, signal, tag) = environ.translate_resume(
+                builder,
+                state,
+                original_contobj,
+                &call_arg_types,
+                call_args,
+            )?;
+            // Description of results:
+            // * The `base_addr` is the base address of VM context.
+            // * The `signal` is an encoded boolean indicating whether
+            // the `resume` returned ordinarily or via a suspend
+            // instruction.
+            // * The `tag` is the index of the control tag supplied to
+            // suspend (only valid if `signal` is 1).
+
+            // Pop the `resume_args` off the stack.
+            state.popn(arity + 1);
+
+            // Now, construct blocks for the three continuations:
+            // 1) `resume` returned normally.
+            // 2) `resume` returned via a suspend.
+            // 3) `resume` is forwarding (TODO)
+
+            // Test the signal bit.
+            let is_zero = builder.ins().icmp_imm(IntCC::Equal, signal, 0);
+            let return_block = crate::translation_utils::return_block(builder, environ)?;
+            let suspend_block = crate::translation_utils::suspend_block(builder, environ)?;
+            let switch_block = builder.create_block();
+            // Jump to the return block if the signal is 0, otherwise
+            // jump to the suspend block.
+            canonicalise_brif(builder, is_zero, return_block, &[], suspend_block, &[]);
+
+            // Next, build the suspend block.
+            let contref = {
+                builder.switch_to_block(suspend_block);
+                builder.seal_block(suspend_block);
+
+                // Load the continuation object
+                // TODO(frank-emrich) Is it actually the case that the suspended continuation MUST
+                // be the one we resumed here? In that case we wouldn't actually have to go via memory
+                // but could just re-use the cont object on the (WASM) stack in the beginning
+
+                // ANSWER(dhil): Yes, in general it will be a
+                // completely different object. If we had some static
+                // information to tell us that the previous
+                // continuation object wasn't ever invoked again, then
+                // we could reuse it. A different question is how to
+                // avoid allocation of the intermediary "continuation
+                // proxy objects", though, for that I reckon we need
+                // fat pointers.
+                let contobj =
+                    environ.typed_continuations_load_continuation_object(builder, base_addr);
+                let contref = environ.typed_continuations_new_cont_ref(builder, contobj);
+
+                // We need to terminate this block before being allowed to switch to another one
+                builder.ins().jump(switch_block, &[]);
+                contref
+            };
+
+            // Strategy:
+            //
+            // Translate each each (tag, label) pair in the resume table to a
+            // switch-case of the form "case tag: br label".
+            // The switching logic then ensures that we jump to the block
+            // handling the corresponding tag.
+            //
+            // The fallback/default case performs effect forwarding (TODO).
+            //
+            // First, initialise the switch structure.
+            let mut switch = Switch::new();
+            // Second, we consume the resume table entry-wise.
+            let mut case_blocks = vec![];
+            for (tag, label) in resumetable.targets().map(|x| x.unwrap()) {
+                let case = crate::translation_utils::resumetable_entry_block(builder, environ)?;
+                switch.set_entry(tag as u128, case);
+                builder.switch_to_block(case);
+
+                // Load and push arguments.
+                let param_types = environ.tag_params(tag).to_vec();
+                let params = environ.typed_continuations_load_payloads(builder, &param_types);
+
+                state.pushn(&params);
+                // Push the continuation reference.
+                state.push1(contref);
+                let count = params.len() + 1;
+                let (br_destination, inputs) = translate_br_if_args(label, state);
+
+                // Now jump to the actual user-defined block handling
+                // this tag, as given by the resumetable.
+                builder.ins().jump(br_destination, inputs);
+                state.popn(count);
+                case_blocks.push(case);
+            }
+
+            // Note that at this point we haven't actually emitted any
+            // code for the switching logic itself, but only filled
+            // the Switch structure and created the blocks it jumps
+            // to.
+
+            let forwarding_case =
+                crate::translation_utils::resumetable_forwarding_block(builder, environ)?;
+
+            // Switch block (where the actual switching logic is
+            // emitted to).
+            {
+                builder.switch_to_block(switch_block);
+                switch.emit(builder, tag, forwarding_case);
+                builder.seal_block(switch_block);
+                builder.switch_to_block(forwarding_case);
+                builder.seal_block(forwarding_case);
+                // TODO: emit effect forwarding logic.
+                builder.ins().trap(ir::TrapCode::UnreachableCodeReached);
+
+                // We can only seal the blocks we generated for each
+                // tag now, after switch.emit ran.
+                for case_block in case_blocks {
+                    builder.seal_block(case_block);
+                }
+            }
+
+            // Now, finish the return block.
+            {
+                builder.switch_to_block(return_block);
+                builder.seal_block(return_block);
+
+                // Load and push the results.
+                let returns = environ.continuation_returns(*type_index).to_vec();
+                let values = environ.typed_continuations_load_return_values(
+                    builder,
+                    &returns,
+                    original_contobj,
+                );
+
+                // The continuation has returned and all `ContinuationReferences`
+                // to it should have been be invalidated. We may safely deallocate
+                // it.
+                environ.typed_continuations_drop_cont_obj(builder, original_contobj);
+
+                state.pushn(&values);
+            }
+        }
+        Operator::Suspend { tag_index } => {
+            let param_types = environ.tag_params(*tag_index).to_vec();
+
+            let params = state.peekn(param_types.len());
+            let param_count = params.len();
+
+            environ.typed_continuations_store_payloads(builder, &param_types, params);
+            state.popn(param_count);
+
+            let vmctx = environ.translate_suspend(builder, state, *tag_index);
+
+            let contobj = environ.typed_continuations_load_continuation_object(builder, vmctx);
+
+            let return_types = environ.tag_returns(*tag_index).to_vec();
+            let return_values =
+                environ.typed_continuations_load_tag_return_values(builder, contobj, &return_types);
+
+            state.pushn(&return_values);
+        }
+        Operator::ContBind {
+            src_index,
+            dst_index,
+        } => {
+            let src_arity = environ.continuation_arguments(*src_index).len();
+            let dst_arity = environ.continuation_arguments(*dst_index).len();
+            let arg_count = src_arity - dst_arity;
+
+            let (original_contref, args) = state.peekn(arg_count + 1).split_last().unwrap();
+            let contobj =
+                environ.typed_continuations_cont_ref_get_cont_obj(builder, *original_contref);
+
+            let src_arity_value = builder.ins().iconst(I32, src_arity as i64);
+            environ.typed_continuations_store_resume_args(builder, args, src_arity_value, contobj);
+
+            let new_contref = environ.typed_continuations_new_cont_ref(builder, contobj);
+
+            state.popn(arg_count + 1);
+            state.push1(new_contref);
+        }
+        Operator::ResumeThrow {
+            type_index: _,
+            tag_index: _,
+            resumetable: _,
+        }
+        | Operator::Barrier { blockty: _, .. } => todo!("Implement continuation instructions"),
     };
     Ok(())
 }
diff --git a/cranelift/wasm/src/environ/dummy.rs b/cranelift/wasm/src/environ/dummy.rs
index 5da3fe76d..4650b44ca 100644
--- a/cranelift/wasm/src/environ/dummy.rs
+++ b/cranelift/wasm/src/environ/dummy.rs
@@ -672,6 +672,141 @@ impl<'dummy_environment> FuncEnvironment for DummyFuncEnvironment<'dummy_environ
     ) -> WasmResult<ir::Value> {
         Ok(pos.ins().iconst(I32, 0))
     }
+
+    fn translate_cont_new(
+        &mut self,
+        _builder: &mut FunctionBuilder,
+        _state: &FuncTranslationState,
+        _func: ir::Value,
+        _arg_types: &[wasmtime_types::WasmType],
+        _return_types: &[wasmtime_types::WasmType],
+    ) -> WasmResult<ir::Value> {
+        todo!()
+    }
+
+    fn translate_resume(
+        &mut self,
+        _builder: &mut FunctionBuilder,
+        _state: &FuncTranslationState,
+        _cont: ir::Value,
+        _call_arg_types: &[WasmType],
+        _call_args: &[ir::Value],
+    ) -> WasmResult<(ir::Value, ir::Value, ir::Value)> {
+        todo!()
+    }
+
+    fn translate_resume_throw(
+        &mut self,
+        _pos: FuncCursor,
+        _state: &FuncTranslationState,
+        _tag_index: u32,
+        _cont: ir::Value,
+    ) -> WasmResult<ir::Value> {
+        todo!()
+    }
+
+    fn translate_suspend(
+        &mut self,
+        _builder: &mut FunctionBuilder,
+        _state: &FuncTranslationState,
+        _tag_index: u32,
+    ) -> ir::Value {
+        todo!()
+    }
+
+    fn continuation_arguments(&self, _type_index: u32) -> &[wasmtime_types::WasmType] {
+        todo!()
+    }
+
+    fn continuation_returns(&self, _type_index: u32) -> &[WasmType] {
+        todo!()
+    }
+
+    fn tag_params(&self, _tag_index: u32) -> &[WasmType] {
+        todo!()
+    }
+
+    fn tag_returns(&self, _tag_index: u32) -> &[WasmType] {
+        todo!()
+    }
+
+    fn typed_continuations_load_payloads(
+        &mut self,
+        _builder: &mut FunctionBuilder,
+        _valtypes: &[WasmType],
+    ) -> Vec<ir::Value> {
+        todo!()
+    }
+
+    fn typed_continuations_load_tag_return_values(
+        &mut self,
+        _builder: &mut FunctionBuilder,
+        _contobj: ir::Value,
+        _valtypes: &[WasmType],
+    ) -> Vec<ir::Value> {
+        todo!()
+    }
+
+    fn typed_continuations_store_resume_args(
+        &mut self,
+        _builder: &mut FunctionBuilder,
+        _values: &[ir::Value],
+        _remaining_arg_count: ir::Value,
+        _contref: ir::Value,
+    ) {
+        todo!()
+    }
+
+    fn typed_continuations_store_payloads(
+        &mut self,
+        _builder: &mut FunctionBuilder,
+        _valtypes: &[WasmType],
+        _values: &[ir::Value],
+    ) {
+        todo!()
+    }
+
+    fn typed_continuations_load_continuation_object(
+        &self,
+        _builder: &mut FunctionBuilder,
+        _base_addr: ir::Value,
+    ) -> ir::Value {
+        todo!()
+    }
+
+    fn typed_continuations_new_cont_ref(
+        &mut self,
+        _builder: &mut FunctionBuilder,
+        _contobj_addr: ir::Value,
+    ) -> ir::Value {
+        todo!()
+    }
+
+    fn typed_continuations_load_return_values(
+        &mut self,
+        _builder: &mut FunctionBuilder,
+        _valtypes: &[WasmType],
+        _contobj: ir::Value,
+    ) -> std::vec::Vec<ir::Value> {
+        unimplemented!()
+    }
+
+    fn typed_continuations_cont_ref_get_cont_obj(
+        &mut self,
+        _builder: &mut FunctionBuilder,
+        _contref: ir::Value,
+    ) -> ir::Value {
+        unimplemented!()
+    }
+
+    /// TODO
+    fn typed_continuations_drop_cont_obj(
+        &mut self,
+        _builder: &mut FunctionBuilder,
+        _contobj: ir::Value,
+    ) {
+        unimplemented!()
+    }
 }
 
 impl TypeConvert for DummyEnvironment {
diff --git a/cranelift/wasm/src/environ/spec.rs b/cranelift/wasm/src/environ/spec.rs
index d20491abc..00402a0b0 100644
--- a/cranelift/wasm/src/environ/spec.rs
+++ b/cranelift/wasm/src/environ/spec.rs
@@ -563,6 +563,127 @@ pub trait FuncEnvironment: TargetEnvironment {
         false
     }
 
+    /// TODO(dhil): write documentation.
+    fn translate_cont_new(
+        &mut self,
+        builder: &mut FunctionBuilder,
+        state: &FuncTranslationState,
+        func: ir::Value,
+        arg_types: &[wasmtime_types::WasmType],
+        return_types: &[wasmtime_types::WasmType],
+    ) -> WasmResult<ir::Value>;
+
+    /// Translates a resume instruction and returns a triple (vmctx,
+    /// signal, tag), where vmctx is the base address of the VM
+    /// context, signal is high bit of the resume result, and tag is
+    /// the index of the control tag supplied to suspend (if the
+    /// signal is 1).
+    fn translate_resume(
+        &mut self,
+        builder: &mut FunctionBuilder,
+        state: &FuncTranslationState,
+        cont: ir::Value,
+        call_arg_types: &[wasmtime_types::WasmType],
+        call_args: &[ir::Value],
+    ) -> WasmResult<(ir::Value, ir::Value, ir::Value)>;
+
+    /// TODO(dhil): write documentation.
+    fn translate_resume_throw(
+        &mut self,
+        pos: FuncCursor,
+        state: &FuncTranslationState,
+        tag_index: u32,
+        cont: ir::Value,
+    ) -> WasmResult<ir::Value>;
+
+    /// TODO(dhil): write documentation.
+    fn translate_suspend(
+        &mut self,
+        builder: &mut FunctionBuilder,
+        state: &FuncTranslationState,
+        tag_index: u32,
+    ) -> ir::Value;
+
+    /// TODO
+    fn continuation_arguments(&self, type_index: u32) -> &[wasmtime_types::WasmType];
+
+    /// TODO
+    fn continuation_returns(&self, type_index: u32) -> &[wasmtime_types::WasmType];
+
+    /// TODO
+    fn typed_continuations_load_return_values(
+        &mut self,
+        builder: &mut FunctionBuilder,
+        valtypes: &[wasmtime_types::WasmType],
+        contobj: ir::Value,
+    ) -> std::vec::Vec<ir::Value>;
+
+    /// TODO
+    fn typed_continuations_load_payloads(
+        &mut self,
+        builder: &mut FunctionBuilder,
+        valtypes: &[wasmtime_types::WasmType],
+    ) -> std::vec::Vec<ir::Value>;
+
+    /// TODO
+    fn typed_continuations_load_tag_return_values(
+        &mut self,
+        builder: &mut FunctionBuilder,
+        contobj: ir::Value,
+        valtypes: &[wasmtime_types::WasmType],
+    ) -> std::vec::Vec<ir::Value>;
+
+    /// TODO
+    fn typed_continuations_store_payloads(
+        &mut self,
+        builder: &mut FunctionBuilder,
+        valtypes: &[wasmtime_types::WasmType],
+        values: &[ir::Value],
+    );
+
+    /// TODO
+    fn typed_continuations_store_resume_args(
+        &mut self,
+        builder: &mut FunctionBuilder,
+        values: &[ir::Value],
+        remaining_arg_count: ir::Value,
+        contobj: ir::Value,
+    );
+
+    /// TODO
+    fn typed_continuations_drop_cont_obj(
+        &mut self,
+        builder: &mut FunctionBuilder,
+        contobj: ir::Value,
+    );
+
+    /// TODO
+    fn tag_params(&self, tag_index: u32) -> &[wasmtime_types::WasmType];
+
+    /// TODO
+    fn tag_returns(&self, tag_index: u32) -> &[wasmtime_types::WasmType];
+
+    /// TODO
+    fn typed_continuations_load_continuation_object(
+        &self,
+        builder: &mut FunctionBuilder,
+        base_addr: ir::Value,
+    ) -> ir::Value;
+
+    /// TODO
+    fn typed_continuations_new_cont_ref(
+        &mut self,
+        builder: &mut FunctionBuilder,
+        contobj_addr: ir::Value,
+    ) -> ir::Value;
+
+    /// TODO
+    fn typed_continuations_cont_ref_get_cont_obj(
+        &mut self,
+        builder: &mut FunctionBuilder,
+        contref: ir::Value,
+    ) -> ir::Value;
+
     /// Returns whether the CLIF `x86_blendv` instruction should be used for the
     /// relaxed simd `*.relaxed_laneselect` instruction for the specified type.
     fn use_x86_blendv_for_relaxed_laneselect(&self, ty: Type) -> bool {
diff --git a/cranelift/wasm/src/sections_translator.rs b/cranelift/wasm/src/sections_translator.rs
index e6aff9706..3aa3a9328 100644
--- a/cranelift/wasm/src/sections_translator.rs
+++ b/cranelift/wasm/src/sections_translator.rs
@@ -21,7 +21,7 @@ use wasmparser::{
     self, Data, DataKind, DataSectionReader, Element, ElementItems, ElementKind,
     ElementSectionReader, Export, ExportSectionReader, ExternalKind, FunctionSectionReader,
     GlobalSectionReader, ImportSectionReader, MemorySectionReader, MemoryType, NameSectionReader,
-    Naming, Operator, StructuralType, TableSectionReader, TagSectionReader, TagType, TypeRef,
+    Naming, Operator, TableSectionReader, TagSectionReader, TagType, Type, TypeRef,
     TypeSectionReader,
 };
 
@@ -51,18 +51,16 @@ pub fn parse_type_section<'a>(
     environ.reserve_types(count)?;
 
     for entry in types {
-        let entry = entry?;
-        if entry.is_final || entry.supertype_idx.is_some() {
-            unimplemented!("gc proposal");
-        }
-        match entry.structural_type {
-            StructuralType::Func(wasm_func_ty) => {
+        match entry? {
+            Type::Func(wasm_func_ty) => {
                 let ty = environ.convert_func_type(&wasm_func_ty);
                 environ.declare_type_func(ty)?;
             }
-            StructuralType::Array(_) | StructuralType::Struct(_) => {
+            Type::Array(_) => {
                 unimplemented!("gc proposal");
             }
+            Type::Cont(_) => unimplemented!(), // Note(dhil): there is no support for declaring bare
+                                               // continuation types.
         }
     }
     Ok(())
diff --git a/cranelift/wasm/src/translation_utils.rs b/cranelift/wasm/src/translation_utils.rs
index 7d2208881..99d72a4cf 100644
--- a/cranelift/wasm/src/translation_utils.rs
+++ b/cranelift/wasm/src/translation_utils.rs
@@ -7,6 +7,7 @@ use cranelift_frontend::FunctionBuilder;
 #[cfg(feature = "enable-serde")]
 use serde::{Deserialize, Serialize};
 use wasmparser::{FuncValidator, WasmFuncType, WasmModuleResources};
+use wasmtime_types::WasmType;
 
 /// Get the parameter and result types for the given Wasm blocktype.
 pub fn blocktype_params_results<'a, T>(
@@ -97,3 +98,87 @@ pub fn get_vmctx_value_label() -> ir::ValueLabel {
     const VMCTX_LABEL: u32 = 0xffff_fffe;
     ir::ValueLabel::from_u32(VMCTX_LABEL)
 }
+
+/// Create a `Block` with the given Wasm parameters.
+pub fn block_with_params_wasmtype<PE: TargetEnvironment + ?Sized>(
+    builder: &mut FunctionBuilder,
+    params: &[WasmType],
+    environ: &PE,
+) -> WasmResult<ir::Block> {
+    let block = builder.create_block();
+    for ty in params {
+        match ty {
+            WasmType::I32 => {
+                builder.append_block_param(block, ir::types::I32);
+            }
+            WasmType::I64 => {
+                builder.append_block_param(block, ir::types::I64);
+            }
+            WasmType::F32 => {
+                builder.append_block_param(block, ir::types::F32);
+            }
+            WasmType::F64 => {
+                builder.append_block_param(block, ir::types::F64);
+            }
+            WasmType::Ref(rt) => {
+                builder.append_block_param(block, environ.reference_type(rt.heap_type));
+            }
+            WasmType::V128 => {
+                builder.append_block_param(block, ir::types::I8X16);
+            }
+        }
+    }
+    Ok(block)
+}
+
+/// Create a synthetic suspend block (used to wrap a resume table).
+pub fn suspend_block<PE: TargetEnvironment + ?Sized>(
+    builder: &mut FunctionBuilder,
+    _environ: &PE,
+) -> WasmResult<ir::Block> {
+    let block = builder.create_block();
+    Ok(block)
+}
+
+/// Create a synthetic resume table entry block.
+pub fn resumetable_entry_block<PE: TargetEnvironment + ?Sized>(
+    builder: &mut FunctionBuilder,
+    _environ: &PE,
+) -> WasmResult<ir::Block> {
+    let block = builder.create_block();
+    Ok(block)
+}
+
+/// Create a synthetic resume table forwarding block.
+pub fn resumetable_forwarding_block<PE: TargetEnvironment + ?Sized>(
+    builder: &mut FunctionBuilder,
+    _environ: &PE,
+) -> WasmResult<ir::Block> {
+    let block = builder.create_block();
+
+    Ok(block)
+}
+
+/// Create a synthetic return block (used to wrap the return
+/// continuation of resume).
+pub fn return_block<PE: TargetEnvironment + ?Sized>(
+    builder: &mut FunctionBuilder,
+    _environ: &PE,
+) -> WasmResult<ir::Block> {
+    let block = builder.create_block();
+
+    Ok(block)
+}
+
+/// Compute the maximum number of arguments that a suspension may
+/// supply.
+pub fn resumetable_max_num_tag_payloads<PE: crate::FuncEnvironment + ?Sized>(
+    tags: &[u32],
+    environ: &PE,
+) -> WasmResult<usize> {
+    Ok(tags
+        .iter()
+        .map(|tag| environ.tag_params(*tag).len())
+        .max()
+        .unwrap())
+}
diff --git a/crates/c-api/include/wasmtime.h b/crates/c-api/include/wasmtime.h
index cd7cc353c..41096cb67 100644
--- a/crates/c-api/include/wasmtime.h
+++ b/crates/c-api/include/wasmtime.h
@@ -199,11 +199,11 @@
 /**
  * \brief Wasmtime version string.
  */
-#define WASMTIME_VERSION "12.0.0"
+#define WASMTIME_VERSION "11.0.0"
 /**
  * \brief Wasmtime major version number.
  */
-#define WASMTIME_VERSION_MAJOR 12
+#define WASMTIME_VERSION_MAJOR 11
 /**
  * \brief Wasmtime minor version number.
  */
diff --git a/crates/cli-flags/src/lib.rs b/crates/cli-flags/src/lib.rs
index ba568f0d5..d04c232d7 100644
--- a/crates/cli-flags/src/lib.rs
+++ b/crates/cli-flags/src/lib.rs
@@ -47,6 +47,11 @@ pub const SUPPORTED_WASM_FEATURES: &[(&str, &str)] = &[
         "function-references",
         "enables support for typed function references",
     ),
+    ("exceptions", "enables support for exceptions"),
+    (
+        "typed-continuations",
+        "enables support for typed continuations",
+    ),
 ];
 
 pub const SUPPORTED_WASI_MODULES: &[(&str, &str)] = &[
@@ -371,6 +376,8 @@ impl CommonOptions {
             #[cfg(feature = "component-model")]
             component_model,
             function_references,
+            exceptions,
+            typed_continuations,
         } = self.wasm_features.unwrap_or_default();
 
         if let Some(enable) = simd {
@@ -404,6 +411,12 @@ impl CommonOptions {
         if let Some(enable) = component_model {
             config.wasm_component_model(enable);
         }
+        if let Some(enable) = exceptions {
+            config.wasm_exceptions(enable);
+        }
+        if let Some(enable) = typed_continuations {
+            config.wasm_typed_continuations(enable);
+        }
     }
 
     pub fn opt_level(&self) -> wasmtime::OptLevel {
@@ -441,6 +454,8 @@ pub struct WasmFeatures {
     #[cfg(feature = "component-model")]
     pub component_model: Option<bool>,
     pub function_references: Option<bool>,
+    pub exceptions: Option<bool>,
+    pub typed_continuations: Option<bool>,
 }
 
 fn parse_wasm_features(features: &str) -> Result<WasmFeatures> {
@@ -493,6 +508,8 @@ fn parse_wasm_features(features: &str) -> Result<WasmFeatures> {
         #[cfg(feature = "component-model")]
         component_model: all.or(values["component-model"]),
         function_references: all.or(values["function-references"]),
+        exceptions: all.or(values["exceptions"]),
+        typed_continuations: all.or(values["typed-continuations"]),
     })
 }
 
@@ -609,6 +626,8 @@ mod test {
             multi_memory,
             memory64,
             function_references,
+            exceptions: _,
+            typed_continuations,
         } = options.wasm_features.unwrap();
 
         assert_eq!(reference_types, Some(true));
@@ -620,6 +639,7 @@ mod test {
         assert_eq!(memory64, Some(true));
         assert_eq!(function_references, Some(true));
         assert_eq!(relaxed_simd, Some(true));
+        assert_eq!(typed_continuations, Some(true));
 
         Ok(())
     }
@@ -638,6 +658,8 @@ mod test {
             multi_memory,
             memory64,
             function_references,
+            exceptions,
+            typed_continuations,
         } = options.wasm_features.unwrap();
 
         assert_eq!(reference_types, Some(false));
@@ -649,6 +671,8 @@ mod test {
         assert_eq!(memory64, Some(false));
         assert_eq!(function_references, Some(false));
         assert_eq!(relaxed_simd, Some(false));
+        assert_eq!(exceptions, Some(false));
+        assert_eq!(typed_continuations, Some(false));
 
         Ok(())
     }
@@ -670,6 +694,8 @@ mod test {
             multi_memory,
             memory64,
             function_references,
+            exceptions,
+            typed_continuations,
         } = options.wasm_features.unwrap();
 
         assert_eq!(reference_types, Some(false));
@@ -681,6 +707,8 @@ mod test {
         assert_eq!(memory64, Some(true));
         assert_eq!(function_references, None);
         assert_eq!(relaxed_simd, None);
+        assert_eq!(exceptions, None);
+        assert_eq!(typed_continuations, None);
 
         Ok(())
     }
diff --git a/crates/cranelift/Cargo.toml b/crates/cranelift/Cargo.toml
index 1de960f2f..a9eb6f6cd 100644
--- a/crates/cranelift/Cargo.toml
+++ b/crates/cranelift/Cargo.toml
@@ -26,9 +26,9 @@ target-lexicon = { workspace = true }
 gimli = { workspace = true }
 object = { workspace = true, features = ['write'] }
 thiserror = { workspace = true }
-wasmtime-versioned-export-macros = { workspace = true }
 
 [features]
 all-arch = ["cranelift-codegen/all-arch"]
 component-model = ["wasmtime-environ/component-model"]
 incremental-cache = ["cranelift-codegen/incremental-cache"]
+unsafe_disable_continuation_linearity_check = []
\ No newline at end of file
diff --git a/crates/cranelift/src/compiler/component.rs b/crates/cranelift/src/compiler/component.rs
index 75b7a249f..22a2c3d24 100644
--- a/crates/cranelift/src/compiler/component.rs
+++ b/crates/cranelift/src/compiler/component.rs
@@ -525,6 +525,7 @@ impl Compiler {
 ///
 /// Note that a macro is used here to keep this in sync with the actual
 /// transcoder functions themselves which are also defined via a macro.
+#[allow(unused_mut)]
 mod host {
     use crate::compiler::Compiler;
     use cranelift_codegen::ir::{self, AbiParam};
@@ -540,12 +541,11 @@ mod host {
             $(
                 pub(super) fn $name(compiler: &Compiler, func: &mut ir::Function) -> (ir::SigRef, u32) {
                     let pointer_type = compiler.isa.pointer_type();
-                    let params = vec![
+                    let mut params = vec![
                         $( AbiParam::new(host_transcode!(@ty pointer_type $param)) ),*
                     ];
-                    let returns = vec![
-                        $( AbiParam::new(host_transcode!(@ty pointer_type $result)) )?
-                    ];
+                    let mut returns = Vec::new();
+                    $(host_transcode!(@push_return pointer_type params returns $result);)?
                     let sig = func.import_signature(ir::Signature {
                         params,
                         returns,
@@ -560,7 +560,12 @@ mod host {
         (@ty $ptr:ident size) => ($ptr);
         (@ty $ptr:ident ptr_u8) => ($ptr);
         (@ty $ptr:ident ptr_u16) => ($ptr);
-        (@ty $ptr:ident ptr_size) => ($ptr);
+
+        (@push_return $ptr:ident $params:ident $returns:ident size) => ($returns.push(AbiParam::new($ptr)););
+        (@push_return $ptr:ident $params:ident $returns:ident size_pair) => ({
+            $params.push(AbiParam::new($ptr));
+            $returns.push(AbiParam::new($ptr));
+        });
     }
 
     wasmtime_environ::foreach_transcoder!(host_transcode);
diff --git a/crates/cranelift/src/debug/transform/unit.rs b/crates/cranelift/src/debug/transform/unit.rs
index eefed56d0..1b220097c 100644
--- a/crates/cranelift/src/debug/transform/unit.rs
+++ b/crates/cranelift/src/debug/transform/unit.rs
@@ -15,7 +15,6 @@ use gimli::write;
 use gimli::{AttributeValue, DebuggingInformationEntry, Unit};
 use std::collections::HashSet;
 use wasmtime_environ::DefinedFuncIndex;
-use wasmtime_versioned_export_macros::versioned_stringify_ident;
 
 struct InheritedAttr<T> {
     stack: Vec<(usize, T)>,
@@ -199,7 +198,7 @@ where
     //  ..  .. DW_AT_type = <wrapper_ptr_type>
     //  ..  .. DW_AT_artificial = 1
     add_tag!(wrapper_die_id, gimli::DW_TAG_subprogram => deref_op_die as deref_op_die_id {
-        gimli::DW_AT_linkage_name = write::AttributeValue::StringRef(out_strings.add(versioned_stringify_ident!(resolve_vmctx_memory_ptr))),
+        gimli::DW_AT_linkage_name = write::AttributeValue::StringRef(out_strings.add("resolve_vmctx_memory_ptr")),
         gimli::DW_AT_name = write::AttributeValue::StringRef(out_strings.add("ptr")),
         gimli::DW_AT_type = write::AttributeValue::UnitRef(ptr_type_id)
     });
@@ -216,7 +215,7 @@ where
     //  ..  .. DW_AT_type = <wrapper_ptr_type>
     //  ..  .. DW_AT_artificial = 1
     add_tag!(wrapper_die_id, gimli::DW_TAG_subprogram => deref_op_die as deref_op_die_id {
-        gimli::DW_AT_linkage_name = write::AttributeValue::StringRef(out_strings.add(versioned_stringify_ident!(resolve_vmctx_memory_ptr))),
+        gimli::DW_AT_linkage_name = write::AttributeValue::StringRef(out_strings.add("resolve_vmctx_memory_ptr")),
         gimli::DW_AT_name = write::AttributeValue::StringRef(out_strings.add("operator*")),
         gimli::DW_AT_type = write::AttributeValue::UnitRef(ref_type_id)
     });
@@ -233,7 +232,7 @@ where
     //  ..  .. DW_AT_type = <wrapper_ptr_type>
     //  ..  .. DW_AT_artificial = 1
     add_tag!(wrapper_die_id, gimli::DW_TAG_subprogram => deref_op_die as deref_op_die_id {
-        gimli::DW_AT_linkage_name = write::AttributeValue::StringRef(out_strings.add(versioned_stringify_ident!(resolve_vmctx_memory_ptr))),
+        gimli::DW_AT_linkage_name = write::AttributeValue::StringRef(out_strings.add("resolve_vmctx_memory_ptr")),
         gimli::DW_AT_name = write::AttributeValue::StringRef(out_strings.add("operator->")),
         gimli::DW_AT_type = write::AttributeValue::UnitRef(ptr_type_id)
     });
diff --git a/crates/cranelift/src/debug/transform/utils.rs b/crates/cranelift/src/debug/transform/utils.rs
index 0ffd19062..161612812 100644
--- a/crates/cranelift/src/debug/transform/utils.rs
+++ b/crates/cranelift/src/debug/transform/utils.rs
@@ -6,8 +6,8 @@ use anyhow::Error;
 use cranelift_codegen::isa::TargetIsa;
 use gimli::write;
 use wasmtime_environ::DefinedFuncIndex;
-use wasmtime_versioned_export_macros::versioned_stringify_ident;
-///Adds internal Wasm utility types DIEs such as WebAssemblyPtr and
+
+/// Adds internal Wasm utility types DIEs such as WebAssemblyPtr and
 /// WasmtimeVMContext.
 ///
 /// For unwrapping Wasm pointer, the WasmtimeVMContext has the `set()` method
@@ -113,7 +113,7 @@ pub(crate) fn add_internal_types(
     //  ..  .. DW_AT_type = <vmctx_ptr_die>
     //  ..  .. DW_AT_artificial = 1
     add_tag!(vmctx_die_id, gimli::DW_TAG_subprogram => vmctx_set as vmctx_set_id {
-        gimli::DW_AT_linkage_name = write::AttributeValue::StringRef(out_strings.add(versioned_stringify_ident!(set_vmctx_memory))),
+        gimli::DW_AT_linkage_name = write::AttributeValue::StringRef(out_strings.add("set_vmctx_memory")),
         gimli::DW_AT_name = write::AttributeValue::StringRef(out_strings.add("set"))
     });
     add_tag!(vmctx_set_id, gimli::DW_TAG_formal_parameter => vmctx_set_this_param as vmctx_set_this_param_id {
diff --git a/crates/cranelift/src/func_environ.rs b/crates/cranelift/src/func_environ.rs
index 9b182c1a7..825878301 100644
--- a/crates/cranelift/src/func_environ.rs
+++ b/crates/cranelift/src/func_environ.rs
@@ -10,9 +10,10 @@ use cranelift_frontend::FunctionBuilder;
 use cranelift_frontend::Variable;
 use cranelift_wasm::{
     self, FuncIndex, FuncTranslationState, GlobalIndex, GlobalVariable, Heap, HeapData, HeapStyle,
-    MemoryIndex, TableIndex, TargetEnvironment, TypeIndex, WasmHeapType, WasmRefType, WasmResult,
-    WasmType,
+    MemoryIndex, TableIndex, TagIndex, TargetEnvironment, TypeIndex, WasmHeapType, WasmRefType,
+    WasmResult, WasmType,
 };
+
 use std::convert::TryFrom;
 use std::mem;
 use wasmparser::Operator;
@@ -858,6 +859,59 @@ impl<'module_environment> FuncEnvironment<'module_environment> {
         builder.switch_to_block(continuation_block);
         result_param
     }
+
+    fn generate_builtin_call(
+        &mut self,
+        builder: &mut FunctionBuilder,
+        index: BuiltinFunctionIndex,
+        sig: ir::SigRef,
+        args: Vec<ir::Value>,
+    ) -> (ir::Value, ir::Value) {
+        let mut args = args;
+        let (vmctx, addr) =
+            self.translate_load_builtin_function_address(&mut builder.cursor(), index);
+        args.insert(0, vmctx);
+        let call_inst = builder.ins().call_indirect(sig, addr, &args);
+        let result_value = builder.func.dfg.first_result(call_inst);
+        return (vmctx, result_value);
+    }
+
+    fn generate_builtin_call_no_return_val(
+        &mut self,
+        builder: &mut FunctionBuilder,
+        index: BuiltinFunctionIndex,
+        sig: ir::SigRef,
+        args: Vec<ir::Value>,
+    ) -> ir::Value {
+        let mut args = args;
+        let (vmctx, addr) =
+            self.translate_load_builtin_function_address(&mut builder.cursor(), index);
+        args.insert(0, vmctx);
+        builder.ins().call_indirect(sig, addr, &args);
+        return vmctx;
+    }
+}
+
+macro_rules! generate_builtin_call {
+    ($self : ident, $builder: ident, $builtin_name: ident, $args: expr) => {{
+        let index = BuiltinFunctionIndex::$builtin_name();
+        let sig = $self
+            .builtin_function_signatures
+            .$builtin_name(&mut $builder.func);
+        let args = $args.to_vec();
+        $self.generate_builtin_call($builder, index, sig, args)
+    }};
+}
+
+macro_rules! generate_builtin_call_no_return_val {
+    ($self : ident, $builder: ident, $builtin_name: ident, $args: expr) => {{
+        let index = BuiltinFunctionIndex::$builtin_name();
+        let sig = $self
+            .builtin_function_signatures
+            .$builtin_name(&mut $builder.func);
+        let args = $args.to_vec();
+        $self.generate_builtin_call_no_return_val($builder, index, sig, args)
+    }};
 }
 
 impl TypeConvert for FuncEnvironment<'_> {
@@ -2200,6 +2254,348 @@ impl<'module_environment> cranelift_wasm::FuncEnvironment for FuncEnvironment<'m
         self.isa.triple().architecture == target_lexicon::Architecture::X86_64
     }
 
+    fn translate_cont_new(
+        &mut self,
+        builder: &mut FunctionBuilder,
+        _state: &FuncTranslationState,
+        func: ir::Value,
+        arg_types: &[WasmType],
+        return_types: &[WasmType],
+    ) -> WasmResult<ir::Value> {
+        let nargs = builder.ins().iconst(I64, arg_types.len() as i64);
+        let nreturns = builder.ins().iconst(I64, return_types.len() as i64);
+
+        let (_vmctx, contobj) =
+            generate_builtin_call!(self, builder, cont_new, [func, nargs, nreturns]);
+
+        Ok(contobj)
+    }
+
+    // TODO(dhil): Currently, this function invokes
+    // `translate_load_builtin_function_address` multiple times, which
+    // causes repeated allocation of values pointing to the vmctx. We
+    // should refactor or inline this logic at some point.
+    fn translate_resume(
+        &mut self,
+        builder: &mut FunctionBuilder,
+        _state: &FuncTranslationState,
+        contobj: ir::Value,
+        _call_arg_types: &[WasmType],
+        call_args: &[ir::Value],
+    ) -> WasmResult<(ir::Value, ir::Value, ir::Value)> {
+        // Strategy:
+        //
+        //
+        // First, store the remainder of `call_args` in the
+        // designated typed continuation store in the VM context.
+        //
+        // Second: Call the `resume` builtin
+
+        if call_args.len() > 0 {
+            let count = builder.ins().iconst(I32, call_args.len() as i64);
+            self.typed_continuations_store_resume_args(builder, call_args, count, contobj);
+        }
+
+        let (vmctx, result) = generate_builtin_call!(self, builder, resume, [contobj]);
+
+        // The result encodes whether the return happens via ordinary
+        // means or via a suspend. If the high bit is set, then it is
+        // interpreted as the return happened via a suspend, and the
+        // remainder of the integer is to be interpreted as the index
+        // of the control tag that was supplied to the suspend.
+        let signal_mask = 0xf000_0000;
+        let inverse_signal_mask = 0x0fff_ffff;
+        let signal = builder.ins().band_imm(result, signal_mask);
+        let real_result = builder.ins().band_imm(result, inverse_signal_mask);
+
+        // We return a pointer to the base of the VM context, as the
+        // subsequent codegen needs to project from it. Along with it,
+        // we also return the return signal and the tag.
+        Ok((vmctx, signal, real_result))
+    }
+
+    fn translate_resume_throw(
+        &mut self,
+        _pos: FuncCursor,
+        _state: &FuncTranslationState,
+        _tag_index: u32,
+        _cont: ir::Value,
+    ) -> WasmResult<ir::Value> {
+        todo!()
+    }
+
+    fn translate_suspend(
+        &mut self,
+        builder: &mut FunctionBuilder,
+        _state: &FuncTranslationState,
+        tag_index: u32,
+    ) -> ir::Value {
+        let tag_index = builder.ins().iconst(I32, tag_index as i64);
+
+        // Returns the vmctx
+        return generate_builtin_call_no_return_val!(self, builder, suspend, [tag_index]);
+    }
+
+    fn continuation_arguments(&self, index: u32) -> &[WasmType] {
+        let idx = self.module.types[TypeIndex::from_u32(index)].unwrap_continuation();
+        self.types[idx].params()
+    }
+
+    fn continuation_returns(&self, index: u32) -> &[WasmType] {
+        let idx = self.module.types[TypeIndex::from_u32(index)].unwrap_continuation();
+        self.types[idx].returns()
+    }
+
+    fn tag_params(&self, tag_index: u32) -> &[WasmType] {
+        let idx = self.module.tags[TagIndex::from_u32(tag_index)].signature;
+        self.types[idx].params()
+    }
+
+    fn tag_returns(&self, tag_index: u32) -> &[WasmType] {
+        let idx = self.module.tags[TagIndex::from_u32(tag_index)].signature;
+        self.types[idx].returns()
+    }
+
+    fn typed_continuations_load_payloads(
+        &mut self,
+        builder: &mut FunctionBuilder,
+        valtypes: &[WasmType],
+    ) -> Vec<ir::Value> {
+        let memflags = ir::MemFlags::trusted();
+        let mut values = vec![];
+
+        if valtypes.len() > 0 {
+            let nargs = builder.ins().iconst(I32, valtypes.len() as i64);
+
+            let (_vmctx, payload_ptr) =
+                generate_builtin_call!(self, builder, get_payload_buffer, [nargs]);
+
+            let mut offset = 0;
+            for valtype in valtypes {
+                let val = builder.ins().load(
+                    super::value_type(self.isa, *valtype),
+                    memflags,
+                    payload_ptr,
+                    offset,
+                );
+                values.push(val);
+                offset += self.offsets.ptr.maximum_value_size() as i32;
+            }
+
+            generate_builtin_call_no_return_val!(self, builder, deallocate_payload_buffer, [nargs]);
+        }
+        values
+    }
+
+    fn typed_continuations_load_tag_return_values(
+        &mut self,
+        builder: &mut FunctionBuilder,
+        contobj: ir::Value,
+        valtypes: &[WasmType],
+    ) -> Vec<ir::Value> {
+        let memflags = ir::MemFlags::trusted();
+        let mut values = vec![];
+
+        if valtypes.len() > 0 {
+            let nargs = builder.ins().iconst(I32, valtypes.len() as i64);
+
+            let (_vmctx, payload_ptr) = generate_builtin_call!(
+                self,
+                builder,
+                cont_obj_get_tag_return_values_buffer,
+                [contobj, nargs]
+            );
+
+            let mut offset = 0;
+            for valtype in valtypes {
+                let val = builder.ins().load(
+                    super::value_type(self.isa, *valtype),
+                    memflags,
+                    payload_ptr,
+                    offset,
+                );
+                values.push(val);
+                offset += self.offsets.ptr.maximum_value_size() as i32;
+            }
+
+            generate_builtin_call_no_return_val!(
+                self,
+                builder,
+                cont_obj_deallocate_tag_return_values_buffer,
+                [contobj]
+            );
+        }
+        values
+    }
+
+    /// TODO
+    fn typed_continuations_cont_ref_get_cont_obj(
+        &mut self,
+        builder: &mut FunctionBuilder,
+        contref: ir::Value,
+    ) -> ir::Value {
+        if cfg!(feature = "unsafe_disable_continuation_linearity_check") {
+            // The "contref" is a contobj already
+            return contref;
+        } else {
+            let (_vmctx, contobj) =
+                generate_builtin_call!(self, builder, cont_ref_get_cont_obj, [contref]);
+            return contobj;
+        }
+    }
+
+    /// TODO
+    fn typed_continuations_store_resume_args(
+        &mut self,
+        builder: &mut FunctionBuilder,
+        values: &[ir::Value],
+        remaining_arg_count: ir::Value,
+        contobj: ir::Value,
+    ) {
+        let nargs = builder.ins().iconst(I32, values.len() as i64);
+
+        if values.len() > 0 {
+            let use_args_block = builder.create_block();
+            let use_payloads_block = builder.create_block();
+            let store_data_block = builder.create_block();
+            builder.append_block_param(store_data_block, self.pointer_type());
+
+            let (_vmctx, is_invoked) =
+                generate_builtin_call!(self, builder, cont_obj_has_state_invoked, [contobj]);
+
+            builder
+                .ins()
+                .brif(is_invoked, use_payloads_block, &[], use_args_block, &[]);
+
+            {
+                builder.switch_to_block(use_args_block);
+                builder.seal_block(use_args_block);
+                let (_vmctx, ptr) = generate_builtin_call!(
+                    self,
+                    builder,
+                    cont_obj_occupy_next_args_slots,
+                    [contobj, nargs]
+                );
+                builder.ins().jump(store_data_block, &[ptr]);
+            }
+
+            {
+                builder.switch_to_block(use_payloads_block);
+                builder.seal_block(use_payloads_block);
+                let (_vmctx, ptr) = generate_builtin_call!(
+                    self,
+                    builder,
+                    cont_obj_occupy_next_tag_returns_slots,
+                    [contobj, nargs, remaining_arg_count]
+                );
+                builder.ins().jump(store_data_block, &[ptr]);
+            }
+
+            {
+                builder.switch_to_block(store_data_block);
+                builder.seal_block(store_data_block);
+
+                let ptr = builder.block_params(store_data_block)[0];
+
+                // Store the values.
+                let memflags = ir::MemFlags::trusted();
+                let mut offset = 0;
+                for value in values {
+                    builder.ins().store(memflags, *value, ptr, offset);
+                    offset += self.offsets.ptr.maximum_value_size() as i32;
+                }
+            }
+        }
+    }
+
+    //TODO(frank-emrich) Consider removing `valtypes` argument, as values are inherently typed
+    fn typed_continuations_store_payloads(
+        &mut self,
+        builder: &mut FunctionBuilder,
+        valtypes: &[WasmType],
+        values: &[ir::Value],
+    ) {
+        //TODO(frank-emrich) what flags exactly do we need here?
+        let memflags = ir::MemFlags::trusted();
+
+        assert_eq!(values.len(), valtypes.len());
+        if valtypes.len() > 0 {
+            let nargs = builder.ins().iconst(I32, values.len() as i64);
+
+            let (_vmctx, payload_addr) =
+                generate_builtin_call!(self, builder, allocate_payload_buffer, [nargs]);
+
+            let mut offset = 0;
+            for value in values {
+                builder.ins().store(memflags, *value, payload_addr, offset);
+                offset += self.offsets.ptr.maximum_value_size() as i32;
+            }
+        }
+    }
+
+    fn typed_continuations_load_continuation_object(
+        &self,
+        builder: &mut FunctionBuilder,
+        base_addr: ir::Value,
+    ) -> ir::Value {
+        let memflags = ir::MemFlags::trusted().with_readonly();
+        let offset = i32::try_from(self.offsets.vmctx_typed_continuations_store()).unwrap();
+        builder
+            .ins()
+            .load(self.pointer_type(), memflags, base_addr, offset)
+    }
+
+    fn typed_continuations_new_cont_ref(
+        &mut self,
+        builder: &mut FunctionBuilder,
+        contobj_addr: ir::Value,
+    ) -> ir::Value {
+        if cfg!(feature = "unsafe_disable_continuation_linearity_check") {
+            return contobj_addr;
+        } else {
+            let (_vmctx, contref) =
+                generate_builtin_call!(self, builder, new_cont_ref, [contobj_addr]);
+            return contref;
+        }
+    }
+
+    /// TODO
+    fn typed_continuations_drop_cont_obj(
+        &mut self,
+        builder: &mut FunctionBuilder,
+        contobj: ir::Value,
+    ) {
+        generate_builtin_call_no_return_val!(self, builder, drop_cont_obj, [contobj]);
+    }
+
+    fn typed_continuations_load_return_values(
+        &mut self,
+        builder: &mut FunctionBuilder,
+        valtypes: &[WasmType],
+        contobj: ir::Value,
+    ) -> std::vec::Vec<ir::Value> {
+        let mut values = vec![];
+
+        if valtypes.len() > 0 {
+            let (_vmctx, result_buffer_addr) =
+                generate_builtin_call!(self, builder, cont_obj_get_results, [contobj]);
+
+            let mut offset = 0;
+            let memflags = ir::MemFlags::trusted();
+            for valtype in valtypes {
+                let val = builder.ins().load(
+                    super::value_type(self.isa, *valtype),
+                    memflags,
+                    result_buffer_addr,
+                    offset,
+                );
+                values.push(val);
+                offset += self.offsets.ptr.maximum_value_size() as i32;
+            }
+        }
+        return values;
+    }
+
     fn use_x86_blendv_for_relaxed_laneselect(&self, ty: Type) -> bool {
         self.isa.has_x86_blendv_lowering(ty)
     }
diff --git a/crates/cranelift/src/lib.rs b/crates/cranelift/src/lib.rs
index 87adcf182..cc6ae5358 100644
--- a/crates/cranelift/src/lib.rs
+++ b/crates/cranelift/src/lib.rs
@@ -7,7 +7,7 @@ use cranelift_codegen::ir;
 use cranelift_codegen::isa::{CallConv, TargetIsa};
 use cranelift_entity::PrimaryMap;
 use cranelift_wasm::{DefinedFuncIndex, WasmFuncType, WasmType};
-use target_lexicon::Architecture;
+use target_lexicon::CallingConvention;
 use wasmtime_cranelift_shared::CompiledFunctionMetadata;
 
 pub use builder::builder;
@@ -126,27 +126,18 @@ fn array_call_signature(isa: &dyn TargetIsa) -> ir::Signature {
 
 /// Get the internal Wasm calling convention signature for the given type.
 fn wasm_call_signature(isa: &dyn TargetIsa, wasm_func_ty: &WasmFuncType) -> ir::Signature {
-    // NB: this calling convention in the near future is expected to be
-    // unconditionally switched to the "tail" calling convention once all
-    // platforms have support for tail calls.
-    //
-    // Also note that the calling convention for wasm functions is purely an
-    // internal implementation detail of cranelift and Wasmtime. Native Rust
-    // code does not interact with raw wasm functions and instead always
-    // operates through trampolines either using the `array_call_signature` or
-    // `native_call_signature` where the default platform ABI is used.
-    let call_conv = match isa.triple().architecture {
-        // On s390x the "wasmtime" calling convention is used to give vectors
-        // little-endian lane order at the ABI layer which should reduce the
-        // need for conversion when operating on vector function arguments. By
-        // default vectors on s390x are otherwise in big-endian lane order which
-        // would require conversions.
-        Architecture::S390x => CallConv::WasmtimeSystemV,
-
-        // All other platforms pick "fast" as the calling convention since it's
-        // presumably, well, the fastest.
-        _ => CallConv::Fast,
+    let call_conv = if isa.triple().default_calling_convention().ok()
+        == Some(CallingConvention::AppleAarch64)
+    {
+        // FIXME: We need an Apple-specific calling convention, so that
+        // Cranelift's ABI implementation generates unwinding directives
+        // about pointer authentication usage, so we can't just use
+        // `CallConv::Fast`.
+        CallConv::AppleAarch64
+    } else {
+        CallConv::Fast
     };
+
     let mut sig = blank_sig(isa, call_conv);
     let cvt = |ty: &WasmType| ir::AbiParam::new(value_type(isa, *ty));
     sig.params.extend(wasm_func_ty.params().iter().map(&cvt));
diff --git a/crates/environ/Cargo.toml b/crates/environ/Cargo.toml
index ed0499b30..8eb284151 100644
--- a/crates/environ/Cargo.toml
+++ b/crates/environ/Cargo.toml
@@ -15,7 +15,7 @@ anyhow = { workspace = true }
 cranelift-entity = { workspace = true }
 wasmtime-types = { workspace = true }
 wasmparser = { workspace = true }
-indexmap = { workspace = true, features = ["serde"] }
+indexmap = { version = "1.0.2", features = ["serde-1"] }
 thiserror = { workspace = true }
 serde = { version = "1.0.94", features = ["derive"] }
 log = { workspace = true }
diff --git a/crates/environ/examples/factc.rs b/crates/environ/examples/factc.rs
index b6bf89ff7..473168d9a 100644
--- a/crates/environ/examples/factc.rs
+++ b/crates/environ/examples/factc.rs
@@ -128,13 +128,15 @@ impl Factc {
             .validate_all(&input)
             .context("failed to validate input wasm")?;
         let wasm_types = wasm_types.as_ref();
-        for i in 0..wasm_types.component_type_count() {
-            let ty = wasm_types.component_type_at(i);
-            let ty = match &wasm_types[ty] {
-                wasmparser::types::Type::ComponentFunc(ty) => {
-                    types.convert_component_func_type(wasm_types, ty)?
-                }
-                _ => continue,
+        for i in 0.. {
+            let ty = match wasm_types.id_from_type_index(i, false) {
+                Some(ty) => ty,
+                None => break,
+            };
+            let wasm_ty = wasm_types.type_from_id(ty).unwrap();
+            let ty = match wasm_ty.as_component_func_type() {
+                Some(ty) => types.convert_component_func_type(wasm_types, ty)?,
+                None => continue,
             };
             adapters.push(Adapter {
                 lift_ty: ty,
diff --git a/crates/environ/src/builtin.rs b/crates/environ/src/builtin.rs
index 61eb31a1f..ed97cde77 100644
--- a/crates/environ/src/builtin.rs
+++ b/crates/environ/src/builtin.rs
@@ -51,6 +51,63 @@ macro_rules! foreach_builtin_function {
             out_of_gas(vmctx: vmctx);
             /// Invoked when we reach a new epoch.
             new_epoch(vmctx: vmctx) -> i64;
+            /// Creates a new continuation from a funcref.
+
+            cont_new(vmctx: vmctx, r: pointer, param_count: i64, result_count: i64) -> pointer;
+            /// Resumes a continuation.
+            resume(vmctx: vmctx, contobj: pointer) -> i32;
+            /// Suspends a continuation.
+            suspend(vmctx: vmctx, tag: i32);
+            /// Projects the buffer storing the results after a continuation
+            /// function has returned normally.
+            /// Must only be called after the continuation has returned and
+            /// the executed function has return values.
+            cont_obj_get_results(vmctx: vmctx, contobj: pointer) -> pointer;
+            /// Projects a pointer within the continuation argument buffer
+            /// pointing at the next free slot. Marks the next `arg_count`
+            /// entries in that buffer as used.
+            cont_obj_occupy_next_args_slots(vmctx: vmctx, contobj: pointer, arg_count: i32) -> pointer;
+            /// Returns a boolean indicating whether the state of the continutation object is `Invoked`
+            cont_obj_has_state_invoked(vmctx: vmctx, contobj: pointer) -> i32;
+            /// Returns the continuation object corresponding to the given continuation reference.
+            cont_ref_get_cont_obj(vmctx: vmctx, contref: pointer) -> pointer;
+            /// Drops the given continuation object. Currently unused.
+            //cont_obj_drop(vmctx: vmctx, contobj: pointer);
+            /// Crates a new continuation reference.
+            new_cont_ref(vmctx: vmctx, contobj: pointer) -> pointer;
+
+
+            /// Allocates a buffer large enough for storing `element_count` tag
+            /// payloads and stores it in the `VMContext` in such a way that
+            /// subsequent calls to `get_payload_buffer` will return the same
+            /// buffer.
+            /// Returns a pointer to that buffer.
+            /// Such a payload buffer is only used to store payloads provided
+            /// at a suspend site and read in a corresponding handler.
+            allocate_payload_buffer(vmctx: vmctx, element_count: i32) -> pointer;
+            /// Counterpart to `alllocate_payload_buffer`, deallocating the
+            /// buffer. For debugging purposes, `expected_element_capacity`
+            /// should be the same value passed when allocating.
+            deallocate_payload_buffer(vmctx: vmctx, expected_element_capacity: i32);
+            /// Returns pointer to the payload buffer, whose function was described earlier.
+            /// `expected_element_capacity` should be the same value passed when
+            /// allocating.
+            get_payload_buffer(vmctx: vmctx, expected_element_capacity: i32) -> pointer;
+
+
+            /// Returns a pointer to the next empty slot within the tag return value buffer
+            /// of the given continuation object.
+            /// Such a buffer is used to store payloads provided by cont.bind and resume
+            /// and received at a suspend site.
+            /// The next `arg_count` slots within the buffer are marked as used.
+            /// If no such buffer currently exists, a new one is allocated.
+            cont_obj_occupy_next_tag_returns_slots(vmctx: vmctx, contobj: pointer, arg_count : i32, remaining_arg_count : i32) -> pointer;
+            /// Returns a pointer to the beginning of the tag return value buffer
+            cont_obj_get_tag_return_values_buffer(vmctx: vmctx, contobj: pointer, expected_count : i32) -> pointer;
+            /// Deallocated the tag return value buffer within the continuation object.
+            cont_obj_deallocate_tag_return_values_buffer(vmctx: vmctx, contobj: pointer);
+            /// TODO
+            drop_cont_obj(vmctx: vmctx, contobj: pointer);
         }
     };
 }
diff --git a/crates/environ/src/component.rs b/crates/environ/src/component.rs
index 611f8c07d..0961b356e 100644
--- a/crates/environ/src/component.rs
+++ b/crates/environ/src/component.rs
@@ -60,11 +60,11 @@ macro_rules! foreach_transcoder {
             latin1_to_latin1(src: ptr_u8, len: size, dst: ptr_u8);
             latin1_to_utf16(src: ptr_u8, len: size, dst: ptr_u16);
             utf8_to_utf16(src: ptr_u8, len: size, dst: ptr_u16) -> size;
-            utf16_to_utf8(src: ptr_u16, src_len: size, dst: ptr_u8, dst_len: size, ret2: ptr_size) -> size;
-            latin1_to_utf8(src: ptr_u8, src_len: size, dst: ptr_u8, dst_len: size, ret2: ptr_size) -> size;
+            utf16_to_utf8(src: ptr_u16, src_len: size, dst: ptr_u8, dst_len: size) -> size_pair;
+            latin1_to_utf8(src: ptr_u8, src_len: size, dst: ptr_u8, dst_len: size) -> size_pair;
             utf16_to_compact_probably_utf16(src: ptr_u16, len: size, dst: ptr_u16) -> size;
-            utf8_to_latin1(src: ptr_u8, len: size, dst: ptr_u8, ret2: ptr_size) -> size;
-            utf16_to_latin1(src: ptr_u16, len: size, dst: ptr_u8, ret2: ptr_size) -> size;
+            utf8_to_latin1(src: ptr_u8, len: size, dst: ptr_u8) -> size_pair;
+            utf16_to_latin1(src: ptr_u16, len: size, dst: ptr_u8) -> size_pair;
             utf8_to_compact_utf16(src: ptr_u8, src_len: size, dst: ptr_u16, dst_len: size, bytes_so_far: size) -> size;
             utf16_to_compact_utf16(src: ptr_u16, src_len: size, dst: ptr_u16, dst_len: size, bytes_so_far: size) -> size;
         }
diff --git a/crates/environ/src/component/dfg.rs b/crates/environ/src/component/dfg.rs
index aa02d6b7d..bd7ee9658 100644
--- a/crates/environ/src/component/dfg.rs
+++ b/crates/environ/src/component/dfg.rs
@@ -303,6 +303,7 @@ impl ComponentDfg {
         let mut linearize = LinearizeDfg {
             dfg: &self,
             initializers: Vec::new(),
+            num_runtime_modules: 0,
             runtime_memories: Default::default(),
             runtime_post_return: Default::default(),
             runtime_reallocs: Default::default(),
@@ -335,6 +336,7 @@ impl ComponentDfg {
             exports,
             initializers: linearize.initializers,
 
+            num_runtime_modules: linearize.num_runtime_modules,
             num_runtime_memories: linearize.runtime_memories.len() as u32,
             num_runtime_post_returns: linearize.runtime_post_return.len() as u32,
             num_runtime_reallocs: linearize.runtime_reallocs.len() as u32,
@@ -353,6 +355,7 @@ impl ComponentDfg {
 struct LinearizeDfg<'a> {
     dfg: &'a ComponentDfg,
     initializers: Vec<GlobalInitializer>,
+    num_runtime_modules: u32,
     runtime_memories: HashMap<MemoryId, RuntimeMemoryIndex>,
     runtime_reallocs: HashMap<ReallocId, RuntimeReallocIndex>,
     runtime_post_return: HashMap<PostReturnId, RuntimePostReturnIndex>,
@@ -409,8 +412,20 @@ impl LinearizeDfg<'_> {
                     options,
                 }
             }
-            Export::ModuleStatic(i) => info::Export::ModuleStatic(*i),
-            Export::ModuleImport(i) => info::Export::ModuleImport(*i),
+            Export::ModuleStatic(i) => {
+                let index = RuntimeModuleIndex::from_u32(self.num_runtime_modules);
+                self.num_runtime_modules += 1;
+                self.initializers
+                    .push(GlobalInitializer::SaveStaticModule(*i));
+                info::Export::Module(index)
+            }
+            Export::ModuleImport(i) => {
+                let index = RuntimeModuleIndex::from_u32(self.num_runtime_modules);
+                self.num_runtime_modules += 1;
+                self.initializers
+                    .push(GlobalInitializer::SaveModuleImport(*i));
+                info::Export::Module(index)
+            }
             Export::Instance(map) => info::Export::Instance(
                 map.iter()
                     .map(|(name, export)| (name.clone(), self.export(export)))
diff --git a/crates/environ/src/component/info.rs b/crates/environ/src/component/info.rs
index 74e518942..9b74146f3 100644
--- a/crates/environ/src/component/info.rs
+++ b/crates/environ/src/component/info.rs
@@ -140,6 +140,10 @@ pub struct Component {
     /// instantiate this component.
     pub num_lowerings: u32,
 
+    /// The number of modules that are required to be saved within an instance
+    /// at runtime, or effectively the number of exported modules.
+    pub num_runtime_modules: u32,
+
     /// The number of functions which "always trap" used to implement
     /// `canon.lower` of `canon.lift`'d functions within the same component.
     pub num_always_trap: u32,
@@ -217,6 +221,13 @@ pub enum GlobalInitializer {
     /// used as a `post-return` function.
     ExtractPostReturn(ExtractPostReturn),
 
+    /// The `module` specified is saved into the runtime state at the next
+    /// `RuntimeModuleIndex`, referred to later by `Export` definitions.
+    SaveStaticModule(StaticModuleIndex),
+
+    /// Same as `SaveModuleUpvar`, but for imports.
+    SaveModuleImport(RuntimeImportIndex),
+
     /// Similar to `ExtractMemory` and friends and indicates that a `VMFuncRef`
     /// needs to be initialized for a transcoder function and this will later be
     /// used to instantiate an adapter module.
@@ -423,9 +434,10 @@ pub enum Export {
         options: CanonicalOptions,
     },
     /// A module defined within this component is exported.
-    ModuleStatic(StaticModuleIndex),
-    /// A module imported into this component is exported.
-    ModuleImport(RuntimeImportIndex),
+    ///
+    /// The module index here indexes a module recorded with
+    /// `GlobalInitializer::SaveModule` above.
+    Module(RuntimeModuleIndex),
     /// A nested instance is being exported which has recursively defined
     /// `Export` items.
     Instance(IndexMap<String, Export>),
diff --git a/crates/environ/src/component/translate.rs b/crates/environ/src/component/translate.rs
index 5133a2064..84c3ad63b 100644
--- a/crates/environ/src/component/translate.rs
+++ b/crates/environ/src/component/translate.rs
@@ -422,8 +422,11 @@ impl<'a, 'data> Translator<'a, 'data> {
                             core_func_index,
                             options,
                         } => {
-                            let ty =
-                                types[types.component_type_at(type_index)].unwrap_component_func();
+                            let ty = types
+                                .type_at(type_index, false)
+                                .unwrap()
+                                .as_component_func_type()
+                                .unwrap();
                             let ty = self.types.convert_component_func_type(types, ty)?;
                             let func = FuncIndex::from_u32(core_func_index);
                             let options = self.canonical_options(&options);
@@ -435,16 +438,15 @@ impl<'a, 'data> Translator<'a, 'data> {
                             func_index,
                             options,
                         } => {
-                            let lower_ty = types.component_function_at(func_index);
-                            let lower_ty = types[lower_ty].unwrap_component_func();
+                            let lower_ty = types.component_function_at(func_index).unwrap();
                             let lower_ty =
                                 self.types.convert_component_func_type(types, lower_ty)?;
 
                             let func = ComponentFuncIndex::from_u32(func_index);
                             let options = self.canonical_options(&options);
 
-                            let canonical_abi = types.function_at(self.result.core_func_index);
-                            let canonical_abi = types[canonical_abi].unwrap_func();
+                            let canonical_abi =
+                                types.function_at(self.result.core_func_index).unwrap();
                             let canonical_abi = self.types.convert_func_type(canonical_abi);
                             let canonical_abi = self
                                 .types
@@ -729,7 +731,7 @@ impl<'a, 'data> Translator<'a, 'data> {
             }
             wasmparser::ComponentExternalKind::Type => {
                 let types = self.validator.types(0).unwrap();
-                let ty = types.component_type_at(index);
+                let ty = types.id_from_type_index(index, false).unwrap();
                 let ty = self.types.convert_type(types, ty)?;
                 ComponentItem::Type(ty)
             }
diff --git a/crates/environ/src/component/types.rs b/crates/environ/src/component/types.rs
index afcca9ee5..3d135ab72 100644
--- a/crates/environ/src/component/types.rs
+++ b/crates/environ/src/component/types.rs
@@ -173,6 +173,10 @@ indices! {
     /// Same as `RuntimeMemoryIndex` except for the `post-return` function.
     pub struct RuntimePostReturnIndex(u32);
 
+    /// Index that represents an exported module from a component since that's
+    /// currently the only use for saving the entire module state at runtime.
+    pub struct RuntimeModuleIndex(u32);
+
     /// Index into the list of transcoders identified during compilation.
     ///
     /// This is used to index the `VMFuncRef` slots reserved for string encoders
@@ -406,14 +410,22 @@ impl ComponentTypesBuilder {
                 TypeDef::ComponentInstance(self.convert_instance(types, id)?)
             }
             types::ComponentEntityType::Func(id) => {
-                let id = types[id].unwrap_component_func();
+                let id = types
+                    .type_from_id(id)
+                    .unwrap()
+                    .as_component_func_type()
+                    .unwrap();
                 let idx = self.convert_component_func_type(types, id)?;
                 TypeDef::ComponentFunc(idx)
             }
-            types::ComponentEntityType::Type { created, .. } => match &types[created] {
-                types::Type::Defined(_) => TypeDef::Interface(self.defined_type(types, created)?),
-                _ => bail!("unsupported type export"),
-            },
+            types::ComponentEntityType::Type { created, .. } => {
+                match types.type_from_id(created).unwrap() {
+                    types::Type::Defined(_) => {
+                        TypeDef::Interface(self.defined_type(types, created)?)
+                    }
+                    _ => bail!("unsupported type export"),
+                }
+            }
             types::ComponentEntityType::Value(_) => bail!("values not supported"),
         })
     }
@@ -424,7 +436,7 @@ impl ComponentTypesBuilder {
         types: types::TypesRef<'_>,
         id: types::TypeId,
     ) -> Result<TypeDef> {
-        Ok(match &types[id] {
+        Ok(match types.type_from_id(id).unwrap() {
             types::Type::Defined(_) => TypeDef::Interface(self.defined_type(types, id)?),
             types::Type::Module(_) => TypeDef::Module(self.convert_module(types, id)?),
             types::Type::Component(_) => TypeDef::Component(self.convert_component(types, id)?),
@@ -434,10 +446,10 @@ impl ComponentTypesBuilder {
             types::Type::ComponentFunc(f) => {
                 TypeDef::ComponentFunc(self.convert_component_func_type(types, f)?)
             }
-            types::Type::Instance(_) | types::Type::Sub(_) => {
+            types::Type::Instance(_) | types::Type::Func(_) | types::Type::Array(_) => {
                 unreachable!()
             }
-            types::Type::Resource(_) => unimplemented!(),
+            types::Type::Resource(_) | types::Type::Cont(_) => unimplemented!(),
         })
     }
 
@@ -449,7 +461,7 @@ impl ComponentTypesBuilder {
         if let Some(ret) = self.component_types_cache.get(&id) {
             return Ok(*ret);
         }
-        let ty = types[id].unwrap_component();
+        let ty = &types.type_from_id(id).unwrap().as_component_type().unwrap();
         let mut result = TypeComponent::default();
         for (name, ty) in ty.imports.iter() {
             result.imports.insert(
@@ -476,7 +488,11 @@ impl ComponentTypesBuilder {
         if let Some(ret) = self.instance_types_cache.get(&id) {
             return Ok(*ret);
         }
-        let ty = types[id].unwrap_component_instance();
+        let ty = &types
+            .type_from_id(id)
+            .unwrap()
+            .as_component_instance_type()
+            .unwrap();
         let mut result = TypeComponentInstance::default();
         for (name, ty) in ty.exports.iter() {
             result.exports.insert(
@@ -497,7 +513,7 @@ impl ComponentTypesBuilder {
         if let Some(ret) = self.module_types_cache.get(&id) {
             return Ok(*ret);
         }
-        let ty = types[id].unwrap_module();
+        let ty = &types.type_from_id(id).unwrap().as_module_type().unwrap();
         let mut result = TypeModule::default();
         for ((module, field), ty) in ty.imports.iter() {
             result.imports.insert(
@@ -522,7 +538,7 @@ impl ComponentTypesBuilder {
     ) -> Result<EntityType> {
         Ok(match ty {
             types::EntityType::Func(idx) => {
-                let ty = types[*idx].unwrap_func();
+                let ty = types.type_from_id(*idx).unwrap().as_func_type().unwrap();
                 let ty = self.convert_func_type(ty);
                 EntityType::Function(self.module_types_builder().wasm_func_type(ty))
             }
@@ -541,7 +557,7 @@ impl ComponentTypesBuilder {
         if let Some(ty) = self.defined_types_cache.get(&id) {
             return Ok(*ty);
         }
-        let ret = match types[id].unwrap_defined() {
+        let ret = match types.type_from_id(id).unwrap().as_defined_type().unwrap() {
             types::ComponentDefinedType::Primitive(ty) => ty.into(),
             types::ComponentDefinedType::Record(e) => {
                 InterfaceType::Record(self.record_type(types, e)?)
diff --git a/crates/environ/src/continuation.rs b/crates/environ/src/continuation.rs
new file mode 100644
index 000000000..e69de29bb
diff --git a/crates/environ/src/fact.rs b/crates/environ/src/fact.rs
index bf9b2ffce..01ded60e4 100644
--- a/crates/environ/src/fact.rs
+++ b/crates/environ/src/fact.rs
@@ -25,7 +25,6 @@ use crate::component::{
 };
 use crate::fact::transcode::Transcoder;
 use crate::{EntityRef, FuncIndex, GlobalIndex, MemoryIndex, PrimaryMap};
-use std::borrow::Cow;
 use std::collections::HashMap;
 use wasm_encoder::*;
 
@@ -439,7 +438,7 @@ impl<'a> Module<'a> {
         if self.debug {
             result.section(&CustomSection {
                 name: "wasmtime-trampoline-traps".into(),
-                data: Cow::Borrowed(&traps),
+                data: std::borrow::Cow::Borrowed(&traps),
             });
         }
         result.finish()
diff --git a/crates/environ/src/module.rs b/crates/environ/src/module.rs
index 565329df0..6ff03109c 100644
--- a/crates/environ/src/module.rs
+++ b/crates/environ/src/module.rs
@@ -781,6 +781,7 @@ pub struct TableSegment {
 #[allow(missing_docs)]
 pub enum ModuleType {
     Function(SignatureIndex),
+    Continuation(SignatureIndex),
 }
 
 impl ModuleType {
@@ -789,6 +790,16 @@ impl ModuleType {
     pub fn unwrap_function(&self) -> SignatureIndex {
         match self {
             ModuleType::Function(f) => *f,
+            ModuleType::Continuation(_) => panic!("Attempt to unwrap non-function."),
+        }
+    }
+
+    /// Assert his is a `ModuleType::Continuation`, returning the
+    /// underlying `TypeIndex`.
+    pub fn unwrap_continuation(&self) -> SignatureIndex {
+        match self {
+            ModuleType::Continuation(f) => *f,
+            _ => panic!("Attempt to unwrap non-continuation."),
         }
     }
 }
@@ -860,6 +871,9 @@ pub struct Module {
 
     /// WebAssembly global initializers for locally-defined globals.
     pub global_initializers: PrimaryMap<DefinedGlobalIndex, GlobalInit>,
+
+    /// WebAssembly exceptions and typed control tags.
+    pub tags: PrimaryMap<TagIndex, FunctionType>,
 }
 
 /// Initialization routines for creating an instance, encompassing imports,
@@ -1047,12 +1061,21 @@ impl Module {
             func_ref,
         })
     }
+
+    /// TODO
+    pub fn push_tag(&mut self, signature: SignatureIndex) -> TagIndex {
+        self.tags.push(FunctionType {
+            signature,
+            func_ref: FuncRefIndex::reserved_value(),
+        })
+    }
 }
 
 impl TypeConvert for Module {
     fn lookup_heap_type(&self, index: TypeIndex) -> WasmHeapType {
         match self.types[index] {
             ModuleType::Function(i) => WasmHeapType::TypedFunc(i),
+            ModuleType::Continuation(i) => WasmHeapType::TypedFunc(i), // TODO(dhil): Perhaps we should have a continuation heap type...
         }
     }
 }
diff --git a/crates/environ/src/module_environ.rs b/crates/environ/src/module_environ.rs
index 670d764f0..7371d2285 100644
--- a/crates/environ/src/module_environ.rs
+++ b/crates/environ/src/module_environ.rs
@@ -16,8 +16,8 @@ use std::path::PathBuf;
 use std::sync::Arc;
 use wasmparser::{
     types::Types, CustomSectionReader, DataKind, ElementItems, ElementKind, Encoding, ExternalKind,
-    FuncToValidate, FunctionBody, NameSectionReader, Naming, Operator, Parser, Payload,
-    StructuralType, TypeRef, Validator, ValidatorResources,
+    FuncToValidate, FunctionBody, NameSectionReader, Naming, Operator, Parser, Payload, Type,
+    TypeRef, Validator, ValidatorResources,
 };
 
 /// Object containing the standalone environment information.
@@ -238,18 +238,17 @@ impl<'a, 'data> ModuleEnvironment<'a, 'data> {
                 self.types.reserve_wasm_signatures(num);
 
                 for ty in types {
-                    let ty = ty?;
-                    if ty.is_final || ty.supertype_idx.is_some() {
-                        unimplemented!("gc proposal")
-                    }
-                    match ty.structural_type {
-                        StructuralType::Func(wasm_func_ty) => {
+                    match ty? {
+                        Type::Func(wasm_func_ty) => {
                             let ty = self.convert_func_type(&wasm_func_ty);
                             self.declare_type_func(ty)?;
                         }
-                        StructuralType::Array(_) | StructuralType::Struct(_) => {
+                        Type::Array(_) => {
                             unimplemented!("gc proposal")
                         }
+                        Type::Cont(i) => {
+                            self.declare_type_cont(i)?;
+                        }
                     }
                 }
             }
@@ -362,9 +361,19 @@ impl<'a, 'data> ModuleEnvironment<'a, 'data> {
             Payload::TagSection(tags) => {
                 self.validator.tag_section(&tags)?;
 
+                let cnt = usize::try_from(tags.count()).unwrap();
+                self.result.module.tags.reserve_exact(cnt);
+
+                for entry in tags {
+                    let sigindex = entry?.func_type_idx;
+                    let ty = TypeIndex::from_u32(sigindex);
+                    let sig_index = self.result.module.types[ty].unwrap_function();
+                    self.result.module.push_tag(sig_index);
+                }
+
                 // This feature isn't enabled at this time, so we should
                 // never get here.
-                unreachable!();
+                //unreachable!();
             }
 
             Payload::GlobalSection(globals) => {
@@ -812,6 +821,15 @@ and for re-adding support for interface types you can see this issue:
         Ok(())
     }
 
+    fn declare_type_cont(&mut self, index: u32) -> WasmResult<()> {
+        let sig_index = self.result.module.types[TypeIndex::from_u32(index)].unwrap_function();
+        self.result
+            .module
+            .types
+            .push(ModuleType::Continuation(sig_index));
+        Ok(())
+    }
+
     /// Parses the Name section of the wasm module.
     fn name_section(&mut self, names: NameSectionReader<'data>) -> WasmResult<()> {
         for subsection in names {
diff --git a/crates/environ/src/trap_encoding.rs b/crates/environ/src/trap_encoding.rs
index c65185abb..7b90be91a 100644
--- a/crates/environ/src/trap_encoding.rs
+++ b/crates/environ/src/trap_encoding.rs
@@ -1,6 +1,7 @@
 use crate::obj::ELF_WASMTIME_TRAPS;
 use object::write::{Object, StandardSegment};
 use object::{Bytes, LittleEndian, SectionKind, U32Bytes};
+
 use std::convert::TryFrom;
 use std::fmt;
 use std::ops::Range;
diff --git a/crates/environ/src/vmoffsets.rs b/crates/environ/src/vmoffsets.rs
index cd94fc9e8..96cf9c104 100644
--- a/crates/environ/src/vmoffsets.rs
+++ b/crates/environ/src/vmoffsets.rs
@@ -91,6 +91,11 @@ pub struct VMOffsets<P> {
     defined_globals: u32,
     defined_func_refs: u32,
     size: u32,
+
+    // NOTE(dhil): The following field is used as "global" to store
+    // the arguments of continuations and payloads of suspensions.
+    typed_continuations_store: u32,
+    typed_continuations_payloads_ptr: u32,
 }
 
 /// Trait used for the `ptr` representation of the field of `VMOffsets`
@@ -154,6 +159,12 @@ pub trait PtrSize {
         16
     }
 
+    /// This is the size of the largest value type (i.e. a V128).
+    #[inline]
+    fn maximum_value_size(&self) -> u8 {
+        self.size_of_vmglobal_definition()
+    }
+
     // Offsets within `VMRuntimeLimits`
 
     /// Return the offset of the `stack_limit` field of `VMRuntimeLimits`
@@ -352,6 +363,8 @@ impl<P: PtrSize> VMOffsets<P> {
         }
 
         calculate_sizes! {
+            typed_continuations_payloads_ptr: "typed continuations payloads",
+            typed_continuations_store: "typed continuations store",
             defined_func_refs: "module functions",
             defined_globals: "defined globals",
             owned_memories: "owned memories",
@@ -404,6 +417,8 @@ impl<P: PtrSize> From<VMOffsetsFields<P>> for VMOffsets<P> {
             defined_globals: 0,
             defined_func_refs: 0,
             size: 0,
+            typed_continuations_store: 0,
+            typed_continuations_payloads_ptr: 0,
         };
 
         // Convenience functions for checked addition and multiplication.
@@ -466,6 +481,12 @@ impl<P: PtrSize> From<VMOffsetsFields<P>> for VMOffsets<P> {
                 ret.num_escaped_funcs,
                 ret.ptr.size_of_vm_func_ref(),
             ),
+            size(typed_continuations_store)
+                = ret.ptr.size(),
+            size(typed_continuations_payloads_ptr) = ret.ptr.size(),
+            align(16), // TODO(dhil): This could probably be done more
+                       // efficiently by packing the pointer into the above 16 byte
+                       // alignment
         }
 
         ret.size = next_field_offset;
@@ -730,6 +751,18 @@ impl<P: PtrSize> VMOffsets<P> {
         self.builtin_functions
     }
 
+    /// The offset of the typed continuations store.
+    #[inline]
+    pub fn vmctx_typed_continuations_store(&self) -> u32 {
+        self.typed_continuations_store
+    }
+
+    /// The offset of the typed continuations payloads pointer.
+    #[inline]
+    pub fn vmctx_typed_continuations_payloads_ptr(&self) -> u32 {
+        self.typed_continuations_payloads_ptr
+    }
+
     /// Return the size of the `VMContext` allocation.
     #[inline]
     pub fn size_of_vmctx(&self) -> u32 {
diff --git a/crates/fiber/Cargo.toml b/crates/fiber/Cargo.toml
index f62c2f2fb..e2acc6c0f 100644
--- a/crates/fiber/Cargo.toml
+++ b/crates/fiber/Cargo.toml
@@ -7,9 +7,14 @@ license = "Apache-2.0 WITH LLVM-exception"
 repository = "https://github.com/bytecodealliance/wasmtime"
 edition.workspace = true
 
+# We link to some native code with symbols that don't change often, so let Cargo
+# know that we can't show up multiple times in a crate graph. If this is an
+# issue in the future we should tweak the build script to set `#define`
+# directives or similar to embed a version number of this crate in symbols.
+links = "wasmtime-fiber-shims"
+
 [dependencies]
 cfg-if = { workspace = true }
-wasmtime-versioned-export-macros = { workspace = true }
 
 [target.'cfg(unix)'.dependencies]
 rustix = { workspace = true, features = ["mm", "param"] }
@@ -24,7 +29,6 @@ features = [
 
 [build-dependencies]
 cc = "1.0"
-wasmtime-versioned-export-macros = { workspace = true }
 
 [dev-dependencies]
 backtrace = "0.3.61"
diff --git a/crates/fiber/build.rs b/crates/fiber/build.rs
index 079a58167..6bfc5c4b9 100644
--- a/crates/fiber/build.rs
+++ b/crates/fiber/build.rs
@@ -1,5 +1,4 @@
 use std::env;
-use wasmtime_versioned_export_macros::versioned_suffix;
 
 fn main() {
     let mut build = cc::Build::new();
@@ -8,11 +7,9 @@ fn main() {
     if os == "windows" {
         println!("cargo:rerun-if-changed=src/windows.c");
         build.file("src/windows.c");
-        build.define("VERSIONED_SUFFIX", Some(versioned_suffix!()));
     } else if arch == "s390x" {
         println!("cargo:rerun-if-changed=src/unix/s390x.S");
         build.file("src/unix/s390x.S");
-        build.define("VERSIONED_SUFFIX", Some(versioned_suffix!()));
     } else {
         // assume that this is included via inline assembly in the crate itself,
         // and the crate will otherwise have a `compile_error!` for unsupported
diff --git a/crates/fiber/src/unix.rs b/crates/fiber/src/unix.rs
index b148ff324..ef0ddea6b 100644
--- a/crates/fiber/src/unix.rs
+++ b/crates/fiber/src/unix.rs
@@ -117,16 +117,13 @@ pub struct Fiber;
 pub struct Suspend(*mut u8);
 
 extern "C" {
-    #[wasmtime_versioned_export_macros::versioned_link]
     fn wasmtime_fiber_init(
         top_of_stack: *mut u8,
         entry: extern "C" fn(*mut u8, *mut u8),
         entry_arg0: *mut u8,
     );
-    #[wasmtime_versioned_export_macros::versioned_link]
     fn wasmtime_fiber_switch(top_of_stack: *mut u8);
     #[allow(dead_code)] // only used in inline assembly for some platforms
-    #[wasmtime_versioned_export_macros::versioned_link]
     fn wasmtime_fiber_start();
 }
 
diff --git a/crates/fiber/src/unix/aarch64.rs b/crates/fiber/src/unix/aarch64.rs
index 92a09c24b..d77b1f2fb 100644
--- a/crates/fiber/src/unix/aarch64.rs
+++ b/crates/fiber/src/unix/aarch64.rs
@@ -39,7 +39,7 @@ cfg_if::cfg_if! {
 
 // fn(top_of_stack(%x0): *mut u8)
 asm_func!(
-    wasmtime_versioned_export_macros::versioned_stringify_ident!(wasmtime_fiber_switch),
+    "wasmtime_fiber_switch",
     concat!(
         "
             .cfi_startproc
@@ -114,7 +114,7 @@ asm_func!(
 // wasmtime_fiber_start(), and provides wider coverage.
 #[rustfmt::skip]
 asm_func!(
-    wasmtime_versioned_export_macros::versioned_stringify_ident!(wasmtime_fiber_init),
+    "wasmtime_fiber_init",
     concat!(
         "
             .cfi_startproc
@@ -144,7 +144,7 @@ asm_func!(
 // doing. Like over there note that the relative offsets to registers here
 // match the frame layout in `wasmtime_fiber_switch`.
 asm_func!(
-    wasmtime_versioned_export_macros::versioned_stringify_ident!(wasmtime_fiber_start),
+    "wasmtime_fiber_start",
     "
         .cfi_startproc simple
         .cfi_def_cfa_offset 0
diff --git a/crates/fiber/src/unix/arm.rs b/crates/fiber/src/unix/arm.rs
index c2b3c0f0b..1d320fd1f 100644
--- a/crates/fiber/src/unix/arm.rs
+++ b/crates/fiber/src/unix/arm.rs
@@ -12,7 +12,7 @@ use wasmtime_asm_macros::{asm_func, asm_sym};
 
 // fn(top_of_stack(%r0): *mut u8)
 asm_func!(
-    wasmtime_versioned_export_macros::versioned_stringify_ident!(wasmtime_fiber_switch),
+    "wasmtime_fiber_switch",
     "
         // Save callee-saved registers
         push {{r4-r11,lr}}
@@ -34,7 +34,7 @@ asm_func!(
 //    entry_arg0(%r2): *mut u8,
 // )
 asm_func!(
-    wasmtime_versioned_export_macros::versioned_stringify_ident!(wasmtime_fiber_init),
+    "wasmtime_fiber_init",
     "
         adr r3, wasmtime_fiber_start
         str r3, [r0, #-0x0c] // => lr
@@ -49,7 +49,7 @@ asm_func!(
 );
 
 asm_func!(
-    wasmtime_versioned_export_macros::versioned_stringify_ident!(wasmtime_fiber_start),
+    "wasmtime_fiber_start",
     "
         .cfi_startproc simple
         .cfi_def_cfa_offset 0
diff --git a/crates/fiber/src/unix/riscv64.rs b/crates/fiber/src/unix/riscv64.rs
index 61966f7b3..9c7b0cb01 100644
--- a/crates/fiber/src/unix/riscv64.rs
+++ b/crates/fiber/src/unix/riscv64.rs
@@ -9,7 +9,7 @@ use wasmtime_asm_macros::asm_func;
 
 // fn(top_of_stack(rdi): *mut u8)
 asm_func!(
-    wasmtime_versioned_export_macros::versioned_stringify_ident!(wasmtime_fiber_switch),
+    "wasmtime_fiber_switch",
     "
       // See https://github.com/rust-lang/rust/issues/80608.
       .attribute arch, \"rv64gc\"
@@ -90,7 +90,7 @@ asm_func!(
 // )
 #[rustfmt::skip]
 asm_func!(
-    wasmtime_versioned_export_macros::versioned_stringify_ident!(wasmtime_fiber_init),
+    "wasmtime_fiber_init",
     "
       lla t0,{}
       sd t0,-0x18(a0)  // ra,first should be wasmtime_fiber_start.
@@ -107,7 +107,7 @@ asm_func!(
 );
 
 asm_func!(
-    wasmtime_versioned_export_macros::versioned_stringify_ident!(wasmtime_fiber_start),
+    "wasmtime_fiber_start",
     "
     .cfi_startproc simple
     .cfi_def_cfa_offset 0
diff --git a/crates/fiber/src/unix/s390x.S b/crates/fiber/src/unix/s390x.S
index 4207fcb70..a5a47118b 100644
--- a/crates/fiber/src/unix/s390x.S
+++ b/crates/fiber/src/unix/s390x.S
@@ -10,14 +10,11 @@
 
 .text
 
-#define CONCAT2(a, b) a ## b
-#define CONCAT(a, b) CONCAT2(a , b)
-#define VERSIONED_SYMBOL(a) CONCAT(a, VERSIONED_SUFFIX)
-#define GLOBL(fnname) .globl VERSIONED_SYMBOL(fnname)
-#define HIDDEN(fnname) .hidden VERSIONED_SYMBOL(fnname)
-#define TYPE(fnname) .type VERSIONED_SYMBOL(fnname),@function
-#define FUNCTION(fnname) VERSIONED_SYMBOL(fnname)
-#define SIZE(fnname) .size VERSIONED_SYMBOL(fnname),.-VERSIONED_SYMBOL(fnname)
+#define GLOBL(fnname) .globl fnname
+#define HIDDEN(fnname) .hidden fnname
+#define TYPE(fnname) .type fnname,@function
+#define FUNCTION(fnname) fnname
+#define SIZE(fnname) .size fnname,.-fnname
 
 // fn(top_of_stack(%x0): *mut u8)
 HIDDEN(wasmtime_fiber_switch)
diff --git a/crates/fiber/src/unix/x86_64.rs b/crates/fiber/src/unix/x86_64.rs
index 15e4fd57a..420111c04 100644
--- a/crates/fiber/src/unix/x86_64.rs
+++ b/crates/fiber/src/unix/x86_64.rs
@@ -9,7 +9,7 @@ use wasmtime_asm_macros::asm_func;
 
 // fn(top_of_stack(rdi): *mut u8)
 asm_func!(
-    wasmtime_versioned_export_macros::versioned_stringify_ident!(wasmtime_fiber_switch),
+    "wasmtime_fiber_switch",
     "
         // We're switching to arbitrary code somewhere else, so pessimistically
         // assume that all callee-save register are clobbered. This means we need
@@ -49,7 +49,7 @@ asm_func!(
 // )
 #[rustfmt::skip]
 asm_func!(
-    wasmtime_versioned_export_macros::versioned_stringify_ident!(wasmtime_fiber_init),
+    "wasmtime_fiber_init",
     "
         // Here we're going to set up a stack frame as expected by
         // `wasmtime_fiber_switch`. The values we store here will get restored into
@@ -89,7 +89,7 @@ asm_func!(
 // If you're curious a decent introduction to CFI things and unwinding is at
 // https://www.imperialviolet.org/2017/01/18/cfi.html
 asm_func!(
-    wasmtime_versioned_export_macros::versioned_stringify_ident!(wasmtime_fiber_start),
+    "wasmtime_fiber_start",
     "
         // Use the `simple` directive on the startproc here which indicates that
         // some default settings for the platform are omitted, since this
diff --git a/crates/fiber/src/windows.c b/crates/fiber/src/windows.c
index 9d4176eb1..9e017f9b0 100644
--- a/crates/fiber/src/windows.c
+++ b/crates/fiber/src/windows.c
@@ -1,9 +1,5 @@
 #include <windows.h>
 
-#define CONCAT2(a, b) a ## b
-#define CONCAT(a, b) CONCAT2(a , b)
-#define VERSIONED_SYMBOL(a) CONCAT(a, VERSIONED_SUFFIX)
-
-LPVOID VERSIONED_SYMBOL(wasmtime_fiber_get_current)() {
+LPVOID wasmtime_fiber_get_current() {
    return GetCurrentFiber();
 }
diff --git a/crates/fiber/src/windows.rs b/crates/fiber/src/windows.rs
index 2e09f28b7..04452bd87 100644
--- a/crates/fiber/src/windows.rs
+++ b/crates/fiber/src/windows.rs
@@ -46,7 +46,6 @@ struct StartState {
 const FIBER_FLAG_FLOAT_SWITCH: u32 = 1;
 
 extern "C" {
-    #[wasmtime_versioned_export_macros::versioned_link]
     fn wasmtime_fiber_get_current() -> *mut c_void;
 }
 
diff --git a/crates/fibre/Cargo.toml b/crates/fibre/Cargo.toml
new file mode 100644
index 000000000..fda3db9a6
--- /dev/null
+++ b/crates/fibre/Cargo.toml
@@ -0,0 +1,34 @@
+[package]
+name = "wasmtime-fibre"
+version.workspace = true
+authors.workspace = true
+description = "Fiber support for Wasmtime"
+license = "Apache-2.0 WITH LLVM-exception"
+repository = "https://github.com/bytecodealliance/wasmtime"
+edition.workspace = true
+
+# We link to some native code with symbols that don't change often, so let Cargo
+# know that we can't show up multiple times in a crate graph. If this is an
+# issue in the future we should tweak the build script to set `#define`
+# directives or similar to embed a version number of this crate in symbols.
+links = "wasmtime-fibre-shims"
+
+[dependencies]
+cfg-if = { workspace = true }
+
+[target.'cfg(unix)'.dependencies]
+rustix = { workspace = true, features = ["mm", "param"] }
+wasmtime-asm-macros = { workspace = true }
+
+[target.'cfg(windows)'.dependencies.windows-sys]
+workspace = true
+features = [
+  "Win32_System_Threading",
+  "Win32_Foundation",
+]
+
+[build-dependencies]
+cc = "1.0"
+
+[dev-dependencies]
+backtrace = "0.3.61"
diff --git a/crates/fibre/LICENSE b/crates/fibre/LICENSE
new file mode 100644
index 000000000..f9d81955f
--- /dev/null
+++ b/crates/fibre/LICENSE
@@ -0,0 +1,220 @@
+
+                                 Apache License
+                           Version 2.0, January 2004
+                        http://www.apache.org/licenses/
+
+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+   1. Definitions.
+
+      "License" shall mean the terms and conditions for use, reproduction,
+      and distribution as defined by Sections 1 through 9 of this document.
+
+      "Licensor" shall mean the copyright owner or entity authorized by
+      the copyright owner that is granting the License.
+
+      "Legal Entity" shall mean the union of the acting entity and all
+      other entities that control, are controlled by, or are under common
+      control with that entity. For the purposes of this definition,
+      "control" means (i) the power, direct or indirect, to cause the
+      direction or management of such entity, whether by contract or
+      otherwise, or (ii) ownership of fifty percent (50%) or more of the
+      outstanding shares, or (iii) beneficial ownership of such entity.
+
+      "You" (or "Your") shall mean an individual or Legal Entity
+      exercising permissions granted by this License.
+
+      "Source" form shall mean the preferred form for making modifications,
+      including but not limited to software source code, documentation
+      source, and configuration files.
+
+      "Object" form shall mean any form resulting from mechanical
+      transformation or translation of a Source form, including but
+      not limited to compiled object code, generated documentation,
+      and conversions to other media types.
+
+      "Work" shall mean the work of authorship, whether in Source or
+      Object form, made available under the License, as indicated by a
+      copyright notice that is included in or attached to the work
+      (an example is provided in the Appendix below).
+
+      "Derivative Works" shall mean any work, whether in Source or Object
+      form, that is based on (or derived from) the Work and for which the
+      editorial revisions, annotations, elaborations, or other modifications
+      represent, as a whole, an original work of authorship. For the purposes
+      of this License, Derivative Works shall not include works that remain
+      separable from, or merely link (or bind by name) to the interfaces of,
+      the Work and Derivative Works thereof.
+
+      "Contribution" shall mean any work of authorship, including
+      the original version of the Work and any modifications or additions
+      to that Work or Derivative Works thereof, that is intentionally
+      submitted to Licensor for inclusion in the Work by the copyright owner
+      or by an individual or Legal Entity authorized to submit on behalf of
+      the copyright owner. For the purposes of this definition, "submitted"
+      means any form of electronic, verbal, or written communication sent
+      to the Licensor or its representatives, including but not limited to
+      communication on electronic mailing lists, source code control systems,
+      and issue tracking systems that are managed by, or on behalf of, the
+      Licensor for the purpose of discussing and improving the Work, but
+      excluding communication that is conspicuously marked or otherwise
+      designated in writing by the copyright owner as "Not a Contribution."
+
+      "Contributor" shall mean Licensor and any individual or Legal Entity
+      on behalf of whom a Contribution has been received by Licensor and
+      subsequently incorporated within the Work.
+
+   2. Grant of Copyright License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      copyright license to reproduce, prepare Derivative Works of,
+      publicly display, publicly perform, sublicense, and distribute the
+      Work and such Derivative Works in Source or Object form.
+
+   3. Grant of Patent License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      (except as stated in this section) patent license to make, have made,
+      use, offer to sell, sell, import, and otherwise transfer the Work,
+      where such license applies only to those patent claims licensable
+      by such Contributor that are necessarily infringed by their
+      Contribution(s) alone or by combination of their Contribution(s)
+      with the Work to which such Contribution(s) was submitted. If You
+      institute patent litigation against any entity (including a
+      cross-claim or counterclaim in a lawsuit) alleging that the Work
+      or a Contribution incorporated within the Work constitutes direct
+      or contributory patent infringement, then any patent licenses
+      granted to You under this License for that Work shall terminate
+      as of the date such litigation is filed.
+
+   4. Redistribution. You may reproduce and distribute copies of the
+      Work or Derivative Works thereof in any medium, with or without
+      modifications, and in Source or Object form, provided that You
+      meet the following conditions:
+
+      (a) You must give any other recipients of the Work or
+          Derivative Works a copy of this License; and
+
+      (b) You must cause any modified files to carry prominent notices
+          stating that You changed the files; and
+
+      (c) You must retain, in the Source form of any Derivative Works
+          that You distribute, all copyright, patent, trademark, and
+          attribution notices from the Source form of the Work,
+          excluding those notices that do not pertain to any part of
+          the Derivative Works; and
+
+      (d) If the Work includes a "NOTICE" text file as part of its
+          distribution, then any Derivative Works that You distribute must
+          include a readable copy of the attribution notices contained
+          within such NOTICE file, excluding those notices that do not
+          pertain to any part of the Derivative Works, in at least one
+          of the following places: within a NOTICE text file distributed
+          as part of the Derivative Works; within the Source form or
+          documentation, if provided along with the Derivative Works; or,
+          within a display generated by the Derivative Works, if and
+          wherever such third-party notices normally appear. The contents
+          of the NOTICE file are for informational purposes only and
+          do not modify the License. You may add Your own attribution
+          notices within Derivative Works that You distribute, alongside
+          or as an addendum to the NOTICE text from the Work, provided
+          that such additional attribution notices cannot be construed
+          as modifying the License.
+
+      You may add Your own copyright statement to Your modifications and
+      may provide additional or different license terms and conditions
+      for use, reproduction, or distribution of Your modifications, or
+      for any such Derivative Works as a whole, provided Your use,
+      reproduction, and distribution of the Work otherwise complies with
+      the conditions stated in this License.
+
+   5. Submission of Contributions. Unless You explicitly state otherwise,
+      any Contribution intentionally submitted for inclusion in the Work
+      by You to the Licensor shall be under the terms and conditions of
+      this License, without any additional terms or conditions.
+      Notwithstanding the above, nothing herein shall supersede or modify
+      the terms of any separate license agreement you may have executed
+      with Licensor regarding such Contributions.
+
+   6. Trademarks. This License does not grant permission to use the trade
+      names, trademarks, service marks, or product names of the Licensor,
+      except as required for reasonable and customary use in describing the
+      origin of the Work and reproducing the content of the NOTICE file.
+
+   7. Disclaimer of Warranty. Unless required by applicable law or
+      agreed to in writing, Licensor provides the Work (and each
+      Contributor provides its Contributions) on an "AS IS" BASIS,
+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied, including, without limitation, any warranties or conditions
+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+      PARTICULAR PURPOSE. You are solely responsible for determining the
+      appropriateness of using or redistributing the Work and assume any
+      risks associated with Your exercise of permissions under this License.
+
+   8. Limitation of Liability. In no event and under no legal theory,
+      whether in tort (including negligence), contract, or otherwise,
+      unless required by applicable law (such as deliberate and grossly
+      negligent acts) or agreed to in writing, shall any Contributor be
+      liable to You for damages, including any direct, indirect, special,
+      incidental, or consequential damages of any character arising as a
+      result of this License or out of the use or inability to use the
+      Work (including but not limited to damages for loss of goodwill,
+      work stoppage, computer failure or malfunction, or any and all
+      other commercial damages or losses), even if such Contributor
+      has been advised of the possibility of such damages.
+
+   9. Accepting Warranty or Additional Liability. While redistributing
+      the Work or Derivative Works thereof, You may choose to offer,
+      and charge a fee for, acceptance of support, warranty, indemnity,
+      or other liability obligations and/or rights consistent with this
+      License. However, in accepting such obligations, You may act only
+      on Your own behalf and on Your sole responsibility, not on behalf
+      of any other Contributor, and only if You agree to indemnify,
+      defend, and hold each Contributor harmless for any liability
+      incurred by, or claims asserted against, such Contributor by reason
+      of your accepting any such warranty or additional liability.
+
+   END OF TERMS AND CONDITIONS
+
+   APPENDIX: How to apply the Apache License to your work.
+
+      To apply the Apache License to your work, attach the following
+      boilerplate notice, with the fields enclosed by brackets "[]"
+      replaced with your own identifying information. (Don't include
+      the brackets!)  The text should be enclosed in the appropriate
+      comment syntax for the file format. We also recommend that a
+      file or class name and description of purpose be included on the
+      same "printed page" as the copyright notice for easier
+      identification within third-party archives.
+
+   Copyright [yyyy] [name of copyright owner]
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+
+
+--- LLVM Exceptions to the Apache 2.0 License ----
+
+As an exception, if, as a result of your compiling your source code, portions
+of this Software are embedded into an Object form of such source code, you
+may redistribute such embedded portions in such Object form without complying
+with the conditions of Sections 4(a), 4(b) and 4(d) of the License.
+
+In addition, if you combine or link compiled forms of this Software with
+software that is licensed under the GPLv2 ("Combined Software") and if a
+court of competent jurisdiction determines that the patent provision (Section
+3), the indemnity provision (Section 9) or other Section of the License
+conflicts with the conditions of the GPLv2, you may retroactively and
+prospectively choose to deem waived or otherwise exclude such Section(s) of
+the License, but only in their entirety and only with respect to the Combined
+Software.
+
diff --git a/crates/fibre/build.rs b/crates/fibre/build.rs
new file mode 100644
index 000000000..7dc6efb15
--- /dev/null
+++ b/crates/fibre/build.rs
@@ -0,0 +1,7 @@
+fn main() {
+    // assume that this is included via inline assembly in the crate itself,
+    // and the crate will otherwise have a `compile_error!` for unsupported
+    // platforms.
+    println!("cargo:rerun-if-changed=build.rs");
+    return;
+}
diff --git a/crates/fibre/src/lib.rs b/crates/fibre/src/lib.rs
new file mode 100644
index 000000000..e1eeb67ef
--- /dev/null
+++ b/crates/fibre/src/lib.rs
@@ -0,0 +1,318 @@
+use std::any::Any;
+use std::cell::Cell;
+use std::io;
+use std::marker::PhantomData;
+use std::ops::Range;
+use std::panic::{self, AssertUnwindSafe};
+
+cfg_if::cfg_if! {
+    if #[cfg(windows)] {
+        mod windows;
+        use windows as imp;
+    } else if #[cfg(unix)] {
+        pub mod unix;
+        use unix as imp;
+    } else {
+        compile_error!("fibers are not supported on this platform");
+    }
+}
+
+/// Represents an execution stack to use for a fiber.
+#[derive(Debug)]
+pub struct FiberStack(imp::FiberStack);
+
+impl FiberStack {
+    /// Creates a new fiber stack of the given size.
+    pub fn new(size: usize) -> io::Result<Self> {
+        Ok(Self(imp::FiberStack::new(size)?))
+    }
+
+    /// Creates a new fiber stack of the given size (using malloc).
+    pub fn malloc(size: usize) -> io::Result<Self> {
+        Ok(Self(imp::FiberStack::malloc(size)?))
+    }
+
+    /// Creates a new fiber stack with the given pointer to the bottom of the
+    /// stack plus the byte length of the stack.
+    ///
+    /// The `bottom` pointer should be addressable for `len` bytes. The page
+    /// beneath `bottom` should be unmapped as a guard page.
+    ///
+    /// # Safety
+    ///
+    /// This is unsafe because there is no validation of the given pointer.
+    ///
+    /// The caller must properly allocate the stack space with a guard page and
+    /// make the pages accessible for correct behavior.
+    pub unsafe fn from_raw_parts(bottom: *mut u8, len: usize) -> io::Result<Self> {
+        Ok(Self(imp::FiberStack::from_raw_parts(bottom, len)?))
+    }
+
+    /// Gets the top of the stack.
+    ///
+    /// Returns `None` if the platform does not support getting the top of the
+    /// stack.
+    pub fn top(&self) -> Option<*mut u8> {
+        self.0.top()
+    }
+
+    pub unsafe fn parent(&self) -> *mut u8 {
+        self.0.parent()
+    }
+
+    pub unsafe fn write_parent(&self, tsp: *mut u8) {
+        self.0.write_parent(tsp);
+    }
+
+    /// Returns the range of where this stack resides in memory if the platform
+    /// supports it.
+    pub fn range(&self) -> Option<Range<usize>> {
+        self.0.range()
+    }
+}
+
+pub struct Fiber<'a, Resume, Yield, Return> {
+    stack: FiberStack,
+    inner: imp::Fiber,
+    done: Cell<bool>,
+    _phantom: PhantomData<&'a (Resume, Yield, Return)>,
+}
+
+pub struct Suspend<Resume, Yield, Return> {
+    inner: imp::Suspend,
+    _phantom: PhantomData<(Resume, Yield, Return)>,
+}
+
+pub enum RunResult<Resume, Yield, Return> {
+    Executing,
+    Resuming(Resume),
+    Yield(Yield),
+    Returned(Return),
+    Panicked(Box<dyn Any + Send>),
+}
+
+impl<'a, Resume, Yield, Return> Fiber<'a, Resume, Yield, Return> {
+    /// Creates a new fiber which will execute `func` on the given stack.
+    ///
+    /// This function returns a `Fiber` which, when resumed, will execute `func`
+    /// to completion. When desired the `func` can suspend itself via
+    /// `Fiber::suspend`.
+    pub fn new(
+        stack: FiberStack,
+        func: impl FnOnce(Resume, &Suspend<Resume, Yield, Return>) -> Return + 'a,
+    ) -> io::Result<Self> {
+        let inner = imp::Fiber::new(&stack.0, func)?;
+
+        Ok(Self {
+            stack,
+            inner,
+            done: Cell::new(false),
+            _phantom: PhantomData,
+        })
+    }
+
+    /// Resumes execution of this fiber.
+    ///
+    /// This function will transfer execution to the fiber and resume from where
+    /// it last left off.
+    ///
+    /// Returns `true` if the fiber finished or `false` if the fiber was
+    /// suspended in the middle of execution.
+    ///
+    /// # Panics
+    ///
+    /// Panics if the current thread is already executing a fiber or if this
+    /// fiber has already finished.
+    ///
+    /// Note that if the fiber itself panics during execution then the panic
+    /// will be propagated to this caller.
+    pub fn resume(&self, val: Resume) -> Result<Return, Yield> {
+        assert!(!self.done.replace(true), "cannot resume a finished fiber");
+        let result = Cell::new(RunResult::Resuming(val));
+        self.inner.resume(&self.stack.0, &result);
+        match result.into_inner() {
+            RunResult::Resuming(_) | RunResult::Executing => unreachable!(),
+            RunResult::Yield(y) => {
+                self.done.set(false);
+                Err(y)
+            }
+            RunResult::Returned(r) => Ok(r),
+            RunResult::Panicked(payload) => std::panic::resume_unwind(payload),
+        }
+    }
+
+    /// Returns whether this fiber has finished executing.
+    pub fn done(&self) -> bool {
+        self.done.get()
+    }
+
+    /// Gets the stack associated with this fiber.
+    pub fn stack(&self) -> &FiberStack {
+        &self.stack
+    }
+}
+
+impl<Resume, Yield, Return> Suspend<Resume, Yield, Return> {
+    /// Suspend execution of a currently running fiber.
+    ///
+    /// This function will switch control back to the original caller of
+    /// `Fiber::resume`. This function will then return once the `Fiber::resume`
+    /// function is called again.
+    ///
+    /// # Panics
+    ///
+    /// Panics if the current thread is not executing a fiber from this library.
+    pub fn suspend(&self, value: Yield) -> Resume {
+        self.inner
+            .switch::<Resume, Yield, Return>(RunResult::Yield(value))
+    }
+
+    fn execute(
+        inner: imp::Suspend,
+        initial: Resume,
+        func: impl FnOnce(Resume, &Suspend<Resume, Yield, Return>) -> Return,
+    ) {
+        let suspend = Suspend {
+            inner,
+            _phantom: PhantomData,
+        };
+        let result = panic::catch_unwind(AssertUnwindSafe(|| (func)(initial, &suspend)));
+        suspend.inner.switch::<Resume, Yield, Return>(match result {
+            Ok(result) => RunResult::Returned(result),
+            Err(panic) => RunResult::Panicked(panic),
+        });
+    }
+}
+
+impl<A, B, C> Drop for Fiber<'_, A, B, C> {
+    fn drop(&mut self) {
+        debug_assert!(self.done.get(), "fiber dropped without finishing");
+    }
+}
+
+#[cfg(test)]
+mod tests {
+    use super::{Fiber, FiberStack};
+    use std::cell::Cell;
+    use std::panic::{self, AssertUnwindSafe};
+    use std::rc::Rc;
+
+    #[test]
+    fn small_stacks() {
+        Fiber::<(), (), ()>::new(FiberStack::new(0).unwrap(), |_, _| {})
+            .unwrap()
+            .resume(())
+            .unwrap();
+        Fiber::<(), (), ()>::new(FiberStack::new(1).unwrap(), |_, _| {})
+            .unwrap()
+            .resume(())
+            .unwrap();
+    }
+
+    #[test]
+    fn smoke() {
+        let hit = Rc::new(Cell::new(false));
+        let hit2 = hit.clone();
+        let fiber = Fiber::<(), (), ()>::new(FiberStack::new(1024 * 1024).unwrap(), move |_, _| {
+            hit2.set(true);
+        })
+        .unwrap();
+        assert!(!hit.get());
+        fiber.resume(()).unwrap();
+        assert!(hit.get());
+    }
+
+    #[test]
+    fn suspend_and_resume() {
+        let hit = Rc::new(Cell::new(false));
+        let hit2 = hit.clone();
+        let fiber = Fiber::<(), (), ()>::new(FiberStack::new(1024 * 1024).unwrap(), move |_, s| {
+            s.suspend(());
+            hit2.set(true);
+            s.suspend(());
+        })
+        .unwrap();
+        assert!(!hit.get());
+        assert!(fiber.resume(()).is_err());
+        assert!(!hit.get());
+        assert!(fiber.resume(()).is_err());
+        assert!(hit.get());
+        assert!(fiber.resume(()).is_ok());
+        assert!(hit.get());
+    }
+
+    #[test]
+    fn backtrace_traces_to_host() {
+        #[inline(never)] // try to get this to show up in backtraces
+        fn look_for_me() {
+            run_test();
+        }
+        fn assert_contains_host() {
+            let trace = backtrace::Backtrace::new();
+            println!("{:?}", trace);
+            assert!(
+                trace
+                .frames()
+                .iter()
+                .flat_map(|f| f.symbols())
+                .filter_map(|s| Some(s.name()?.to_string()))
+                .any(|s| s.contains("look_for_me"))
+                // TODO: apparently windows unwind routines don't unwind through fibers, so this will always fail. Is there a way we can fix that?
+                || cfg!(windows)
+                // TODO: the system libunwind is broken (#2808)
+                || cfg!(all(target_os = "macos", target_arch = "aarch64"))
+            );
+        }
+
+        fn run_test() {
+            let fiber =
+                Fiber::<(), (), ()>::new(FiberStack::new(1024 * 1024).unwrap(), move |(), s| {
+                    assert_contains_host();
+                    s.suspend(());
+                    assert_contains_host();
+                    s.suspend(());
+                    assert_contains_host();
+                })
+                .unwrap();
+            assert!(fiber.resume(()).is_err());
+            assert!(fiber.resume(()).is_err());
+            assert!(fiber.resume(()).is_ok());
+        }
+
+        look_for_me();
+    }
+
+    #[test]
+    fn panics_propagated() {
+        let a = Rc::new(Cell::new(false));
+        let b = SetOnDrop(a.clone());
+        let fiber =
+            Fiber::<(), (), ()>::new(FiberStack::new(1024 * 1024).unwrap(), move |(), _s| {
+                let _ = &b;
+                panic!();
+            })
+            .unwrap();
+        assert!(panic::catch_unwind(AssertUnwindSafe(|| fiber.resume(()))).is_err());
+        assert!(a.get());
+
+        struct SetOnDrop(Rc<Cell<bool>>);
+
+        impl Drop for SetOnDrop {
+            fn drop(&mut self) {
+                self.0.set(true);
+            }
+        }
+    }
+
+    #[test]
+    fn suspend_and_resume_values() {
+        let fiber = Fiber::new(FiberStack::new(1024 * 1024).unwrap(), move |first, s| {
+            assert_eq!(first, 2.0);
+            assert_eq!(s.suspend(4), 3.0);
+            "hello".to_string()
+        })
+        .unwrap();
+        assert_eq!(fiber.resume(2.0), Err(4));
+        assert_eq!(fiber.resume(3.0), Ok("hello".to_string()));
+    }
+}
diff --git a/crates/fibre/src/unix.rs b/crates/fibre/src/unix.rs
new file mode 100644
index 000000000..7b5999cff
--- /dev/null
+++ b/crates/fibre/src/unix.rs
@@ -0,0 +1,225 @@
+//! The unix fiber implementation has some platform-specific details
+//! (naturally) but there's a few details of the stack layout which are common
+//! amongst all platforms using this file. Remember that none of this applies to
+//! Windows, which is entirely separate.
+//!
+//! The stack is expected to look pretty standard with a guard page at the end.
+//! Currently allocation happens in this file but this is probably going to be
+//! refactored to happen somewhere else. Otherwise though the stack layout is
+//! expected to look like so:
+//!
+//!
+//! ```text
+//! 0xB000 +-----------------------+   <- top of stack
+//!        | &Cell<RunResult>      |   <- where to store results
+//! 0xAff8 +-----------------------+
+//!        | *const u8             |   <- last sp to resume from
+//! 0xAff0 +-----------------------+   <- 16-byte aligned
+//!        |                       |
+//!        ~        ...            ~   <- actual native stack space to use
+//!        |                       |
+//! 0x1000 +-----------------------+
+//!        |  guard page           |
+//! 0x0000 +-----------------------+
+//! ```
+//!
+//! Here `0xAff8` is filled in temporarily while `resume` is running. The fiber
+//! started with 0xB000 as a parameter so it knows how to find this.
+//! Additionally `resumes` stores state at 0xAff0 to restart execution, and
+//! `suspend`, which has 0xB000 so it can find this, will read that and write
+//! its own resumption information into this slot as well.
+
+#![allow(unused_macros)]
+
+use crate::RunResult;
+use std::alloc::{alloc, dealloc, Layout};
+use std::cell::Cell;
+use std::io;
+use std::ops::Range;
+use std::ptr;
+
+#[derive(Debug)]
+pub struct FiberStack {
+    // The top of the stack; for stacks allocated by the fiber implementation itself,
+    // the base address of the allocation will be `top.sub(len.unwrap())`
+    top: *mut u8,
+    // The length of the stack
+    len: usize,
+    // whether or not this stack was mmap'd
+    mmap: bool,
+}
+
+impl FiberStack {
+    pub fn new(size: usize) -> io::Result<Self> {
+        // Round up our stack size request to the nearest multiple of the
+        // page size.
+        let page_size = rustix::param::page_size();
+        let size = if size == 0 {
+            page_size
+        } else {
+            (size + (page_size - 1)) & (!(page_size - 1))
+        };
+
+        unsafe {
+            // Add in one page for a guard page and then ask for some memory.
+            let mmap_len = size + page_size;
+            let mmap = rustix::mm::mmap_anonymous(
+                ptr::null_mut(),
+                mmap_len,
+                rustix::mm::ProtFlags::empty(),
+                rustix::mm::MapFlags::PRIVATE,
+            )?;
+
+            rustix::mm::mprotect(
+                mmap.cast::<u8>().add(page_size).cast(),
+                size,
+                rustix::mm::MprotectFlags::READ | rustix::mm::MprotectFlags::WRITE,
+            )?;
+
+            Ok(Self {
+                top: mmap.cast::<u8>().add(mmap_len),
+                len: mmap_len,
+                mmap: true,
+            })
+        }
+    }
+
+    pub fn malloc(size: usize) -> io::Result<Self> {
+        unsafe {
+            let layout = Layout::array::<u8>(size).unwrap();
+            let base = alloc(layout);
+            FiberStack::from_raw_parts(base, size)
+        }
+    }
+
+    pub unsafe fn from_raw_parts(base: *mut u8, len: usize) -> io::Result<Self> {
+        Ok(Self {
+            top: base.add(len),
+            len,
+            mmap: false,
+        })
+    }
+
+    pub fn top(&self) -> Option<*mut u8> {
+        Some(self.top)
+    }
+
+    pub unsafe fn parent(&self) -> *mut u8 {
+        self.top.cast::<*mut u8>().offset(-2).read()
+    }
+
+    pub unsafe fn write_parent(&self, tsp: *mut u8) {
+        self.top.cast::<*mut u8>().offset(-2).write(tsp);
+    }
+
+    pub fn range(&self) -> Option<Range<usize>> {
+        let base = unsafe { self.top.sub(self.len) as usize };
+        Some(base..base + self.len)
+    }
+}
+
+impl Drop for FiberStack {
+    fn drop(&mut self) {
+        unsafe {
+            if self.mmap {
+                let ret = rustix::mm::munmap(self.top.sub(self.len) as _, self.len);
+                debug_assert!(ret.is_ok());
+            } else {
+                let layout = Layout::array::<u8>(self.len).unwrap();
+                dealloc(self.top.sub(self.len), layout);
+            }
+        }
+    }
+}
+
+pub struct Fiber;
+
+pub struct Suspend(*mut u8);
+
+extern "C" {
+    fn wasmtime_fibre_init(
+        top_of_stack: *mut u8,
+        entry: extern "C" fn(*mut u8, *mut u8),
+        entry_arg0: *mut u8,
+    );
+    fn wasmtime_fibre_switch(top_of_stack: *mut u8);
+    #[allow(dead_code)] // only used in inline assembly for some platforms
+    fn wasmtime_fibre_start();
+}
+
+extern "C" fn fiber_start<F, A, B, C>(arg0: *mut u8, top_of_stack: *mut u8)
+where
+    F: FnOnce(A, &super::Suspend<A, B, C>) -> C,
+{
+    unsafe {
+        let inner = Suspend(top_of_stack);
+        let initial = inner.take_resume::<A, B, C>();
+        super::Suspend::<A, B, C>::execute(inner, initial, Box::from_raw(arg0.cast::<F>()))
+    }
+}
+
+impl Fiber {
+    pub fn new<F, A, B, C>(stack: &FiberStack, func: F) -> io::Result<Self>
+    where
+        F: FnOnce(A, &super::Suspend<A, B, C>) -> C,
+    {
+        unsafe {
+            let data = Box::into_raw(Box::new(func)).cast();
+            wasmtime_fibre_init(stack.top, fiber_start::<F, A, B, C>, data);
+        }
+
+        Ok(Self)
+    }
+
+    pub(crate) fn resume<A, B, C>(&self, stack: &FiberStack, result: &Cell<RunResult<A, B, C>>) {
+        unsafe {
+            // Store where our result is going at the very tip-top of the
+            // stack, otherwise known as our reserved slot for this information.
+            //
+            // In the diagram above this is updating address 0xAff8
+            let addr = stack.top.cast::<usize>().offset(-1);
+            addr.write(result as *const _ as usize);
+
+            wasmtime_fibre_switch(stack.top);
+
+            // null this out to help catch use-after-free
+            addr.write(0);
+        }
+    }
+}
+
+impl Suspend {
+    pub fn switch<A, B, C>(&self, result: RunResult<A, B, C>) -> A {
+        unsafe {
+            // Calculate 0xAff8 and then write to it
+            (*self.result_location::<A, B, C>()).set(result);
+            wasmtime_fibre_switch(self.0);
+            self.take_resume::<A, B, C>()
+        }
+    }
+
+    unsafe fn take_resume<A, B, C>(&self) -> A {
+        match (*self.result_location::<A, B, C>()).replace(RunResult::Executing) {
+            RunResult::Resuming(val) => val,
+            _ => panic!("not in resuming state"),
+        }
+    }
+
+    unsafe fn result_location<A, B, C>(&self) -> *const Cell<RunResult<A, B, C>> {
+        let ret = self.0.cast::<*const u8>().offset(-1).read();
+        assert!(!ret.is_null());
+        ret.cast()
+    }
+
+    pub fn from_top_ptr(ptr: *mut u8) -> Self {
+        Suspend(ptr)
+    }
+}
+
+cfg_if::cfg_if! {
+    if #[cfg(target_arch = "x86_64")] {
+        mod x86_64;
+    } else {
+        compile_error!("fibers are not supported on this CPU architecture");
+    }
+}
diff --git a/crates/fibre/src/unix/x86_64.rs b/crates/fibre/src/unix/x86_64.rs
new file mode 100644
index 000000000..ca22a9a99
--- /dev/null
+++ b/crates/fibre/src/unix/x86_64.rs
@@ -0,0 +1,160 @@
+// A WORD OF CAUTION
+//
+// This entire file basically needs to be kept in sync with itself. It's not
+// really possible to modify just one bit of this file without understanding
+// all the other bits. Documentation tries to reference various bits here and
+// there but try to make sure to read over everything before tweaking things!
+
+use wasmtime_asm_macros::asm_func;
+
+// fn(top_of_stack(rdi): *mut u8)
+asm_func!(
+    "wasmtime_fibre_switch",
+    "
+        // We're switching to arbitrary code somewhere else, so pessimistically
+        // assume that all callee-save register are clobbered. This means we need
+        // to save/restore all of them.
+        //
+        // Note that this order for saving is important since we use CFI directives
+        // below to point to where all the saved registers are.
+        push rbp
+        push rbx
+        push r12
+        push r13
+        push r14
+        push r15
+
+        // Load pointer that we're going to resume at and store where we're going
+        // to get resumed from. This is in accordance with the diagram at the top
+        // of unix.rs.
+        mov rax, -0x20[rdi]
+        mov -0x20[rdi], rsp
+
+        // Swap stacks and restore all our callee-saved registers
+        mov rsp, rax
+        pop r15
+        pop r14
+        pop r13
+        pop r12
+        pop rbx
+        pop rbp
+        ret
+    ",
+);
+
+// fn(
+//    top_of_stack(rdi): *mut u8,
+//    entry_point(rsi): extern fn(*mut u8, *mut u8),
+//    entry_arg0(rdx): *mut u8,
+// )
+#[rustfmt::skip]
+asm_func!(
+    "wasmtime_fibre_init",
+    "
+        // Here we're going to set up a stack frame as expected by
+        // `wasmtime_fibre_switch`. The values we store here will get restored into
+        // registers by that function and the `wasmtime_fibre_start` function will
+        // take over and understands which values are in which registers.
+        //
+        // The first 16 bytes of stack are reserved for metadata, so we start
+        // storing values beneath that.
+        lea rax, {start}[rip]
+        mov -0x28[rdi], rax
+        mov -0x30[rdi], rdi   // loaded into rbp during switch
+        mov -0x38[rdi], rsi   // loaded into rbx during switch
+        mov -0x40[rdi], rdx   // loaded into r12 during switch
+
+        // And then we specify the stack pointer resumption should begin at. Our
+        // `wasmtime_fibre_switch` function consumes 6 registers plus a return
+        // pointer, and the top 32 bytes are reserved, so that's:
+        //
+        //	(6 + 1) * 16 + 32 = 0x58
+        lea rax, -0x58[rdi]
+        mov -0x20[rdi], rax
+        ret
+    ",
+    start = sym super::wasmtime_fibre_start,
+);
+
+// This is a pretty special function that has no real signature. Its use is to
+// be the "base" function of all fibers. This entrypoint is used in
+// `wasmtime_fibre_init` to bootstrap the execution of a new fiber.
+//
+// We also use this function as a persistent frame on the stack to emit dwarf
+// information to unwind into the caller. This allows us to unwind from the
+// fiber's stack back to the main stack that the fiber was called from. We use
+// special dwarf directives here to do so since this is a pretty nonstandard
+// function.
+//
+// If you're curious a decent introduction to CFI things and unwinding is at
+// https://www.imperialviolet.org/2017/01/18/cfi.html
+asm_func!(
+    "wasmtime_fibre_start",
+    "
+        // Use the `simple` directive on the startproc here which indicates that
+        // some default settings for the platform are omitted, since this
+        // function is so nonstandard
+        .cfi_startproc simple
+        .cfi_def_cfa_offset 0
+
+        // This is where things get special, we're specifying a custom dwarf
+        // expression for how to calculate the CFA. The goal here is that we
+        // need to load the parent's stack pointer just before the call it made
+        // into `wasmtime_fibre_switch`. Note that the CFA value changes over
+        // time as well because a fiber may be resumed multiple times from
+        // different points on the original stack. This means that our custom
+        // CFA directive involves `DW_OP_deref`, which loads data from memory.
+        //
+        // The expression we're encoding here is that the CFA, the stack pointer
+        // of whatever called into `wasmtime_fibre_start`, is:
+        //
+        //        *$rsp + 0x38
+        //
+        // $rsp is the stack pointer of `wasmtime_fibre_start` at the time the
+        // next instruction after the `.cfi_escape` is executed. Our $rsp at the
+        // start of this function is 16 bytes below the top of the stack (0xAff0
+        // in the diagram in unix.rs). The $rsp to resume at is stored at that
+        // location, so we dereference the stack pointer to load it.
+        //
+        // After dereferencing, though, we have the $rsp value for
+        // `wasmtime_fibre_switch` itself. That's a weird function which sort of
+        // and sort of doesn't exist on the stack.  We want to point to the
+        // caller of `wasmtime_fibre_switch`, so to do that we need to skip the
+        // stack space reserved by `wasmtime_fibre_switch`, which is the 6 saved
+        // registers plus the return address of the caller's `call` instruction.
+        // Hence we offset another 0x38 bytes.
+        .cfi_escape 0x0f, /* DW_CFA_def_cfa_expression */ \
+            4,            /* the byte length of this expression */ \
+            0x57,         /* DW_OP_reg7 (rsp) */ \
+            0x06,         /* DW_OP_deref */ \
+            0x23, 0x38    /* DW_OP_plus_uconst 0x38 */
+
+        // And now after we've indicated where our CFA is for our parent
+        // function, we can define that where all of the saved registers are
+        // located. This uses standard `.cfi` directives which indicate that
+        // these registers are all stored relative to the CFA. Note that this
+        // order is kept in sync with the above register spills in
+        // `wasmtime_fibre_switch`.
+        .cfi_rel_offset rip, -8
+        .cfi_rel_offset rbp, -16
+        .cfi_rel_offset rbx, -24
+        .cfi_rel_offset r12, -32
+        .cfi_rel_offset r13, -40
+        .cfi_rel_offset r14, -48
+        .cfi_rel_offset r15, -56
+
+        // The body of this function is pretty similar. All our parameters are
+        // already loaded into registers by the switch function. The
+        // `wasmtime_fibre_init` routine arranged the various values to be
+        // materialized into the registers used here. Our job is to then move
+        // the values into the ABI-defined registers and call the entry-point.
+        // Note that `call` is used here to leave this frame on the stack so we
+        // can use the dwarf info here for unwinding. The trailing `ud2` is just
+        // for safety.
+        mov rdi, r12
+        mov rsi, rbp
+        call rbx
+        ud2
+        .cfi_endproc
+    ",
+);
diff --git a/crates/fibre/src/windows.c b/crates/fibre/src/windows.c
new file mode 100644
index 000000000..9e017f9b0
--- /dev/null
+++ b/crates/fibre/src/windows.c
@@ -0,0 +1,5 @@
+#include <windows.h>
+
+LPVOID wasmtime_fiber_get_current() {
+   return GetCurrentFiber();
+}
diff --git a/crates/fibre/src/windows.rs b/crates/fibre/src/windows.rs
new file mode 100644
index 000000000..303b95107
--- /dev/null
+++ b/crates/fibre/src/windows.rs
@@ -0,0 +1,165 @@
+use crate::RunResult;
+use std::cell::Cell;
+use std::ffi::c_void;
+use std::io;
+use std::ops::Range;
+use std::ptr;
+use windows_sys::Win32::Foundation::*;
+use windows_sys::Win32::System::Threading::*;
+
+#[derive(Debug)]
+pub struct FiberStack(usize);
+
+impl FiberStack {
+    pub fn new(size: usize) -> io::Result<Self> {
+        Ok(Self(size))
+    }
+
+    pub fn malloc(_size: usize) -> io::Result<Self> {
+        unimplemented!()
+    }
+
+    pub unsafe fn from_raw_parts(_base: *mut u8, _len: usize) -> io::Result<Self> {
+        Err(io::Error::from_raw_os_error(ERROR_NOT_SUPPORTED as i32))
+    }
+
+    pub fn top(&self) -> Option<*mut u8> {
+        None
+    }
+
+    pub fn range(&self) -> Option<Range<usize>> {
+        None
+    }
+}
+
+pub struct Fiber {
+    fiber: *mut c_void,
+    state: Box<StartState>,
+}
+
+pub struct Suspend {
+    state: *const StartState,
+}
+
+struct StartState {
+    parent: Cell<*mut c_void>,
+    initial_closure: Cell<*mut u8>,
+    result_location: Cell<*const u8>,
+}
+
+const FIBER_FLAG_FLOAT_SWITCH: u32 = 1;
+
+extern "C" {
+    fn wasmtime_fiber_get_current() -> *mut c_void;
+}
+
+unsafe extern "system" fn fiber_start<F, A, B, C>(data: *mut c_void)
+where
+    F: FnOnce(A, &super::Suspend<A, B, C>) -> C,
+{
+    // Set the stack guarantee to be consistent with what Rust expects for threads
+    // This value is taken from:
+    // https://github.com/rust-lang/rust/blob/0d97f7a96877a96015d70ece41ad08bb7af12377/library/std/src/sys/windows/stack_overflow.rs
+    if SetThreadStackGuarantee(&mut 0x5000) == 0 {
+        panic!("failed to set fiber stack guarantee");
+    }
+
+    let state = data.cast::<StartState>();
+    let func = Box::from_raw((*state).initial_closure.get().cast::<F>());
+    (*state).initial_closure.set(ptr::null_mut());
+    let suspend = Suspend { state };
+    let initial = suspend.take_resume::<A, B, C>();
+    super::Suspend::<A, B, C>::execute(suspend, initial, *func);
+}
+
+impl Fiber {
+    pub fn new<F, A, B, C>(stack: &FiberStack, func: F) -> io::Result<Self>
+    where
+        F: FnOnce(A, &super::Suspend<A, B, C>) -> C,
+    {
+        unsafe {
+            let state = Box::new(StartState {
+                initial_closure: Cell::new(Box::into_raw(Box::new(func)).cast()),
+                parent: Cell::new(ptr::null_mut()),
+                result_location: Cell::new(ptr::null()),
+            });
+
+            let fiber = CreateFiberEx(
+                0,
+                stack.0,
+                FIBER_FLAG_FLOAT_SWITCH,
+                Some(fiber_start::<F, A, B, C>),
+                &*state as *const StartState as *mut _,
+            );
+
+            if fiber.is_null() {
+                drop(Box::from_raw(state.initial_closure.get().cast::<F>()));
+                return Err(io::Error::last_os_error());
+            }
+
+            Ok(Self { fiber, state })
+        }
+    }
+
+    pub(crate) fn resume<A, B, C>(&self, _stack: &FiberStack, result: &Cell<RunResult<A, B, C>>) {
+        unsafe {
+            let is_fiber = IsThreadAFiber() != 0;
+            let parent_fiber = if is_fiber {
+                wasmtime_fiber_get_current()
+            } else {
+                ConvertThreadToFiber(ptr::null_mut())
+            };
+            assert!(
+                !parent_fiber.is_null(),
+                "failed to make current thread a fiber"
+            );
+            self.state
+                .result_location
+                .set(result as *const _ as *const _);
+            self.state.parent.set(parent_fiber);
+            SwitchToFiber(self.fiber);
+            self.state.parent.set(ptr::null_mut());
+            self.state.result_location.set(ptr::null());
+            if !is_fiber {
+                let res = ConvertFiberToThread();
+                assert!(res != 0, "failed to convert main thread back");
+            }
+        }
+    }
+}
+
+impl Drop for Fiber {
+    fn drop(&mut self) {
+        unsafe {
+            DeleteFiber(self.fiber);
+        }
+    }
+}
+
+impl Suspend {
+    pub(crate) fn switch<A, B, C>(&self, result: RunResult<A, B, C>) -> A {
+        unsafe {
+            (*self.result_location::<A, B, C>()).set(result);
+            debug_assert!(IsThreadAFiber() != 0);
+            let parent = (*self.state).parent.get();
+            debug_assert!(!parent.is_null());
+            SwitchToFiber(parent);
+            self.take_resume::<A, B, C>()
+        }
+    }
+    unsafe fn take_resume<A, B, C>(&self) -> A {
+        match (*self.result_location::<A, B, C>()).replace(RunResult::Executing) {
+            RunResult::Resuming(val) => val,
+            _ => panic!("not in resuming state"),
+        }
+    }
+
+    unsafe fn result_location<A, B, C>(&self) -> *const Cell<RunResult<A, B, C>> {
+        let ret = (*self.state)
+            .result_location
+            .get()
+            .cast::<Cell<RunResult<A, B, C>>>();
+        assert!(!ret.is_null());
+        return ret;
+    }
+}
diff --git a/crates/fuzzing/Cargo.toml b/crates/fuzzing/Cargo.toml
index 06390fdac..e712834e0 100644
--- a/crates/fuzzing/Cargo.toml
+++ b/crates/fuzzing/Cargo.toml
@@ -32,7 +32,7 @@ wasmi = "0.20.0"
 # though, so we could use that if we wanted. For now though just simplify a bit
 # and don't depend on this on Windows.  The same applies on s390x and riscv.
 [target.'cfg(not(any(windows, target_arch = "s390x", target_arch = "riscv64")))'.dependencies]
-v8 = "0.74.1"
+v8 = "0.44.3"
 
 [dev-dependencies]
 wat = { workspace = true }
diff --git a/crates/jit-debug/Cargo.toml b/crates/jit-debug/Cargo.toml
index 85c6b6840..5515be101 100644
--- a/crates/jit-debug/Cargo.toml
+++ b/crates/jit-debug/Cargo.toml
@@ -13,7 +13,6 @@ edition.workspace = true
 [dependencies]
 once_cell = { workspace = true, optional = true }
 object = { workspace = true, optional = true }
-wasmtime-versioned-export-macros = { workspace = true }
 
 [target.'cfg(target_os = "linux")'.dependencies]
 rustix = { workspace = true, features = ["mm", "param", "time"], optional = true }
diff --git a/crates/jit-debug/src/gdb_jit_int.rs b/crates/jit-debug/src/gdb_jit_int.rs
index 87ecd7ee4..e887cddb0 100644
--- a/crates/jit-debug/src/gdb_jit_int.rs
+++ b/crates/jit-debug/src/gdb_jit_int.rs
@@ -6,7 +6,6 @@ use once_cell::sync::Lazy;
 use std::pin::Pin;
 use std::ptr;
 use std::sync::Mutex;
-use wasmtime_versioned_export_macros::versioned_link;
 
 #[repr(C)]
 struct JITCodeEntry {
@@ -29,7 +28,6 @@ struct JITDescriptor {
 }
 
 extern "C" {
-    #[versioned_link]
     fn wasmtime_jit_debug_descriptor() -> *mut JITDescriptor;
     fn __jit_debug_register_code();
 }
diff --git a/crates/jit/src/profiling.rs b/crates/jit/src/profiling.rs
index d816d65f8..22f53f521 100644
--- a/crates/jit/src/profiling.rs
+++ b/crates/jit/src/profiling.rs
@@ -20,7 +20,7 @@ cfg_if::cfg_if! {
 }
 
 cfg_if::cfg_if! {
-    if #[cfg(unix)] {
+    if #[cfg(target_os = "linux")] {
         mod perfmap;
         pub use perfmap::new as new_perfmap;
     } else {
diff --git a/crates/runtime/Cargo.toml b/crates/runtime/Cargo.toml
index 7691495f9..5f727642e 100644
--- a/crates/runtime/Cargo.toml
+++ b/crates/runtime/Cargo.toml
@@ -14,12 +14,12 @@ edition.workspace = true
 wasmtime-asm-macros = { workspace = true }
 wasmtime-environ = { workspace = true }
 wasmtime-fiber = { workspace = true, optional = true }
+wasmtime-fibre = { workspace = true }
 wasmtime-jit-debug = { workspace = true, features = ["gdb_jit_int"] }
-wasmtime-versioned-export-macros = { workspace = true }
 libc = { version = "0.2.112", default-features = false }
 log = { workspace = true }
 memoffset = "0.8.0"
-indexmap = { workspace = true }
+indexmap = "1.0.2"
 cfg-if = { workspace = true }
 rand = { version = "0.8.3", features = ['small_rng'] }
 anyhow = { workspace = true }
@@ -51,7 +51,6 @@ once_cell = { workspace = true }
 
 [build-dependencies]
 cc = "1.0"
-wasmtime-versioned-export-macros = { workspace = true }
 
 [features]
 async = ["wasmtime-fiber"]
@@ -68,3 +67,5 @@ component-model = [
   "wasmtime-environ/component-model",
   "dep:encoding_rs",
 ]
+
+unsafe_disable_continuation_linearity_check = []
\ No newline at end of file
diff --git a/crates/runtime/build.rs b/crates/runtime/build.rs
index 571f0c4b2..5cf6326b3 100644
--- a/crates/runtime/build.rs
+++ b/crates/runtime/build.rs
@@ -1,5 +1,4 @@
 use std::env;
-use wasmtime_versioned_export_macros::versioned_suffix;
 
 fn main() {
     let mut build = cc::Build::new();
@@ -8,7 +7,6 @@ fn main() {
     let os = env::var("CARGO_CFG_TARGET_OS").unwrap();
     build.define(&format!("CFG_TARGET_OS_{}", os), None);
     build.define(&format!("CFG_TARGET_ARCH_{}", arch), None);
-    build.define("VERSIONED_SUFFIX", Some(versioned_suffix!()));
     if arch == "s390x" {
         println!("cargo:rerun-if-changed=src/trampolines/s390x.S");
         build.file("src/trampolines/s390x.S");
diff --git a/crates/runtime/src/component/transcode.rs b/crates/runtime/src/component/transcode.rs
index e67b87a0b..5c007c8df 100644
--- a/crates/runtime/src/component/transcode.rs
+++ b/crates/runtime/src/component/transcode.rs
@@ -29,6 +29,7 @@ macro_rules! define_transcoders {
             $(
                 $name: unsafe extern "C" fn(
                     $(define_transcoders!(@ty $param),)*
+                    $(define_transcoders!(@retptr $result),)?
                 ) $( -> define_transcoders!(@ty $result))?,
             )*
         }
@@ -41,9 +42,12 @@ macro_rules! define_transcoders {
     };
 
     (@ty size) => (usize);
+    (@ty size_pair) => (usize);
     (@ty ptr_u8) => (*mut u8);
     (@ty ptr_u16) => (*mut u16);
-    (@ty ptr_size) => (*mut usize);
+
+    (@retptr size_pair) => (*mut usize);
+    (@retptr size) => (());
 }
 
 wasmtime_environ::foreach_transcoder!(define_transcoders);
@@ -64,6 +68,10 @@ mod trampolines {
             $(
                 pub unsafe extern "C" fn $name(
                     $($pname : define_transcoders!(@ty $param),)*
+                    // If a result is given then a `size_pair` results gets its
+                    // second result value passed via a return pointer here, so
+                    // optionally indicate a return pointer.
+                    $(_retptr: define_transcoders!(@retptr $result))?
                 ) $( -> define_transcoders!(@ty $result))? {
                     $(transcoders!(@validate_param $pname $param);)*
 
@@ -74,10 +82,10 @@ mod trampolines {
                     // Additionally assume that every function below returns a
                     // `Result` where errors turn into traps.
                     let result = std::panic::catch_unwind(|| {
-                        transcoders!(@invoke $name() $($pname)*)
+                        super::$name($($pname),*)
                     });
                     match result {
-                        Ok(Ok(ret)) => transcoders!(@convert_ret ret $($pname: $param)*),
+                        Ok(Ok(ret)) => transcoders!(@convert_ret ret _retptr $($result)?),
                         Ok(Err(err)) => crate::traphandlers::raise_trap(
                             crate::traphandlers::TrapReason::User {
                                 error: err,
@@ -90,17 +98,13 @@ mod trampolines {
             )*
         );
 
-        // Helper macro to convert a 2-tuple automatically when the last
-        // parameter is a `ptr_size` argument.
-        (@convert_ret $ret:ident) => ($ret);
-        (@convert_ret $ret:ident $retptr:ident: ptr_size) => ({
+        (@convert_ret $ret:ident $retptr:ident) => ($ret);
+        (@convert_ret $ret:ident $retptr:ident size) => ($ret);
+        (@convert_ret $ret:ident $retptr:ident size_pair) => ({
             let (a, b) = $ret;
             *$retptr = b;
             a
         });
-        (@convert_ret $ret:ident $name:ident: $ty:ident $($rest:tt)*) => (
-            transcoders!(@convert_ret $ret $($rest)*)
-        );
 
         (@validate_param $arg:ident ptr_u16) => ({
             // This should already be guaranteed by the canonical ABI and our
@@ -109,20 +113,6 @@ mod trampolines {
             assert!(($arg as usize) % 2 == 0, "unaligned 16-bit pointer");
         });
         (@validate_param $arg:ident $ty:ident) => ();
-
-        // Helper macro to invoke `$m` with all of the tokens passed except for
-        // any argument named `ret2`
-        (@invoke $m:ident ($($args:tt)*)) => (super::$m($($args)*));
-
-        // ignore `ret2`-named arguments
-        (@invoke $m:ident ($($args:tt)*) ret2 $($rest:tt)*) => (
-            transcoders!(@invoke $m ($($args)*) $($rest)*)
-        );
-
-        // move all other arguments into the `$args` list
-        (@invoke $m:ident ($($args:tt)*) $param:ident $($rest:tt)*) => (
-            transcoders!(@invoke $m ($($args)* $param,) $($rest)*)
-        );
     }
 
     wasmtime_environ::foreach_transcoder!(transcoders);
diff --git a/crates/runtime/src/continuation.rs b/crates/runtime/src/continuation.rs
new file mode 100644
index 000000000..1dfca78d0
--- /dev/null
+++ b/crates/runtime/src/continuation.rs
@@ -0,0 +1,376 @@
+//! Continuations TODO
+
+use crate::instance::TopOfStackPointer;
+use crate::vmcontext::{VMArrayCallFunction, VMFuncRef, VMOpaqueContext, ValRaw};
+use crate::{Instance, TrapReason};
+use std::cmp;
+use std::mem;
+use std::ptr;
+use wasmtime_fibre::{Fiber, FiberStack, Suspend};
+
+type ContinuationFiber = Fiber<'static, (), u32, ()>;
+type Yield = Suspend<(), u32, ()>;
+
+struct Payloads {
+    length: usize,
+    capacity: usize,
+    /// This is null if and only if capacity (and thus also `length`) are 0.
+    data: *mut u128,
+}
+
+impl Payloads {
+    fn new(capacity: usize) -> Payloads {
+        let data = if capacity == 0 {
+            ptr::null_mut()
+        } else {
+            let mut args = Vec::with_capacity(capacity);
+            let args_ptr = args.as_mut_ptr();
+            args.leak();
+            args_ptr
+        };
+        return Payloads {
+            length: 0,
+            capacity,
+            data,
+        };
+    }
+
+    fn occupy_next(&mut self, count: usize) -> *mut u128 {
+        let original_length = self.length;
+        assert!(self.length + count <= self.capacity);
+        self.length += count;
+        return unsafe { self.data.offset(original_length as isize) };
+    }
+}
+
+/// Encodes the life cycle of a `ContinuationObject`.
+#[derive(PartialEq)]
+enum State {
+    /// The `ContinuationObject` has been created, but `resume` has never been
+    /// called on it. During this stage, we may add arguments using `cont.bind`.
+    Allocated,
+    /// `resume` has been invoked at least once on the `ContinuationObject`,
+    /// meaning that the function passed to `cont.new` has started executing.
+    /// Note that this state does not indicate whether the execution of this
+    /// function is currently suspended or not.
+    Invoked,
+    /// The function originally passed to `cont.new` has returned normally.
+    /// Note that there is no guarantee that a ContinuationObject will ever
+    /// reach this status, as it may stay suspended until being dropped.
+    Returned,
+}
+
+/// TODO
+#[repr(C)]
+pub struct ContinuationObject {
+    fiber: *mut ContinuationFiber,
+
+    /// Used to store
+    /// 1. The arguments to the function passed to cont.new
+    /// 2. The return values of that function
+    /// Note that this is *not* used for tag payloads.
+    args: Payloads,
+
+    // Once a continuation is suspended, this buffer is used to hold payloads
+    // provided by cont.bind and resume and received at the suspend site.
+    // In particular, this may only be Some when `state` is `Invoked`.
+    tag_return_values: Option<Box<Payloads>>,
+
+    state: State,
+}
+
+/// M:1 Many-to-one mapping. A single ContinuationObject may be
+/// referenced by multiple ContinuationReference, though, only one
+/// ContinuationReference may hold a non-null reference to the object
+/// at a given time.
+#[repr(C)]
+pub struct ContinuationReference(Option<*mut ContinuationObject>);
+
+/// TODO
+#[inline(always)]
+pub fn cont_ref_get_cont_obj(
+    contref: *mut ContinuationReference,
+) -> Result<*mut ContinuationObject, TrapReason> {
+    //FIXME rename to indicate that this invalidates the cont ref
+
+    // If this is enabled, we should never call this function.
+    assert!(!cfg!(
+        feature = "unsafe_disable_continuation_linearity_check"
+    ));
+
+    let contopt = unsafe { contref.as_mut().unwrap().0 };
+    match contopt {
+        None => Err(TrapReason::user_with_backtrace(anyhow::Error::msg(
+            "Continuation is already taken",
+        ))), // TODO(dhil): presumably we can set things up such that
+        // we always read from a non-null reference.
+        Some(contobj) => {
+            unsafe {
+                *contref = ContinuationReference(None);
+            }
+            Ok(contobj as *mut ContinuationObject)
+        }
+    }
+}
+
+/// TODO
+#[inline(always)]
+pub fn cont_obj_get_results(obj: *mut ContinuationObject) -> *mut u128 {
+    assert!(unsafe { (*obj).state == State::Returned });
+    assert!(unsafe { !(*obj).args.data.is_null() });
+    unsafe { (*obj).args.data }
+}
+
+/// TODO
+#[inline(always)]
+pub fn cont_obj_occupy_next_args_slots(
+    obj: *mut ContinuationObject,
+    arg_count: usize,
+) -> *mut u128 {
+    assert!(unsafe { (*obj).state == State::Allocated });
+    let args = &mut unsafe { obj.as_mut() }.unwrap().args;
+    return args.occupy_next(arg_count);
+}
+
+/// TODO
+#[inline(always)]
+pub fn cont_obj_occupy_next_tag_returns_slots(
+    obj: *mut ContinuationObject,
+    arg_count: usize,
+    remaining_arg_count: usize,
+) -> *mut u128 {
+    let obj = unsafe { obj.as_mut().unwrap() };
+    assert!(obj.state == State::Invoked);
+    let payloads = obj
+        .tag_return_values
+        .get_or_insert_with(|| Box::new(Payloads::new(remaining_arg_count)));
+    return payloads.occupy_next(arg_count);
+}
+
+/// TODO
+pub fn cont_obj_get_tag_return_values_buffer(
+    obj: *mut ContinuationObject,
+    expected_value_count: usize,
+) -> *mut u128 {
+    let obj = unsafe { obj.as_mut().unwrap() };
+    assert!(obj.state == State::Invoked);
+
+    let payloads = &mut obj.tag_return_values.as_ref().unwrap();
+    assert_eq!(payloads.length, expected_value_count);
+    assert_eq!(payloads.length, payloads.capacity);
+    assert!(!payloads.data.is_null());
+    return payloads.data;
+}
+
+/// TODO
+pub fn cont_obj_deallocate_tag_return_values_buffer(obj: *mut ContinuationObject) {
+    let obj = unsafe { obj.as_mut().unwrap() };
+    assert!(obj.state == State::Invoked);
+    let payloads: Box<Payloads> = obj.tag_return_values.take().unwrap();
+    let _: Vec<u128> =
+        unsafe { Vec::from_raw_parts((*payloads).data, (*payloads).length, (*payloads).capacity) };
+    obj.tag_return_values = None;
+}
+
+/// TODO
+#[inline(always)]
+pub fn cont_obj_has_state_invoked(obj: *mut ContinuationObject) -> bool {
+    // We use this function to determine whether a contination object is in initialisation mode or
+    // not.
+    // FIXME(frank-emrich) Rename this function to make it clearer that we shouldn't call
+    // it in `Returned` state.
+    assert!(unsafe { (*obj).state != State::Returned });
+
+    return unsafe { (*obj).state == State::Invoked };
+}
+
+/// TODO
+#[inline(always)]
+pub fn new_cont_ref(contobj: *mut ContinuationObject) -> *mut ContinuationReference {
+    // If this is enabled, we should never call this function.
+    assert!(!cfg!(
+        feature = "unsafe_disable_continuation_linearity_check"
+    ));
+
+    let contref = Box::new(ContinuationReference(Some(contobj)));
+    Box::into_raw(contref)
+}
+
+/// TODO
+#[inline(always)]
+pub fn drop_cont_obj(contobj: *mut ContinuationObject) {
+    let contobj: Box<ContinuationObject> = unsafe { Box::from_raw(contobj) };
+    let _: Box<ContinuationFiber> = unsafe { Box::from_raw(contobj.fiber) };
+    unsafe {
+        let _: Vec<u128> = Vec::from_raw_parts(
+            contobj.args.data,
+            contobj.args.length,
+            contobj.args.capacity,
+        );
+    };
+    match contobj.tag_return_values {
+        None => (),
+        Some(payloads) => unsafe {
+            let _: Vec<u128> =
+                Vec::from_raw_parts(payloads.data, payloads.length, payloads.capacity);
+        },
+    }
+}
+
+/// TODO
+pub fn allocate_payload_buffer(instance: &mut Instance, element_count: usize) -> *mut u128 {
+    // In the current design, we allocate a `Vec<u128>` and store a pointer to
+    // it in the `VMContext` payloads pointer slot. We then return the pointer
+    // to the `Vec`'s data, not to the `Vec` itself.
+    // This is mostly for debugging purposes, since the `Vec` stores its size.
+    // Alternatively, we may allocate the buffer ourselves here and store the
+    // pointer directly in the `VMContext`. This would avoid one level of
+    // pointer indirection.
+
+    let payload_ptr =
+        unsafe { instance.get_typed_continuations_payloads_ptr_mut() as *mut *mut Vec<u128> };
+
+    // FIXME(frank-emrich) This doesn't work, yet, because we don't zero-initialize the
+    // payload pointer field in the VMContext, meaning that it may initially contain garbage.
+    // Ensure that there isn't an active payload buffer. If there was, we didn't clean up propertly
+    // assert!(unsafe { (*payload_ptr).is_null() });
+
+    let mut vec = Box::new(Vec::<u128>::with_capacity(element_count));
+
+    let vec_data = (*vec).as_mut_ptr();
+    unsafe {
+        *payload_ptr = Box::into_raw(vec);
+    }
+    return vec_data;
+}
+
+/// TODO
+pub fn deallocate_payload_buffer(instance: &mut Instance, element_count: usize) {
+    let payload_ptr =
+        unsafe { instance.get_typed_continuations_payloads_ptr_mut() as *mut *mut Vec<u128> };
+
+    let vec = unsafe { Box::from_raw(*payload_ptr) };
+
+    // If these don't match something went wrong.
+    assert_eq!(vec.capacity(), element_count);
+
+    unsafe { *payload_ptr = ptr::null_mut() };
+
+    // payload buffer destroyed when `vec` goes out of scope
+}
+
+/// TODO
+pub fn get_payload_buffer(instance: &mut Instance, element_count: usize) -> *mut u128 {
+    let payload_ptr =
+        unsafe { instance.get_typed_continuations_payloads_ptr_mut() as *mut *mut Vec<u128> };
+
+    let vec = unsafe { (*payload_ptr).as_mut().unwrap() };
+
+    // If these don't match something went wrong.
+    assert_eq!(vec.capacity(), element_count);
+
+    let vec_data = vec.as_mut_ptr();
+    return vec_data;
+}
+
+/// TODO
+#[inline(always)]
+pub fn cont_new(
+    instance: &mut Instance,
+    func: *mut u8,
+    param_count: usize,
+    result_count: usize,
+) -> *mut ContinuationObject {
+    let func = func as *mut VMFuncRef;
+    let callee_ctx = unsafe { (*func).vmctx };
+    let caller_ctx = VMOpaqueContext::from_vmcontext(instance.vmctx());
+    let f = unsafe {
+        mem::transmute::<
+            VMArrayCallFunction,
+            unsafe extern "C" fn(*mut VMOpaqueContext, *mut VMOpaqueContext, *mut ValRaw, usize),
+        >((*func).array_call)
+    };
+    let capacity = cmp::max(param_count, result_count);
+
+    let payload = Payloads::new(capacity);
+
+    let args_ptr = payload.data;
+    let fiber = Box::new(
+        Fiber::new(
+            FiberStack::malloc(4096).unwrap(),
+            move |_first_val: (), _suspend: &Yield| unsafe {
+                f(callee_ctx, caller_ctx, args_ptr as *mut ValRaw, capacity)
+            },
+        )
+        .unwrap(),
+    );
+
+    let contobj = Box::new(ContinuationObject {
+        fiber: Box::into_raw(fiber),
+        args: payload,
+        tag_return_values: None,
+        state: State::Allocated,
+    });
+    // TODO(dhil): we need memory clean up of
+    // continuation reference objects.
+    return Box::into_raw(contobj);
+}
+
+/// TODO
+#[inline(always)]
+pub fn resume(
+    instance: &mut Instance,
+    contobj: *mut ContinuationObject,
+) -> Result<u32, TrapReason> {
+    assert!(unsafe { (*contobj).state == State::Allocated || (*contobj).state == State::Invoked });
+    let fiber = unsafe { (*contobj).fiber };
+    let fiber_stack = unsafe { &fiber.as_ref().unwrap().stack() };
+    let tsp = TopOfStackPointer::as_raw(instance.tsp());
+    unsafe { fiber_stack.write_parent(tsp) };
+    instance.set_tsp(TopOfStackPointer::from_raw(fiber_stack.top().unwrap()));
+    unsafe {
+        (*(*(*instance.store()).vmruntime_limits())
+            .stack_limit
+            .get_mut()) = 0
+    };
+    unsafe { (*contobj).state = State::Invoked };
+    // This is to make sure that after we resume from a suspend, we can load the continuation object
+    // to access the tag return values.
+    unsafe {
+        let cont_store_ptr =
+            instance.get_typed_continuations_store_mut() as *mut *mut ContinuationObject;
+        cont_store_ptr.write(contobj)
+    };
+    match unsafe { fiber.as_mut().unwrap().resume(()) } {
+        Ok(()) => {
+            // The result of the continuation was written to the first
+            // entry of the payload store by virtue of using the array
+            // calling trampoline to execute it.
+
+            unsafe { (*contobj).state = State::Returned };
+            Ok(0) // zero value = return normally.
+        }
+        Err(tag) => {
+            // We set the high bit to signal a return via suspend. We
+            // encode the tag into the remainder of the integer.
+            let signal_mask = 0xf000_0000;
+            debug_assert_eq!(tag & signal_mask, 0);
+            unsafe {
+                let cont_store_ptr =
+                    instance.get_typed_continuations_store_mut() as *mut *mut ContinuationObject;
+                cont_store_ptr.write(contobj)
+            };
+            Ok(tag | signal_mask)
+        }
+    }
+}
+
+/// TODO
+#[inline(always)]
+pub fn suspend(instance: &mut Instance, tag_index: u32) {
+    let stack_ptr = TopOfStackPointer::as_raw(instance.tsp());
+    let parent = unsafe { stack_ptr.cast::<*mut u8>().offset(-2).read() };
+    instance.set_tsp(TopOfStackPointer::from_raw(parent));
+    let suspend = wasmtime_fibre::unix::Suspend::from_top_ptr(stack_ptr);
+    suspend.switch::<(), u32, ()>(wasmtime_fibre::RunResult::Yield(tag_index))
+}
diff --git a/crates/runtime/src/debug_builtins.rs b/crates/runtime/src/debug_builtins.rs
index 82ac1cf37..9e7ef295a 100644
--- a/crates/runtime/src/debug_builtins.rs
+++ b/crates/runtime/src/debug_builtins.rs
@@ -3,11 +3,10 @@
 use crate::instance::Instance;
 use crate::vmcontext::VMContext;
 use wasmtime_environ::{EntityRef, MemoryIndex};
-use wasmtime_versioned_export_macros::versioned_export;
 
 static mut VMCTX_AND_MEMORY: (*mut VMContext, usize) = (std::ptr::null_mut(), 0);
 
-#[versioned_export]
+#[no_mangle]
 pub unsafe extern "C" fn resolve_vmctx_memory(ptr: usize) -> *const u8 {
     Instance::from_vmctx(VMCTX_AND_MEMORY.0, |handle| {
         assert!(
@@ -20,7 +19,7 @@ pub unsafe extern "C" fn resolve_vmctx_memory(ptr: usize) -> *const u8 {
     })
 }
 
-#[versioned_export]
+#[no_mangle]
 pub unsafe extern "C" fn resolve_vmctx_memory_ptr(p: *const u32) -> *const u8 {
     let ptr = std::ptr::read(p);
     assert!(
@@ -38,7 +37,7 @@ pub unsafe extern "C" fn resolve_vmctx_memory_ptr(p: *const u32) -> *const u8 {
     })
 }
 
-#[versioned_export]
+#[no_mangle]
 pub unsafe extern "C" fn set_vmctx_memory(vmctx_ptr: *mut VMContext) {
     // TODO multi-memory
     VMCTX_AND_MEMORY = (vmctx_ptr, 0);
diff --git a/crates/runtime/src/helpers.c b/crates/runtime/src/helpers.c
index e3c9bb582..96019669d 100644
--- a/crates/runtime/src/helpers.c
+++ b/crates/runtime/src/helpers.c
@@ -42,11 +42,7 @@ typedef void *platform_jmp_buf[5]; // this is the documented size; see the docs
 
 #endif
 
-#define CONCAT2(a, b) a ## b
-#define CONCAT(a, b) CONCAT2(a , b)
-#define VERSIONED_SYMBOL(a) CONCAT(a, VERSIONED_SUFFIX)
-
-int VERSIONED_SYMBOL(wasmtime_setjmp)(
+int wasmtime_setjmp(
     void **buf_storage,
     void (*body)(void*, void*),
     void *payload,
@@ -60,7 +56,7 @@ int VERSIONED_SYMBOL(wasmtime_setjmp)(
   return 1;
 }
 
-void VERSIONED_SYMBOL(wasmtime_longjmp)(void *JmpBuf) {
+void wasmtime_longjmp(void *JmpBuf) {
   platform_jmp_buf *buf = (platform_jmp_buf*) JmpBuf;
   platform_longjmp(*buf, 1);
 }
@@ -103,6 +99,6 @@ struct JITDescriptor __jit_debug_descriptor = {1, 0, NULL, NULL};
 
 
 
-struct JITDescriptor* VERSIONED_SYMBOL(wasmtime_jit_debug_descriptor)() {
+struct JITDescriptor* wasmtime_jit_debug_descriptor() {
   return &__jit_debug_descriptor;
 }
diff --git a/crates/runtime/src/instance.rs b/crates/runtime/src/instance.rs
index 4e24aec4d..087161f2a 100644
--- a/crates/runtime/src/instance.rs
+++ b/crates/runtime/src/instance.rs
@@ -140,6 +140,9 @@ pub struct Instance {
     /// seems not too bad.
     vmctx_self_reference: SendSyncPtr<VMContext>,
 
+    /// Current top of the stack pointer (tsp)
+    tsp: TopOfStackPointer,
+
     /// Additional context used by compiled wasm code. This field is last, and
     /// represents a dynamically-sized array that extends beyond the nominal
     /// end of the struct (similar to a flexible array member).
@@ -148,6 +151,13 @@ pub struct Instance {
 
 #[allow(clippy::cast_ptr_alignment)]
 impl Instance {
+    pub(crate) fn tsp(&self) -> TopOfStackPointer {
+        self.tsp
+    }
+    pub(crate) fn set_tsp(&mut self, ptr: TopOfStackPointer) {
+        self.tsp = ptr;
+    }
+
     /// Create an instance at the given memory address.
     ///
     /// It is assumed the memory was properly aligned and the
@@ -183,6 +193,7 @@ impl Instance {
                 vmctx_self_reference: SendSyncPtr::new(
                     NonNull::new(ptr.cast::<u8>().add(mem::size_of::<Instance>()).cast()).unwrap(),
                 ),
+                tsp: TopOfStackPointer::null(),
                 vmctx: VMContext {
                     _marker: std::marker::PhantomPinned,
                 },
@@ -1176,6 +1187,16 @@ impl Instance {
         }
         fault
     }
+
+    /// TODO
+    pub unsafe fn get_typed_continuations_store_mut(&mut self) -> *mut u32 {
+        self.vmctx_plus_offset_mut(self.offsets().vmctx_typed_continuations_store())
+    }
+
+    /// TODO
+    pub unsafe fn get_typed_continuations_payloads_ptr_mut(&mut self) -> *mut u32 {
+        self.vmctx_plus_offset_mut(self.offsets().vmctx_typed_continuations_payloads_ptr())
+    }
 }
 
 impl Drop for Instance {
@@ -1207,6 +1228,46 @@ pub struct InstanceHandle {
     instance: Option<SendSyncPtr<Instance>>,
 }
 
+// These are only valid if the `Instance` type is send/sync, hence the
+// assertion below.
+unsafe impl Send for InstanceHandle {}
+unsafe impl Sync for InstanceHandle {}
+
+pub struct TopOfStackPointer {
+    tsp: *mut u8,
+}
+
+impl TopOfStackPointer {
+    pub fn null() -> Self {
+        TopOfStackPointer {
+            tsp: std::ptr::null_mut(),
+        }
+    }
+
+    pub fn as_raw(self) -> *mut u8 {
+        self.tsp
+    }
+
+    pub fn from_raw(tsp: *mut u8) -> Self {
+        TopOfStackPointer { tsp }
+    }
+}
+
+impl Copy for TopOfStackPointer {}
+impl Clone for TopOfStackPointer {
+    fn clone(&self) -> Self {
+        TopOfStackPointer { tsp: self.tsp }
+    }
+}
+
+unsafe impl Send for TopOfStackPointer {}
+unsafe impl Sync for TopOfStackPointer {}
+
+fn _assert_send_sync() {
+    fn _assert<T: Send + Sync>() {}
+    _assert::<Instance>();
+}
+
 impl InstanceHandle {
     /// Creates an "empty" instance handle which internally has a null pointer
     /// to an instance.
diff --git a/crates/runtime/src/lib.rs b/crates/runtime/src/lib.rs
index e23851799..9c071dd09 100644
--- a/crates/runtime/src/lib.rs
+++ b/crates/runtime/src/lib.rs
@@ -46,6 +46,7 @@ mod table;
 mod traphandlers;
 mod vmcontext;
 
+pub mod continuation;
 pub mod debug_builtins;
 pub mod libcalls;
 
diff --git a/crates/runtime/src/libcalls.rs b/crates/runtime/src/libcalls.rs
index a4b4db518..62ffa146f 100644
--- a/crates/runtime/src/libcalls.rs
+++ b/crates/runtime/src/libcalls.rs
@@ -91,7 +91,6 @@ pub mod trampolines {
                 extern "C" {
                     #[allow(missing_docs)]
                     #[allow(improper_ctypes)]
-                    #[wasmtime_versioned_export_macros::versioned_link]
                     pub fn $name(
                         vmctx: *mut VMContext,
                         $( $pname: libcall!(@ty $param), )*
@@ -110,7 +109,7 @@ pub mod trampolines {
                 // the `sym` operator to get the symbol here, but other targets
                 // like s390x need to use outlined assembly files which requires
                 // `no_mangle`.
-                #[cfg_attr(target_arch = "s390x", wasmtime_versioned_export_macros::versioned_export)]
+                #[cfg_attr(target_arch = "s390x", no_mangle)]
                 unsafe extern "C" fn [<impl_ $name>](
                     vmctx: *mut VMContext,
                     $( $pname : libcall!(@ty $param), )*
@@ -625,3 +624,112 @@ pub mod relocs {
         }
     }
 }
+
+// Builtins for continuations. These are thin wrappers around the
+// respective definitions in continuation.rs.
+fn cont_new(
+    instance: &mut Instance,
+    func: *mut u8,
+    param_count: u64,
+    result_count: u64,
+) -> *mut u8 {
+    crate::continuation::cont_new(instance, func, param_count as usize, result_count as usize)
+        as *mut u8
+}
+
+fn resume(instance: &mut Instance, contobj: *mut u8) -> Result<u32, TrapReason> {
+    crate::continuation::resume(
+        instance,
+        contobj as *mut crate::continuation::ContinuationObject,
+    )
+}
+
+fn suspend(instance: &mut Instance, tag_index: u32) {
+    crate::continuation::suspend(instance, tag_index)
+}
+
+fn cont_obj_get_results(_instance: &mut Instance, contobj: *mut u8) -> *mut u8 {
+    crate::continuation::cont_obj_get_results(
+        contobj as *mut crate::continuation::ContinuationObject,
+    ) as *mut u8
+}
+
+fn cont_obj_occupy_next_args_slots(
+    _instance: &mut Instance,
+    contobj: *mut u8,
+    arg_count: u32,
+) -> *mut u8 {
+    crate::continuation::cont_obj_occupy_next_args_slots(
+        contobj as *mut crate::continuation::ContinuationObject,
+        arg_count as usize,
+    ) as *mut u8
+}
+
+fn new_cont_ref(_instance: &mut Instance, contobj: *mut u8) -> *mut u8 {
+    crate::continuation::new_cont_ref(contobj as *mut crate::continuation::ContinuationObject)
+        as *mut u8
+}
+
+fn cont_ref_get_cont_obj(
+    _instance: &mut Instance,
+    contref: *mut u8,
+) -> Result<*mut u8, TrapReason> {
+    Ok(crate::continuation::cont_ref_get_cont_obj(
+        contref as *mut crate::continuation::ContinuationReference,
+    )? as *mut u8)
+}
+
+fn cont_obj_has_state_invoked(
+    _instance: &mut Instance,
+    contobj: *mut u8,
+) -> Result<u32, TrapReason> {
+    Ok(crate::continuation::cont_obj_has_state_invoked(
+        contobj as *mut crate::continuation::ContinuationObject,
+    ) as u32)
+}
+
+fn cont_obj_occupy_next_tag_returns_slots(
+    _instance: &mut Instance,
+    contobj: *mut u8,
+    arg_count: u32,
+    remaining_arg_count: u32,
+) -> *mut u8 {
+    crate::continuation::cont_obj_occupy_next_tag_returns_slots(
+        contobj as *mut crate::continuation::ContinuationObject,
+        arg_count as usize,
+        remaining_arg_count as usize,
+    ) as *mut u8
+}
+
+fn cont_obj_get_tag_return_values_buffer(
+    _instance: &mut Instance,
+    contobj: *mut u8,
+    expected_value_count: u32,
+) -> *mut u8 {
+    crate::continuation::cont_obj_get_tag_return_values_buffer(
+        contobj as *mut crate::continuation::ContinuationObject,
+        expected_value_count as usize,
+    ) as *mut u8
+}
+
+fn cont_obj_deallocate_tag_return_values_buffer(_instance: &mut Instance, contobj: *mut u8) {
+    crate::continuation::cont_obj_deallocate_tag_return_values_buffer(
+        contobj as *mut crate::continuation::ContinuationObject,
+    );
+}
+
+fn allocate_payload_buffer(instance: &mut Instance, element_count: u32) -> *mut u8 {
+    crate::continuation::allocate_payload_buffer(instance, element_count as usize) as *mut u8
+}
+
+fn deallocate_payload_buffer(instance: &mut Instance, expected_element_capacity: u32) {
+    crate::continuation::deallocate_payload_buffer(instance, expected_element_capacity as usize);
+}
+
+fn get_payload_buffer(instance: &mut Instance, expected_element_capacity: u32) -> *mut u8 {
+    crate::continuation::get_payload_buffer(instance, expected_element_capacity as usize) as *mut u8
+}
+
+fn drop_cont_obj(_instance: &mut Instance, contobj: *mut u8) {
+    crate::continuation::drop_cont_obj(contobj as *mut crate::continuation::ContinuationObject)
+}
diff --git a/crates/runtime/src/trampolines/aarch64.rs b/crates/runtime/src/trampolines/aarch64.rs
index 29852bad1..80edd8ae5 100644
--- a/crates/runtime/src/trampolines/aarch64.rs
+++ b/crates/runtime/src/trampolines/aarch64.rs
@@ -2,7 +2,7 @@
 macro_rules! wasm_to_libcall_trampoline {
     ($libcall:ident ; $libcall_impl:ident) => {
         wasmtime_asm_macros::asm_func!(
-            wasmtime_versioned_export_macros::versioned_stringify_ident!($libcall),
+            stringify!($libcall),
             "
                 .cfi_startproc
                 bti c
diff --git a/crates/runtime/src/trampolines/riscv64.rs b/crates/runtime/src/trampolines/riscv64.rs
index e3b06863b..456800594 100644
--- a/crates/runtime/src/trampolines/riscv64.rs
+++ b/crates/runtime/src/trampolines/riscv64.rs
@@ -2,7 +2,7 @@
 macro_rules! wasm_to_libcall_trampoline {
     ($libcall:ident ; $libcall_impl:ident) => {
         wasmtime_asm_macros::asm_func!(
-            wasmtime_versioned_export_macros::versioned_stringify_ident!($libcall),
+            stringify!($libcall),
             concat!(
                 "
                     .cfi_startproc
diff --git a/crates/runtime/src/trampolines/s390x.S b/crates/runtime/src/trampolines/s390x.S
index b6b8bf01d..e014e1205 100644
--- a/crates/runtime/src/trampolines/s390x.S
+++ b/crates/runtime/src/trampolines/s390x.S
@@ -9,16 +9,12 @@
         .type host_to_wasm_trampoline,@function
         .p2align 2
 
-#define CONCAT2(a, b) a ## b
-#define CONCAT(a, b) CONCAT2(a , b)
-#define VERSIONED_SYMBOL(a) CONCAT(a, VERSIONED_SUFFIX)
-
 #define LIBCALL_TRAMPOLINE(libcall, libcall_impl)                                 \
-        .hidden VERSIONED_SYMBOL(libcall) ;                                       \
-        .globl VERSIONED_SYMBOL(libcall) ;                                        \
-        .type VERSIONED_SYMBOL(libcall),@function ;                               \
+        .hidden libcall ;                                                         \
+        .globl libcall ;                                                          \
+        .type libcall,@function ;                                                 \
         .p2align 2 ;                                                              \
-VERSIONED_SYMBOL(libcall): ;                                                      \
+libcall: ;                                                                        \
         .cfi_startproc ;                                                          \
                                                                                   \
         /* Load the pointer to `VMRuntimeLimits` in `%r1`.  */                    \
@@ -32,10 +28,10 @@ VERSIONED_SYMBOL(libcall): ;
         stg %r14, 32(%r1) ;                                                       \
                                                                                   \
         /* Tail call to the actual implementation of this libcall.  */            \
-        jg VERSIONED_SYMBOL(libcall_impl) ;                                       \
+        jg libcall_impl ;                                                         \
                                                                                   \
         .cfi_endproc ;                                                            \
-        .size VERSIONED_SYMBOL(libcall),.-VERSIONED_SYMBOL(libcall)
+        .size libcall,.-libcall
 
 LIBCALL_TRAMPOLINE(memory32_grow, impl_memory32_grow)
 LIBCALL_TRAMPOLINE(table_grow_func_ref, impl_table_grow_func_ref)
diff --git a/crates/runtime/src/trampolines/x86_64.rs b/crates/runtime/src/trampolines/x86_64.rs
index d22bcaf1a..d5af4446d 100644
--- a/crates/runtime/src/trampolines/x86_64.rs
+++ b/crates/runtime/src/trampolines/x86_64.rs
@@ -21,7 +21,7 @@ cfg_if::cfg_if! {
 macro_rules! wasm_to_libcall_trampoline {
     ($libcall:ident ; $libcall_impl:ident) => {
         wasmtime_asm_macros::asm_func!(
-            wasmtime_versioned_export_macros::versioned_stringify_ident!($libcall),
+            stringify!($libcall),
             concat!(
                 "
                    .cfi_startproc simple
diff --git a/crates/runtime/src/traphandlers.rs b/crates/runtime/src/traphandlers.rs
index c43c9779f..25d852671 100644
--- a/crates/runtime/src/traphandlers.rs
+++ b/crates/runtime/src/traphandlers.rs
@@ -24,7 +24,6 @@ cfg_if::cfg_if! {
 
         struct WasmtimeLongjmp;
 
-        #[wasmtime_versioned_export_macros::versioned_export]
         unsafe extern "C" fn wasmtime_setjmp(
             _jmp_buf: *mut *const u8,
             callback: extern "C" fn(*mut u8, *mut VMContext),
@@ -47,14 +46,12 @@ cfg_if::cfg_if! {
             }
         }
 
-        #[wasmtime_versioned_export_macros::versioned_export]
         unsafe extern "C" fn wasmtime_longjmp(_jmp_buf: *const u8) -> ! {
             std::panic::panic_any(WasmtimeLongjmp)
         }
     } else {
         #[link(name = "wasmtime-helpers")]
         extern "C" {
-            #[wasmtime_versioned_export_macros::versioned_link]
             #[allow(improper_ctypes)]
             fn wasmtime_setjmp(
                 jmp_buf: *mut *const u8,
@@ -62,7 +59,6 @@ cfg_if::cfg_if! {
                 payload: *mut u8,
                 callee: *mut VMContext,
             ) -> i32;
-            #[wasmtime_versioned_export_macros::versioned_link]
             fn wasmtime_longjmp(jmp_buf: *const u8) -> !;
         }
     }
diff --git a/crates/test-programs/tests/command.rs b/crates/test-programs/tests/command.rs
index 3473a7c9d..f16f14405 100644
--- a/crates/test-programs/tests/command.rs
+++ b/crates/test-programs/tests/command.rs
@@ -9,11 +9,11 @@ use wasmtime::{
     Config, Engine, Store,
 };
 use wasmtime_wasi::preview2::{
-    clocks::{HostMonotonicClock, HostWallClock},
+    clocks::{WasiMonotonicClock, WasiWallClock},
     pipe::ReadPipe,
     wasi::command::add_to_linker,
     wasi::command::Command,
-    DirPerms, FilePerms, Table, WasiCtx, WasiCtxBuilder, WasiView,
+    DirPerms, FilePerms, Table, WasiClocks, WasiCtx, WasiCtxBuilder, WasiView,
 };
 
 lazy_static::lazy_static! {
@@ -131,7 +131,7 @@ async fn random() -> Result<()> {
 async fn time() -> Result<()> {
     struct FakeWallClock;
 
-    impl HostWallClock for FakeWallClock {
+    impl WasiWallClock for FakeWallClock {
         fn resolution(&self) -> Duration {
             Duration::from_secs(1)
         }
@@ -145,7 +145,7 @@ async fn time() -> Result<()> {
         now: Mutex<u64>,
     }
 
-    impl HostMonotonicClock for FakeMonotonicClock {
+    impl WasiMonotonicClock for FakeMonotonicClock {
         fn resolution(&self) -> u64 {
             1_000_000_000
         }
@@ -160,8 +160,10 @@ async fn time() -> Result<()> {
 
     let mut table = Table::new();
     let wasi = WasiCtxBuilder::new()
-        .set_monotonic_clock(FakeMonotonicClock { now: Mutex::new(0) })
-        .set_wall_clock(FakeWallClock)
+        .set_clocks(WasiClocks {
+            wall: Box::new(FakeWallClock),
+            monotonic: Box::new(FakeMonotonicClock { now: Mutex::new(0) }),
+        })
         .build(&mut table)?;
 
     let (mut store, command) =
diff --git a/crates/versioned-export-macros/Cargo.toml b/crates/versioned-export-macros/Cargo.toml
deleted file mode 100644
index e8e331823..000000000
--- a/crates/versioned-export-macros/Cargo.toml
+++ /dev/null
@@ -1,18 +0,0 @@
-[package]
-authors = ["The Wasmtime Project Developers"]
-description = "Macros for defining versioned exports in Wasmtime"
-edition.workspace = true
-license = "Apache-2.0 WITH LLVM-exception"
-name = "wasmtime-versioned-export-macros"
-repository = "https://github.com/bytecodealliance/wasmtime"
-version.workspace = true
-
-# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
-
-[dependencies]
-syn = { version = "2.0", features = ["full"] }
-quote = "1.0"
-proc-macro2 = "1.0"
-
-[lib]
-proc-macro = true
diff --git a/crates/versioned-export-macros/src/lib.rs b/crates/versioned-export-macros/src/lib.rs
deleted file mode 100644
index 065a0fc50..000000000
--- a/crates/versioned-export-macros/src/lib.rs
+++ /dev/null
@@ -1,66 +0,0 @@
-//! This crate defines macros to easily define and use functions with a
-//! versioned suffix, to facilitate using multiple versions of the same
-//! crate that generate assembly.
-
-use quote::ToTokens;
-
-const VERSION: &str = env!("CARGO_PKG_VERSION");
-
-fn version(value: impl std::fmt::Display) -> String {
-    format!("{}_{}", value, VERSION.replace('.', "_"))
-}
-
-fn versioned_lit_str(value: impl std::fmt::Display) -> syn::LitStr {
-    syn::LitStr::new(version(value).as_str(), proc_macro2::Span::call_site())
-}
-
-#[proc_macro_attribute]
-pub fn versioned_export(
-    _attr: proc_macro::TokenStream,
-    item: proc_macro::TokenStream,
-) -> proc_macro::TokenStream {
-    let mut function = syn::parse_macro_input!(item as syn::ItemFn);
-
-    let export_name = versioned_lit_str(&function.sig.ident);
-    function
-        .attrs
-        .push(syn::parse_quote! { #[export_name = #export_name] });
-
-    function.to_token_stream().into()
-}
-
-#[proc_macro_attribute]
-pub fn versioned_link(
-    _attr: proc_macro::TokenStream,
-    item: proc_macro::TokenStream,
-) -> proc_macro::TokenStream {
-    let mut function = syn::parse_macro_input!(item as syn::ForeignItemFn);
-
-    let link_name = versioned_lit_str(&function.sig.ident);
-    function
-        .attrs
-        .push(syn::parse_quote! { #[link_name = #link_name] });
-
-    function.to_token_stream().into()
-}
-
-#[proc_macro]
-pub fn versioned_stringify_ident(item: proc_macro::TokenStream) -> proc_macro::TokenStream {
-    let ident = syn::parse_macro_input!(item as syn::Ident);
-
-    versioned_lit_str(ident).to_token_stream().into()
-}
-
-#[proc_macro]
-pub fn versioned_suffix(item: proc_macro::TokenStream) -> proc_macro::TokenStream {
-    if !item.is_empty() {
-        return syn::Error::new(
-            proc_macro2::Span::call_site(),
-            "`versioned_suffix!` accepts no input",
-        )
-        .to_compile_error()
-        .into();
-    };
-
-    versioned_lit_str("").to_token_stream().into()
-}
diff --git a/crates/wasi/src/preview2/clocks.rs b/crates/wasi/src/preview2/clocks.rs
index 53bca0507..edfa764c9 100644
--- a/crates/wasi/src/preview2/clocks.rs
+++ b/crates/wasi/src/preview2/clocks.rs
@@ -1,12 +1,17 @@
 pub mod host;
 use cap_std::time::Duration;
 
-pub trait HostWallClock: Send + Sync {
+pub trait WasiWallClock: Send + Sync {
     fn resolution(&self) -> Duration;
     fn now(&self) -> Duration;
 }
 
-pub trait HostMonotonicClock: Send + Sync {
+pub trait WasiMonotonicClock: Send + Sync {
     fn resolution(&self) -> u64;
     fn now(&self) -> u64;
 }
+
+pub struct WasiClocks {
+    pub wall: Box<dyn WasiWallClock + Send + Sync>,
+    pub monotonic: Box<dyn WasiMonotonicClock + Send + Sync>,
+}
diff --git a/crates/wasi/src/preview2/clocks/host.rs b/crates/wasi/src/preview2/clocks/host.rs
index e0c9906c7..965f7a4a4 100644
--- a/crates/wasi/src/preview2/clocks/host.rs
+++ b/crates/wasi/src/preview2/clocks/host.rs
@@ -1,4 +1,4 @@
-use super::{HostMonotonicClock, HostWallClock};
+use super::{WasiClocks, WasiMonotonicClock, WasiWallClock};
 use cap_std::time::{Duration, Instant, SystemClock};
 use cap_std::{ambient_authority, AmbientAuthority};
 use cap_time_ext::{MonotonicClockExt, SystemClockExt};
@@ -16,7 +16,7 @@ impl WallClock {
     }
 }
 
-impl HostWallClock for WallClock {
+impl WasiWallClock for WallClock {
     fn resolution(&self) -> Duration {
         self.clock.resolution()
     }
@@ -47,7 +47,7 @@ impl MonotonicClock {
     }
 }
 
-impl HostMonotonicClock for MonotonicClock {
+impl WasiMonotonicClock for MonotonicClock {
     fn resolution(&self) -> u64 {
         self.clock.resolution().as_nanos().try_into().unwrap()
     }
@@ -64,10 +64,10 @@ impl HostMonotonicClock for MonotonicClock {
     }
 }
 
-pub fn monotonic_clock() -> Box<dyn HostMonotonicClock + Send + Sync> {
-    Box::new(MonotonicClock::new(ambient_authority()))
-}
+pub fn clocks_ctx() -> WasiClocks {
+    // Create the per-instance clock resources.
+    let monotonic = Box::new(MonotonicClock::new(ambient_authority()));
+    let wall = Box::new(WallClock::new(ambient_authority()));
 
-pub fn wall_clock() -> Box<dyn HostWallClock + Send + Sync> {
-    Box::new(WallClock::new(ambient_authority()))
+    WasiClocks { monotonic, wall }
 }
diff --git a/crates/wasi/src/preview2/ctx.rs b/crates/wasi/src/preview2/ctx.rs
index ab5109afa..681d4860b 100644
--- a/crates/wasi/src/preview2/ctx.rs
+++ b/crates/wasi/src/preview2/ctx.rs
@@ -1,5 +1,5 @@
 use crate::preview2::{
-    clocks::{self, HostMonotonicClock, HostWallClock},
+    clocks::{self, WasiClocks},
     filesystem::{Dir, TableFsExt},
     pipe, random, stdio,
     stream::{InputStream, OutputStream, TableStreamExt},
@@ -7,8 +7,6 @@ use crate::preview2::{
 };
 use cap_rand::{Rng, RngCore, SeedableRng};
 
-use super::clocks::host::{monotonic_clock, wall_clock};
-
 pub struct WasiCtxBuilder {
     stdin: Box<dyn InputStream>,
     stdout: Box<dyn OutputStream>,
@@ -20,8 +18,7 @@ pub struct WasiCtxBuilder {
     random: Box<dyn RngCore + Send + Sync>,
     insecure_random: Box<dyn RngCore + Send + Sync>,
     insecure_random_seed: u128,
-    wall_clock: Box<dyn HostWallClock + Send + Sync>,
-    monotonic_clock: Box<dyn HostMonotonicClock + Send + Sync>,
+    clocks: WasiClocks,
 }
 
 impl WasiCtxBuilder {
@@ -46,8 +43,7 @@ impl WasiCtxBuilder {
             random: random::thread_rng(),
             insecure_random,
             insecure_random_seed,
-            wall_clock: wall_clock(),
-            monotonic_clock: monotonic_clock(),
+            clocks: clocks::host::clocks_ctx(),
         }
     }
 
@@ -159,14 +155,8 @@ impl WasiCtxBuilder {
         self.insecure_random_seed = insecure_random_seed;
         self
     }
-
-    pub fn set_wall_clock(mut self, clock: impl clocks::HostWallClock + 'static) -> Self {
-        self.wall_clock = Box::new(clock);
-        self
-    }
-
-    pub fn set_monotonic_clock(mut self, clock: impl clocks::HostMonotonicClock + 'static) -> Self {
-        self.monotonic_clock = Box::new(clock);
+    pub fn set_clocks(mut self, clocks: WasiClocks) -> Self {
+        self.clocks = clocks;
         self
     }
 
@@ -182,8 +172,7 @@ impl WasiCtxBuilder {
             random,
             insecure_random,
             insecure_random_seed,
-            wall_clock,
-            monotonic_clock,
+            clocks,
         } = self;
 
         let stdin = table.push_input_stream(stdin).context("stdin")?;
@@ -210,8 +199,7 @@ impl WasiCtxBuilder {
             random,
             insecure_random,
             insecure_random_seed,
-            wall_clock,
-            monotonic_clock,
+            clocks,
         })
     }
 }
@@ -227,8 +215,7 @@ pub struct WasiCtx {
     pub(crate) random: Box<dyn RngCore + Send + Sync>,
     pub(crate) insecure_random: Box<dyn RngCore + Send + Sync>,
     pub(crate) insecure_random_seed: u128,
-    pub(crate) wall_clock: Box<dyn HostWallClock + Send + Sync>,
-    pub(crate) monotonic_clock: Box<dyn HostMonotonicClock + Send + Sync>,
+    pub(crate) clocks: WasiClocks,
     pub(crate) env: Vec<(String, String)>,
     pub(crate) args: Vec<String>,
     pub(crate) preopens: Vec<(u32, String)>,
diff --git a/crates/wasi/src/preview2/mod.rs b/crates/wasi/src/preview2/mod.rs
index f2b00ee17..04816de7f 100644
--- a/crates/wasi/src/preview2/mod.rs
+++ b/crates/wasi/src/preview2/mod.rs
@@ -36,7 +36,7 @@ pub mod wasi;
 
 pub use cap_fs_ext::SystemTimeSpec;
 pub use cap_rand::RngCore;
-pub use clocks::{HostMonotonicClock, HostWallClock};
+pub use clocks::{WasiClocks, WasiMonotonicClock, WasiWallClock};
 pub use ctx::{WasiCtx, WasiCtxBuilder, WasiView};
 pub use error::I32Exit;
 pub use filesystem::{DirPerms, FilePerms};
diff --git a/crates/wasi/src/preview2/preview2/clocks.rs b/crates/wasi/src/preview2/preview2/clocks.rs
index 0693f09f5..75d292751 100644
--- a/crates/wasi/src/preview2/preview2/clocks.rs
+++ b/crates/wasi/src/preview2/preview2/clocks.rs
@@ -27,7 +27,7 @@ impl TryFrom<SystemTime> for Datetime {
 #[async_trait::async_trait]
 impl<T: WasiView> wall_clock::Host for T {
     async fn now(&mut self) -> anyhow::Result<Datetime> {
-        let now = self.ctx().wall_clock.now();
+        let now = self.ctx().clocks.wall.now();
         Ok(Datetime {
             seconds: now.as_secs(),
             nanoseconds: now.subsec_nanos(),
@@ -35,7 +35,7 @@ impl<T: WasiView> wall_clock::Host for T {
     }
 
     async fn resolution(&mut self) -> anyhow::Result<Datetime> {
-        let res = self.ctx().wall_clock.resolution();
+        let res = self.ctx().clocks.wall.resolution();
         Ok(Datetime {
             seconds: res.as_secs(),
             nanoseconds: res.subsec_nanos(),
@@ -46,11 +46,11 @@ impl<T: WasiView> wall_clock::Host for T {
 #[async_trait::async_trait]
 impl<T: WasiView> monotonic_clock::Host for T {
     async fn now(&mut self) -> anyhow::Result<Instant> {
-        Ok(self.ctx().monotonic_clock.now())
+        Ok(self.ctx().clocks.monotonic.now())
     }
 
     async fn resolution(&mut self) -> anyhow::Result<Instant> {
-        Ok(self.ctx().monotonic_clock.resolution())
+        Ok(self.ctx().clocks.monotonic.resolution())
     }
 
     async fn subscribe(&mut self, when: Instant, absolute: bool) -> anyhow::Result<Pollable> {
diff --git a/crates/wasi/src/preview2/preview2/poll.rs b/crates/wasi/src/preview2/preview2/poll.rs
index 58a7407ef..338b83518 100644
--- a/crates/wasi/src/preview2/preview2/poll.rs
+++ b/crates/wasi/src/preview2/preview2/poll.rs
@@ -56,7 +56,7 @@ impl<T: WasiView> poll::Host for T {
                 }
                 PollableEntry::MonotonicClock(when, absolute) => {
                     poll.subscribe_monotonic_clock(
-                        &*self.ctx().monotonic_clock,
+                        &*self.ctx().clocks.monotonic,
                         when,
                         absolute,
                         userdata,
diff --git a/crates/wasi/src/preview2/sched.rs b/crates/wasi/src/preview2/sched.rs
index 23e6756b5..4d4494e2e 100644
--- a/crates/wasi/src/preview2/sched.rs
+++ b/crates/wasi/src/preview2/sched.rs
@@ -1,6 +1,6 @@
 #![allow(dead_code)]
 use crate::preview2::{
-    clocks::HostMonotonicClock,
+    clocks::WasiMonotonicClock,
     stream::{InputStream, OutputStream},
 };
 use anyhow::Error;
@@ -43,7 +43,7 @@ impl<'a> Poll<'a> {
     }
     pub fn subscribe_monotonic_clock(
         &mut self,
-        clock: &'a dyn HostMonotonicClock,
+        clock: &'a dyn WasiMonotonicClock,
         deadline: u64,
         absolute: bool,
         ud: Userdata,
diff --git a/crates/wasi/src/preview2/sched/subscription.rs b/crates/wasi/src/preview2/sched/subscription.rs
index 7d6f95fd6..feffe893c 100644
--- a/crates/wasi/src/preview2/sched/subscription.rs
+++ b/crates/wasi/src/preview2/sched/subscription.rs
@@ -1,5 +1,5 @@
 use crate::preview2::{
-    clocks::HostMonotonicClock,
+    clocks::WasiMonotonicClock,
     stream::{InputStream, OutputStream},
 };
 use anyhow::Error;
@@ -61,7 +61,7 @@ impl<'a> RwSubscription<'a> {
 }
 
 pub struct MonotonicClockSubscription<'a> {
-    pub clock: &'a dyn HostMonotonicClock,
+    pub clock: &'a dyn WasiMonotonicClock,
     pub absolute_deadline: u64,
 }
 
diff --git a/crates/wasmtime/Cargo.toml b/crates/wasmtime/Cargo.toml
index f5c045e4a..bb4a6eedf 100644
--- a/crates/wasmtime/Cargo.toml
+++ b/crates/wasmtime/Cargo.toml
@@ -23,6 +23,7 @@ wasmtime-environ = { workspace = true }
 wasmtime-jit = { workspace = true }
 wasmtime-cache = { workspace = true, optional = true }
 wasmtime-fiber = { workspace = true, optional = true }
+wasmtime-fibre = { workspace = true }
 wasmtime-cranelift = { workspace = true, optional = true }
 wasmtime-winch = { workspace = true, optional = true }
 wasmtime-component-macro = { workspace = true, optional = true }
@@ -37,7 +38,7 @@ wat = { workspace = true, optional = true }
 serde = { version = "1.0.94", features = ["derive"] }
 serde_json = { workspace = true }
 bincode = "1.2.1"
-indexmap = { workspace = true }
+indexmap = "1.6"
 paste = "1.0.3"
 psm = "0.1.11"
 once_cell = { workspace = true }
diff --git a/crates/wasmtime/src/compiler.rs b/crates/wasmtime/src/compiler.rs
index 1817de872..069c6b51d 100644
--- a/crates/wasmtime/src/compiler.rs
+++ b/crates/wasmtime/src/compiler.rs
@@ -24,11 +24,12 @@
 
 use crate::Engine;
 use anyhow::Result;
-use std::collections::{btree_map, BTreeMap, BTreeSet};
+use std::collections::{btree_map, BTreeMap};
 use std::{any::Any, collections::HashMap};
 use wasmtime_environ::{
-    Compiler, DefinedFuncIndex, FuncIndex, FunctionBodyData, ModuleTranslation, ModuleType,
-    ModuleTypes, PrimaryMap, SignatureIndex, StaticModuleIndex, Tunables, WasmFunctionInfo,
+    Compiler, DefinedFuncIndex, FuncIndex, FunctionBodyData, FunctionLoc, ModuleTranslation,
+    ModuleType, ModuleTypes, PrimaryMap, SignatureIndex, StaticModuleIndex, Tunables,
+    WasmFunctionInfo,
 };
 use wasmtime_jit::{CompiledFunctionInfo, CompiledModuleInfo};
 
@@ -257,7 +258,9 @@ impl<'a> CompileInputs<'a> {
                 wasmtime_environ::component::GlobalInitializer::InstantiateModule(_)
                 | wasmtime_environ::component::GlobalInitializer::ExtractMemory(_)
                 | wasmtime_environ::component::GlobalInitializer::ExtractRealloc(_)
-                | wasmtime_environ::component::GlobalInitializer::ExtractPostReturn(_) => {
+                | wasmtime_environ::component::GlobalInitializer::ExtractPostReturn(_)
+                | wasmtime_environ::component::GlobalInitializer::SaveStaticModule(_)
+                | wasmtime_environ::component::GlobalInitializer::SaveModuleImport(_) => {
                     // Nothing to compile for these.
                 }
             }
@@ -345,7 +348,7 @@ impl<'a> CompileInputs<'a> {
             }
 
             sigs.extend(translation.module.types.iter().map(|(_, ty)| match ty {
-                ModuleType::Function(ty) => (*ty, translation),
+                ModuleType::Function(ty) | ModuleType::Continuation(ty) => (*ty, translation),
             }));
         }
 
@@ -585,13 +588,6 @@ impl FunctionIndices {
             .remove(&CompileKey::NATIVE_TO_WASM_TRAMPOLINE_KIND)
             .unwrap_or_default();
 
-        // NB: unlike the above maps this is not emptied out during iteration
-        // since each module may reach into different portions of this map.
-        let wasm_to_native_trampolines = self
-            .indices
-            .remove(&CompileKey::WASM_TO_NATIVE_TRAMPOLINE_KIND)
-            .unwrap_or_default();
-
         artifacts.modules = translations
             .into_iter()
             .map(|(module, translation)| {
@@ -625,20 +621,16 @@ impl FunctionIndices {
                         })
                         .collect();
 
-                let unique_and_sorted_sigs = translation
-                    .module
-                    .types
-                    .iter()
-                    .map(|(_, ty)| match ty {
-                        ModuleType::Function(ty) => *ty,
-                    })
-                    .collect::<BTreeSet<_>>();
-                let wasm_to_native_trampolines = unique_and_sorted_sigs
-                    .iter()
-                    .map(|idx| {
-                        let key = CompileKey::wasm_to_native_trampoline(*idx);
-                        let compiled = wasm_to_native_trampolines[&key];
-                        (*idx, symbol_ids_and_locs[compiled.unwrap_function()].1)
+                let wasm_to_native_trampolines: Vec<(SignatureIndex, FunctionLoc)> = self
+                    .indices
+                    .remove(&CompileKey::WASM_TO_NATIVE_TRAMPOLINE_KIND)
+                    .into_iter()
+                    .flat_map(|x| x)
+                    .map(|(key, i)| {
+                        (
+                            SignatureIndex::from_u32(key.index),
+                            symbol_ids_and_locs[i.unwrap_function()].1,
+                        )
                     })
                     .collect();
 
@@ -688,17 +680,17 @@ pub struct Artifacts {
     #[cfg(feature = "component-model")]
     pub lowerings: PrimaryMap<
         wasmtime_environ::component::LoweredIndex,
-        wasmtime_environ::component::AllCallFunc<wasmtime_environ::FunctionLoc>,
+        wasmtime_environ::component::AllCallFunc<FunctionLoc>,
     >,
     #[cfg(feature = "component-model")]
     pub always_traps: PrimaryMap<
         wasmtime_environ::component::RuntimeAlwaysTrapIndex,
-        wasmtime_environ::component::AllCallFunc<wasmtime_environ::FunctionLoc>,
+        wasmtime_environ::component::AllCallFunc<FunctionLoc>,
     >,
     #[cfg(feature = "component-model")]
     pub transcoders: PrimaryMap<
         wasmtime_environ::component::RuntimeTranscoderIndex,
-        wasmtime_environ::component::AllCallFunc<wasmtime_environ::FunctionLoc>,
+        wasmtime_environ::component::AllCallFunc<FunctionLoc>,
     >,
 }
 
diff --git a/crates/wasmtime/src/component/instance.rs b/crates/wasmtime/src/component/instance.rs
index 2eeacd451..f8e8f1dd2 100644
--- a/crates/wasmtime/src/component/instance.rs
+++ b/crates/wasmtime/src/component/instance.rs
@@ -11,7 +11,7 @@ use std::sync::Arc;
 use wasmtime_environ::component::{
     AlwaysTrap, ComponentTypes, CoreDef, CoreExport, Export, ExportItem, ExtractMemory,
     ExtractPostReturn, ExtractRealloc, GlobalInitializer, InstantiateModule, LowerImport,
-    RuntimeImportIndex, RuntimeInstanceIndex, Transcoder,
+    RuntimeImportIndex, RuntimeInstanceIndex, RuntimeModuleIndex, Transcoder,
 };
 use wasmtime_environ::{EntityIndex, EntityType, Global, PrimaryMap, WasmType};
 use wasmtime_runtime::component::{ComponentInstance, OwnedComponentInstance};
@@ -30,35 +30,20 @@ pub struct Instance(pub(crate) Stored<Option<Box<InstanceData>>>);
 
 pub(crate) struct InstanceData {
     instances: PrimaryMap<RuntimeInstanceIndex, crate::Instance>,
-
-    // NB: in the future if necessary it would be possible to avoid storing an
-    // entire `Component` here and instead storing only information such as:
-    //
-    // * Some reference to `Arc<ComponentTypes>`
-    // * Necessary references to closed-over modules which are exported from the
-    //   component itself.
-    //
-    // Otherwise the full guts of this component should only ever be used during
-    // the instantiation of this instance, meaning that after instantiation much
-    // of the component can be thrown away (theoretically).
+    // FIXME: shouldn't store the entire component here which keeps upvars
+    // alive and things like that, instead only the bare minimum necessary
+    // should be kept alive here (mostly just `wasmtime_environ::Component`).
     component: Component,
+    exported_modules: PrimaryMap<RuntimeModuleIndex, Module>,
 
     state: OwnedComponentInstance,
 
-    /// Arguments that this instance used to be instantiated.
-    ///
-    /// Strong references are stored to these arguments since pointers are saved
-    /// into the structures such as functions within the
-    /// `OwnedComponentInstance` but it's our job to keep them alive.
+    /// Functions that this instance used during instantiation.
     ///
-    /// One purpose of this storage is to enable embedders to drop a `Linker`,
-    /// for example, after a component is instantiated. In that situation if the
-    /// arguments weren't held here then they might be dropped, and structures
-    /// such as `.lowering()` which point back into the original function would
-    /// become stale and use-after-free conditions when used. By preserving the
-    /// entire list here though we're guaranteed that nothing is lost for the
-    /// duration of the lifetime of this instance.
-    imports: Arc<PrimaryMap<RuntimeImportIndex, RuntimeImport>>,
+    /// Strong references are stored to these functions since pointers are saved
+    /// into the functions within the `OwnedComponentInstance` but it's our job
+    /// to keep them alive.
+    funcs: Vec<Arc<HostFunc>>,
 }
 
 impl Instance {
@@ -220,7 +205,7 @@ impl<'a> Instantiator<'a> {
     fn new(
         component: &'a Component,
         store: &mut StoreOpaque,
-        imports: &'a Arc<PrimaryMap<RuntimeImportIndex, RuntimeImport>>,
+        imports: &'a PrimaryMap<RuntimeImportIndex, RuntimeImport>,
     ) -> Instantiator<'a> {
         let env_component = component.env_component();
         store.modules_mut().register_component(component);
@@ -231,8 +216,11 @@ impl<'a> Instantiator<'a> {
             data: InstanceData {
                 instances: PrimaryMap::with_capacity(env_component.num_runtime_instances as usize),
                 component: component.clone(),
+                exported_modules: PrimaryMap::with_capacity(
+                    env_component.num_runtime_modules as usize,
+                ),
                 state: OwnedComponentInstance::new(component.runtime_info(), store.traitobj()),
-                imports: imports.clone(),
+                funcs: Vec::new(),
             },
         }
     }
@@ -300,6 +288,19 @@ impl<'a> Instantiator<'a> {
                     self.extract_post_return(store.0, post_return)
                 }
 
+                GlobalInitializer::SaveStaticModule(idx) => {
+                    self.data
+                        .exported_modules
+                        .push(self.component.static_module(*idx).clone());
+                }
+
+                GlobalInitializer::SaveModuleImport(idx) => {
+                    self.data.exported_modules.push(match &self.imports[*idx] {
+                        RuntimeImport::Module(m) => m.clone(),
+                        _ => unreachable!(),
+                    });
+                }
+
                 GlobalInitializer::Transcoder(e) => self.transcoder(e),
             }
         }
@@ -329,6 +330,15 @@ impl<'a> Instantiator<'a> {
             array_call,
             type_index,
         );
+
+        // The `func` provided here must be retained within the `Store` itself
+        // after instantiation. Otherwise it might be possible to drop the
+        // `Arc<HostFunc>` and possibly result in a use-after-free. This comes
+        // about because the `.lowering()` method returns a structure that
+        // points to an interior pointer within the `func`. By saving the list
+        // of host functions used we can ensure that the function lives long
+        // enough for the whole duration of this instance.
+        self.data.funcs.push(func.clone());
     }
 
     fn always_trap(&mut self, trap: &AlwaysTrap) {
@@ -430,7 +440,7 @@ impl<'a> Instantiator<'a> {
     }
 
     fn assert_type_matches(
-        &self,
+        &mut self,
         store: &mut StoreOpaque,
         module: &Module,
         arg: &CoreDef,
@@ -475,7 +485,7 @@ impl<'a> Instantiator<'a> {
 /// method.
 pub struct InstancePre<T> {
     component: Component,
-    imports: Arc<PrimaryMap<RuntimeImportIndex, RuntimeImport>>,
+    imports: PrimaryMap<RuntimeImportIndex, RuntimeImport>,
     _marker: marker::PhantomData<fn() -> T>,
 }
 
@@ -503,7 +513,7 @@ impl<T> InstancePre<T> {
     ) -> InstancePre<T> {
         InstancePre {
             component,
-            imports: Arc::new(imports),
+            imports,
             _marker: marker::PhantomData,
         }
     }
@@ -639,10 +649,7 @@ impl<'a, 'store> ExportInstance<'a, 'store> {
                 func,
                 options,
             )),
-            Export::ModuleStatic(_)
-            | Export::ModuleImport(_)
-            | Export::Instance(_)
-            | Export::Type(_) => None,
+            Export::Module(_) | Export::Instance(_) | Export::Type(_) => None,
         }
     }
 
@@ -663,11 +670,7 @@ impl<'a, 'store> ExportInstance<'a, 'store> {
     /// Same as [`Instance::get_module`]
     pub fn module(&mut self, name: &str) -> Option<&'a Module> {
         match self.exports.get(name)? {
-            Export::ModuleStatic(idx) => Some(&self.data.component.static_module(*idx)),
-            Export::ModuleImport(idx) => Some(match &self.data.imports[*idx] {
-                RuntimeImport::Module(m) => m,
-                _ => unreachable!(),
-            }),
+            Export::Module(idx) => Some(&self.data.exported_modules[*idx]),
             _ => None,
         }
     }
@@ -685,17 +688,12 @@ impl<'a, 'store> ExportInstance<'a, 'store> {
     // For now this is just quick-and-dirty to get wast support for iterating
     // over exported modules to work.
     pub fn modules(&self) -> impl Iterator<Item = (&'a str, &'a Module)> + '_ {
-        self.exports.iter().filter_map(|(name, export)| {
-            let module = match *export {
-                Export::ModuleStatic(idx) => self.data.component.static_module(idx),
-                Export::ModuleImport(idx) => match &self.data.imports[idx] {
-                    RuntimeImport::Module(m) => m,
-                    _ => unreachable!(),
-                },
-                _ => return None,
-            };
-            Some((name.as_str(), module))
-        })
+        self.exports
+            .iter()
+            .filter_map(|(name, export)| match *export {
+                Export::Module(idx) => Some((name.as_str(), &self.data.exported_modules[idx])),
+                _ => None,
+            })
     }
 
     fn as_mut(&mut self) -> ExportInstance<'a, '_> {
diff --git a/crates/wasmtime/src/component/linker.rs b/crates/wasmtime/src/component/linker.rs
index c97308fa0..cf2bbb302 100644
--- a/crates/wasmtime/src/component/linker.rs
+++ b/crates/wasmtime/src/component/linker.rs
@@ -4,11 +4,9 @@ use crate::component::matching::TypeChecker;
 use crate::component::{Component, ComponentNamedList, Instance, InstancePre, Lift, Lower, Val};
 use crate::{AsContextMut, Engine, Module, StoreContextMut};
 use anyhow::{anyhow, bail, Context, Result};
-use indexmap::IndexMap;
 use std::collections::hash_map::{Entry, HashMap};
 use std::future::Future;
 use std::marker;
-use std::ops::Deref;
 use std::pin::Pin;
 use std::sync::Arc;
 use wasmtime_environ::component::TypeDef;
@@ -24,7 +22,6 @@ pub struct Linker<T> {
     engine: Engine,
     strings: Strings,
     map: NameMap,
-    path: Vec<usize>,
     allow_shadowing: bool,
     _marker: marker::PhantomData<fn() -> T>,
 }
@@ -41,9 +38,7 @@ pub struct Strings {
 /// a "bag of named items", so each [`LinkerInstance`] can further define items
 /// internally.
 pub struct LinkerInstance<'a, T> {
-    engine: &'a Engine,
-    path: &'a mut Vec<usize>,
-    path_len: usize,
+    engine: Engine,
     strings: &'a mut Strings,
     map: &'a mut NameMap,
     allow_shadowing: bool,
@@ -68,7 +63,6 @@ impl<T> Linker<T> {
             strings: Strings::default(),
             map: NameMap::default(),
             allow_shadowing: false,
-            path: Vec::new(),
             _marker: marker::PhantomData,
         }
     }
@@ -91,9 +85,7 @@ impl<T> Linker<T> {
     /// the root namespace.
     pub fn root(&mut self) -> LinkerInstance<'_, T> {
         LinkerInstance {
-            engine: &self.engine,
-            path: &mut self.path,
-            path_len: 0,
+            engine: self.engine.clone(),
             strings: &mut self.strings,
             map: &mut self.map,
             allow_shadowing: self.allow_shadowing,
@@ -238,9 +230,7 @@ impl<T> Linker<T> {
 impl<T> LinkerInstance<'_, T> {
     fn as_mut(&mut self) -> LinkerInstance<'_, T> {
         LinkerInstance {
-            engine: self.engine,
-            path: self.path,
-            path_len: self.path_len,
+            engine: self.engine.clone(),
             strings: self.strings,
             map: self.map,
             allow_shadowing: self.allow_shadowing,
@@ -320,39 +310,21 @@ impl<T> LinkerInstance<'_, T> {
         name: &str,
         func: F,
     ) -> Result<()> {
-        let mut map = &component
-            .env_component()
-            .import_types
-            .values()
-            .map(|(k, v)| (k.clone(), *v))
-            .collect::<IndexMap<_, _>>();
-
-        for name in self.path.iter().copied().take(self.path_len) {
-            let name = self.strings.strings[name].deref();
-            if let Some(ty) = map.get(name) {
-                if let TypeDef::ComponentInstance(index) = ty {
-                    map = &component.types()[*index].exports;
+        for (import_name, ty) in component.env_component().import_types.values() {
+            if name == import_name {
+                if let TypeDef::ComponentFunc(index) = ty {
+                    let name = self.strings.intern(name);
+                    return self.insert(
+                        name,
+                        Definition::Func(HostFunc::new_dynamic(func, *index, component.types())),
+                    );
                 } else {
-                    bail!("import `{name}` has the wrong type (expected a component instance)");
+                    bail!("import `{name}` has the wrong type (expected a function)");
                 }
-            } else {
-                bail!("import `{name}` not found");
             }
         }
 
-        if let Some(ty) = map.get(name) {
-            if let TypeDef::ComponentFunc(index) = ty {
-                let name = self.strings.intern(name);
-                return self.insert(
-                    name,
-                    Definition::Func(HostFunc::new_dynamic(func, *index, component.types())),
-                );
-            } else {
-                bail!("import `{name}` has the wrong type (expected a function)");
-            }
-        } else {
-            Err(anyhow!("import `{name}` not found"))
-        }
+        Err(anyhow!("import `{name}` not found"))
     }
 
     // TODO: define func_new_async
@@ -395,9 +367,6 @@ impl<T> LinkerInstance<'_, T> {
             Definition::Instance(map) => map,
             _ => unreachable!(),
         };
-        self.path.truncate(self.path_len);
-        self.path.push(name);
-        self.path_len += 1;
         Ok(self)
     }
 
diff --git a/crates/wasmtime/src/config.rs b/crates/wasmtime/src/config.rs
index b0d5bdc87..a2c1493d3 100644
--- a/crates/wasmtime/src/config.rs
+++ b/crates/wasmtime/src/config.rs
@@ -839,6 +839,32 @@ impl Config {
         self
     }
 
+    /// Configures whether the WebAssembly exception handling
+    /// [proposal] will be enabled for compilation.
+    ///
+    /// Note that this feature is a work-in-progress and is incomplete.
+    ///
+    /// This is `false` by default.
+    ///
+    /// [proposal]: https://github.com/WebAssembly/exception-handling
+    pub fn wasm_exceptions(&mut self, enable: bool) -> &mut Self {
+        self.features.exceptions = enable;
+        self
+    }
+
+    /// Configures whether the WebAssembly typed-continuations
+    /// [proposal] will be enabled for compilation.
+    ///
+    /// Note that this feature is a work-in-progress and is incomplete.
+    ///
+    /// This is `false` by default.
+    ///
+    /// [proposal]: https://github.com/effect-handlers/wasm-spec
+    pub fn wasm_typed_continuations(&mut self, enable: bool) -> &mut Self {
+        self.features.typed_continuations = enable;
+        self
+    }
+
     /// Configures which compilation strategy will be used for wasm modules.
     ///
     /// This method can be used to configure which compiler is used for wasm
diff --git a/crates/wasmtime/src/engine/serialization.rs b/crates/wasmtime/src/engine/serialization.rs
index 5eeb421b7..223e67103 100644
--- a/crates/wasmtime/src/engine/serialization.rs
+++ b/crates/wasmtime/src/engine/serialization.rs
@@ -169,6 +169,7 @@ struct WasmFeatures {
     relaxed_simd: bool,
     extended_const: bool,
     function_references: bool,
+    typed_continuations: bool,
 }
 
 impl Metadata {
@@ -189,6 +190,7 @@ impl Metadata {
             extended_const,
             memory_control,
             function_references,
+            typed_continuations,
             gc,
 
             // Always on; we don't currently have knobs for these.
@@ -220,6 +222,7 @@ impl Metadata {
                 relaxed_simd,
                 extended_const,
                 function_references,
+                typed_continuations,
             },
         }
     }
@@ -391,6 +394,7 @@ impl Metadata {
             relaxed_simd,
             extended_const,
             function_references,
+            typed_continuations,
         } = self.features;
 
         Self::check_bool(
@@ -445,6 +449,11 @@ impl Metadata {
             other.function_references,
             "WebAssembly function-references support",
         )?;
+        Self::check_bool(
+            typed_continuations,
+            other.typed_continuations,
+            "WebAssembly typed-continuations support",
+        )?;
 
         Ok(())
     }
diff --git a/crates/wasmtime/src/externals.rs b/crates/wasmtime/src/externals.rs
index 0e13c5669..c9614420b 100644
--- a/crates/wasmtime/src/externals.rs
+++ b/crates/wasmtime/src/externals.rs
@@ -305,6 +305,7 @@ impl Global {
             bail!("immutable global cannot be set");
         }
         let ty = ty.content();
+
         if val.ty() != *ty {
             bail!("global of type {:?} cannot be set to {:?}", ty, val.ty());
         }
@@ -524,8 +525,8 @@ impl Table {
     /// Panics if `store` does not own this table.
     pub fn set(&self, mut store: impl AsContextMut, index: u32, val: Val) -> Result<()> {
         let store = store.as_context_mut().0;
-        let ty = self.ty(&store).element().clone();
-        let val = val.into_table_element(store, ty)?;
+        let rt = self.ty(&store).element().clone();
+        let val = val.into_table_element(store, rt)?;
         let table = self.wasmtime_table(store, std::iter::empty());
         unsafe {
             (*table)
@@ -570,8 +571,8 @@ impl Table {
     /// instead.
     pub fn grow(&self, mut store: impl AsContextMut, delta: u32, init: Val) -> Result<u32> {
         let store = store.as_context_mut().0;
-        let ty = self.ty(&store).element().clone();
-        let init = init.into_table_element(store, ty)?;
+        let rt = self.ty(&store).element().clone();
+        let init = init.into_table_element(store, rt)?;
         let table = self.wasmtime_table(store, std::iter::empty());
         unsafe {
             match (*table).grow(delta, init, store)? {
@@ -664,8 +665,8 @@ impl Table {
     /// Panics if `store` does not own either `dst_table` or `src_table`.
     pub fn fill(&self, mut store: impl AsContextMut, dst: u32, val: Val, len: u32) -> Result<()> {
         let store = store.as_context_mut().0;
-        let ty = self.ty(&store).element().clone();
-        let val = val.into_table_element(store, ty)?;
+        let rt = self.ty(&store).element().clone();
+        let val = val.into_table_element(store, rt)?;
 
         let table = self.wasmtime_table(store, std::iter::empty());
         unsafe {
diff --git a/crates/wasmtime/src/func.rs b/crates/wasmtime/src/func.rs
index b1f0bb03c..2c4b21b9b 100644
--- a/crates/wasmtime/src/func.rs
+++ b/crates/wasmtime/src/func.rs
@@ -1025,6 +1025,7 @@ impl Func {
                 results.len()
             );
         }
+
         for (ty, arg) in ty.params().zip(params) {
             if arg.ty() != ty {
                 bail!(
diff --git a/crates/wasmtime/src/instance.rs b/crates/wasmtime/src/instance.rs
index 697e62a42..9350ffbd8 100644
--- a/crates/wasmtime/src/instance.rs
+++ b/crates/wasmtime/src/instance.rs
@@ -666,11 +666,36 @@ pub struct InstancePre<T> {
     /// instantiation time.
     ///
     /// This is an `Arc<[T]>` for the same reason as `items`.
-    func_refs: Arc<[VMFuncRef]>,
+    func_refs: Arc<[PrePatchedFuncRef]>,
 
     _marker: std::marker::PhantomData<fn() -> T>,
 }
 
+pub(crate) use pre_patched_func_ref::PrePatchedFuncRef;
+mod pre_patched_func_ref {
+    use super::*;
+
+    pub struct PrePatchedFuncRef(VMFuncRef);
+
+    impl PrePatchedFuncRef {
+        /// Safety: callers must arrange for the given `func_ref` to be usable
+        /// in a `Send + Sync` manner (i.e. its associated `Module` is kept
+        /// alive or `Func` is alive and supports these things) and that the
+        /// `wasm_call` field is already patched in, if necessary.
+        pub unsafe fn new(func_ref: VMFuncRef) -> PrePatchedFuncRef {
+            PrePatchedFuncRef(func_ref)
+        }
+
+        pub fn func_ref(&self) -> &VMFuncRef {
+            &self.0
+        }
+    }
+
+    // Safety: This is upheld by `PrePatchedFuncRef::new` callers.
+    unsafe impl<T> Send for InstancePre<T> {}
+    unsafe impl<T> Sync for InstancePre<T> {}
+}
+
 /// InstancePre's clone does not require T: Clone
 impl<T> Clone for InstancePre<T> {
     fn clone(&self) -> Self {
@@ -707,12 +732,12 @@ impl<T> InstancePre<T> {
                         // `f` needs its `VMFuncRef::wasm_call`
                         // patched with a Wasm-to-native trampoline.
                         debug_assert!(matches!(f.host_ctx(), crate::HostContext::Native(_)));
-                        func_refs.push(VMFuncRef {
+                        func_refs.push(PrePatchedFuncRef::new(VMFuncRef {
                             wasm_call: module
                                 .runtime_info()
                                 .wasm_to_native_trampoline(f.sig_index()),
                             ..*f.func_ref()
-                        });
+                        }));
                     }
                 }
             }
@@ -810,7 +835,7 @@ fn pre_instantiate_raw(
     module: &Module,
     items: &Arc<[Definition]>,
     host_funcs: usize,
-    func_refs: &Arc<[VMFuncRef]>,
+    func_refs: &Arc<[PrePatchedFuncRef]>,
 ) -> Result<OwnedImports> {
     if host_funcs > 0 {
         // Any linker-defined function of the `Definition::HostFunc` variant
@@ -827,7 +852,7 @@ fn pre_instantiate_raw(
         store.push_instance_pre_func_refs(func_refs.clone());
     }
 
-    let mut func_refs = func_refs.iter().map(|f| NonNull::from(f));
+    let mut func_refs = func_refs.iter().map(|f| NonNull::from(f.func_ref()));
     let mut imports = OwnedImports::new(module);
     for import in items.iter() {
         if !import.comes_from_same_store(store) {
diff --git a/crates/wasmtime/src/store.rs b/crates/wasmtime/src/store.rs
index df3f6d023..930a73ee9 100644
--- a/crates/wasmtime/src/store.rs
+++ b/crates/wasmtime/src/store.rs
@@ -76,6 +76,7 @@
 //! contents of `StoreOpaque`. This is an invariant that we, as the authors of
 //! `wasmtime`, must uphold for the public interface to be safe.
 
+use crate::instance::PrePatchedFuncRef;
 use crate::linker::Definition;
 use crate::module::BareModuleInfo;
 use crate::trampoline::VMHostGlobalContext;
@@ -96,7 +97,7 @@ use std::task::{Context, Poll};
 use wasmtime_runtime::{
     InstanceAllocationRequest, InstanceAllocator, InstanceHandle, ModuleInfo,
     OnDemandInstanceAllocator, SignalHandler, StoreBox, StorePtr, VMContext, VMExternRef,
-    VMExternRefActivationsTable, VMFuncRef, VMRuntimeLimits, WasmFault,
+    VMExternRefActivationsTable, VMRuntimeLimits, WasmFault,
 };
 
 mod context;
@@ -1214,7 +1215,7 @@ impl StoreOpaque {
         self.func_refs.fill(&mut self.modules);
     }
 
-    pub(crate) fn push_instance_pre_func_refs(&mut self, func_refs: Arc<[VMFuncRef]>) {
+    pub(crate) fn push_instance_pre_func_refs(&mut self, func_refs: Arc<[PrePatchedFuncRef]>) {
         self.func_refs.push_instance_pre_func_refs(func_refs);
     }
 
diff --git a/crates/wasmtime/src/store/func_refs.rs b/crates/wasmtime/src/store/func_refs.rs
index b84849cdc..16ab2c222 100644
--- a/crates/wasmtime/src/store/func_refs.rs
+++ b/crates/wasmtime/src/store/func_refs.rs
@@ -1,4 +1,4 @@
-use crate::module::ModuleRegistry;
+use crate::{instance::PrePatchedFuncRef, module::ModuleRegistry};
 use std::{ptr::NonNull, sync::Arc};
 use wasmtime_runtime::{SendSyncPtr, VMFuncRef, VMNativeCallHostFuncContext};
 
@@ -20,7 +20,7 @@ pub struct FuncRefs {
     /// Pinned `VMFuncRef`s that had their `wasm_call` field
     /// pre-patched when constructing an `InstancePre`, and which we need to
     /// keep alive for our owning store's lifetime.
-    instance_pre_func_refs: Vec<Arc<[VMFuncRef]>>,
+    instance_pre_func_refs: Vec<Arc<[PrePatchedFuncRef]>>,
 }
 
 use send_sync_bump::SendSyncBump;
@@ -79,7 +79,7 @@ impl FuncRefs {
     }
 
     /// Push pre-patched `VMFuncRef`s from an `InstancePre`.
-    pub fn push_instance_pre_func_refs(&mut self, func_refs: Arc<[VMFuncRef]>) {
+    pub fn push_instance_pre_func_refs(&mut self, func_refs: Arc<[PrePatchedFuncRef]>) {
         self.instance_pre_func_refs.push(func_refs);
     }
 }
diff --git a/crates/wast/src/wast.rs b/crates/wast/src/wast.rs
index 32d4cc2d0..974e8bc48 100644
--- a/crates/wast/src/wast.rs
+++ b/crates/wast/src/wast.rs
@@ -465,6 +465,7 @@ impl<T> WastContext<T> {
                 }
             }
             AssertException { .. } => bail!("unimplemented assert_exception"),
+            AssertSuspension { .. } => bail!("unimplemented assert_suspension"),
         }
 
         Ok(())
diff --git a/crates/wit-bindgen/src/lib.rs b/crates/wit-bindgen/src/lib.rs
index 356fd83a3..f4812254e 100644
--- a/crates/wit-bindgen/src/lib.rs
+++ b/crates/wit-bindgen/src/lib.rs
@@ -681,8 +681,6 @@ impl<'a> InterfaceGenerator<'a> {
             TypeDefKind::Type(t) => self.type_alias(id, name, t, &ty.docs),
             TypeDefKind::Future(_) => todo!("generate for future"),
             TypeDefKind::Stream(_) => todo!("generate for stream"),
-            TypeDefKind::Handle(_) => todo!(),
-            TypeDefKind::Resource => todo!(),
             TypeDefKind::Unknown => unreachable!(),
         }
     }
diff --git a/crates/wit-bindgen/src/rust.rs b/crates/wit-bindgen/src/rust.rs
index 94cc233f2..4bbc12ff5 100644
--- a/crates/wit-bindgen/src/rust.rs
+++ b/crates/wit-bindgen/src/rust.rs
@@ -117,9 +117,7 @@ pub trait RustGenerator<'a> {
                     | TypeDefKind::Flags(_)
                     | TypeDefKind::Enum(_)
                     | TypeDefKind::Tuple(_)
-                    | TypeDefKind::Union(_)
-                    | TypeDefKind::Handle(_)
-                    | TypeDefKind::Resource => true,
+                    | TypeDefKind::Union(_) => true,
                     TypeDefKind::Type(Type::Id(t)) => {
                         needs_generics(resolve, &resolve.types[*t].kind)
                     }
@@ -185,9 +183,6 @@ pub trait RustGenerator<'a> {
                 self.push_str(">");
             }
 
-            TypeDefKind::Handle(_) => todo!(),
-            TypeDefKind::Resource => todo!(),
-
             TypeDefKind::Type(t) => self.print_ty(t, mode),
             TypeDefKind::Unknown => unreachable!(),
         }
@@ -297,8 +292,6 @@ pub trait RustGenerator<'a> {
                         TypeDefKind::Variant(_) => out.push_str("Variant"),
                         TypeDefKind::Enum(_) => out.push_str("Enum"),
                         TypeDefKind::Union(_) => out.push_str("Union"),
-                        TypeDefKind::Handle(_) => todo!(),
-                        TypeDefKind::Resource => todo!(),
                         TypeDefKind::Unknown => unreachable!(),
                     },
                 }
diff --git a/crates/wit-bindgen/src/types.rs b/crates/wit-bindgen/src/types.rs
index 9f8d9e89c..223bfcc91 100644
--- a/crates/wit-bindgen/src/types.rs
+++ b/crates/wit-bindgen/src/types.rs
@@ -158,8 +158,6 @@ impl Types {
                 info = self.optional_type_info(resolve, stream.element.as_ref());
                 info |= self.optional_type_info(resolve, stream.end.as_ref());
             }
-            TypeDefKind::Handle(_) => {}
-            TypeDefKind::Resource => {}
             TypeDefKind::Unknown => unreachable!(),
         }
         self.type_info.insert(ty, info);
diff --git a/docs/SUMMARY.md b/docs/SUMMARY.md
index 0e02f5c17..52abd5788 100644
--- a/docs/SUMMARY.md
+++ b/docs/SUMMARY.md
@@ -38,7 +38,6 @@
 - [Using the `wasmtime` CLI](./cli.md)
   - [Installation](./cli-install.md)
   - [CLI Options](./cli-options.md)
-  - [CLI Logging](./cli-logging.md)
   - [Cache Configuration](./cli-cache.md)
 - [Writing WebAssembly](./wasm.md)
   - [Rust](./wasm-rust.md)
diff --git a/fuzz/fuzz_targets/compile.rs b/fuzz/fuzz_targets/compile.rs
index 743ea9468..93ff23c1b 100644
--- a/fuzz/fuzz_targets/compile.rs
+++ b/fuzz/fuzz_targets/compile.rs
@@ -1,12 +1,10 @@
-//! Compile arbitrary bytes from the fuzzer as if they were Wasm, checking that
-//! compilation is deterministic.
-//!
-//! Also use `wasm-mutate` to mutate the fuzz inputs.
+//! Compile arbitrary bytes from the fuzzer as if they were Wasm. Also use
+//! `wasm-mutate` to mutate the fuzz inputs.
 
 #![no_main]
 
 use libfuzzer_sys::{fuzz_mutator, fuzz_target};
-use wasmtime::{Config, Engine, Module, Result};
+use wasmtime::{Config, Engine, Module};
 
 fn create_engine() -> Engine {
     let mut config = Config::default();
@@ -19,24 +17,10 @@ fn create_engine() -> Engine {
     Engine::new(&config).expect("Could not construct Engine")
 }
 
-fn compile_and_serialize(engine: &Engine, wasm: &[u8]) -> Result<Vec<u8>> {
-    let module = Module::new(&engine, wasm)?;
-    module.serialize()
-}
-
 fuzz_target!(|data: &[u8]| {
     let engine = create_engine();
     wasmtime_fuzzing::oracles::log_wasm(data);
-
-    if let Ok(bytes1) = compile_and_serialize(&engine, data) {
-        let bytes2 = compile_and_serialize(&engine, data)
-            .expect("successfully compiled once, should successfully compile again");
-
-        // NB: Don't use `assert_eq!` here because it prints out the LHS and RHS
-        // to stderr on failure, which isn't helpful here since it is just a
-        // huge serialized binary.
-        assert!(bytes1 == bytes2, "Wasm compilation should be deterministic");
-    }
+    drop(Module::new(&engine, data));
 });
 
 fuzz_mutator!(|data: &mut [u8], size: usize, max_size: usize, seed: u32| {
diff --git a/fuzz/fuzz_targets/differential.rs b/fuzz/fuzz_targets/differential.rs
index f4d321faa..f7845803b 100644
--- a/fuzz/fuzz_targets/differential.rs
+++ b/fuzz/fuzz_targets/differential.rs
@@ -354,9 +354,6 @@ fn winch_supports_module(module: &[u8]) -> bool {
                         | I64Popcnt { .. }
                         | LocalGet { .. }
                         | LocalSet { .. }
-                        | LocalTee { .. }
-                        | GlobalGet { .. }
-                        | GlobalSet { .. }
                         | Call { .. }
                         | Nop { .. }
                         | End { .. }
diff --git a/scripts/publish.rs b/scripts/publish.rs
index 29ccf1372..513b0fea6 100644
--- a/scripts/publish.rs
+++ b/scripts/publish.rs
@@ -45,7 +45,6 @@ const CRATES_TO_PUBLISH: &[&str] = &[
     "winch",
     // wasmtime
     "wasmtime-asm-macros",
-    "wasmtime-versioned-export-macros",
     "wasmtime-component-util",
     "wasmtime-wit-bindgen",
     "wasmtime-component-macro",
diff --git a/src/commands/run.rs b/src/commands/run.rs
index 18eec5a50..d7e158d04 100644
--- a/src/commands/run.rs
+++ b/src/commands/run.rs
@@ -844,7 +844,6 @@ fn generate_coredump(err: &anyhow::Error, source_name: &str, coredump_path: &str
             instanceidx,
             f.func_index(),
             u32::try_from(f.func_offset().unwrap_or(0)).unwrap(),
-            // We don't currently have access to locals/stack values
             [],
             [],
         );
diff --git a/supply-chain/audits.toml b/supply-chain/audits.toml
index e01b65bf5..fe0998ffd 100644
--- a/supply-chain/audits.toml
+++ b/supply-chain/audits.toml
@@ -1607,15 +1607,6 @@ who = "Pat Hickey <phickey@fastly.com>"
 criteria = "safe-to-deploy"
 delta = "1.0.51 -> 1.0.57"
 
-[[audits.proc-macro2]]
-who = "Alex Crichton <alex@alexcrichton.com>"
-criteria = "safe-to-deploy"
-delta = "1.0.59 -> 1.0.63"
-notes = """
-This is a routine update for new nightly features and new syntax popping up on
-nightly, nothing out of the ordinary.
-"""
-
 [[audits.pulldown-cmark]]
 who = "Alex Crichton <alex@alexcrichton.com>"
 criteria = "safe-to-deploy"
@@ -1626,18 +1617,6 @@ are otherwise not doing other `unsafe` operations. Additionally the crate does
 not do anything other than markdown rendering as is expected.
 """
 
-[[audits.pulldown-cmark]]
-who = "Alex Crichton <alex@alexcrichton.com>"
-criteria = "safe-to-deploy"
-delta = "0.8.0 -> 0.9.3"
-notes = """
-This is a large change to the `pulldown-cmark` crate but it tightens
-restrictions on `unsafe` code to forbid it in non-SIMD mode and additionally
-many changes look to be related to refactoring, improving, and restructuring.
-This crate is not fundamentally different from before, which was trusted, but
-looks to be receiving new assistance for maintainership as well.
-"""
-
 [[audits.quote]]
 who = "Pat Hickey <phickey@fastly.com>"
 criteria = "safe-to-deploy"
@@ -2669,150 +2648,6 @@ criteria = "safe-to-deploy"
 version = "0.6.4"
 notes = "The Bytecode Alliance is the author of this crate."
 
-[[trusted.async-trait]]
-criteria = "safe-to-deploy"
-user-id = 3618 # David Tolnay (dtolnay)
-start = "2019-07-23"
-end = "2024-07-06"
-
-[[trusted.clap]]
-criteria = "safe-to-deploy"
-user-id = 6743 # Ed Page (epage)
-start = "2021-12-08"
-end = "2024-07-06"
-
-[[trusted.clap_derive]]
-criteria = "safe-to-deploy"
-user-id = 6743 # Ed Page (epage)
-start = "2021-12-08"
-end = "2024-07-06"
-
-[[trusted.clap_lex]]
-criteria = "safe-to-deploy"
-user-id = 6743 # Ed Page (epage)
-start = "2022-04-15"
-end = "2024-07-06"
-
-[[trusted.equivalent]]
-criteria = "safe-to-deploy"
-user-id = 539 # Josh Stone (cuviper)
-start = "2023-02-05"
-end = "2024-07-11"
-
-[[trusted.hashbrown]]
-criteria = "safe-to-deploy"
-user-id = 2915 # Amanieu d'Antras (Amanieu)
-start = "2019-04-02"
-end = "2024-07-11"
-
-[[trusted.indexmap]]
-criteria = "safe-to-deploy"
-user-id = 539 # Josh Stone (cuviper)
-start = "2020-01-15"
-end = "2024-07-06"
-
-[[trusted.itoa]]
-criteria = "safe-to-deploy"
-user-id = 3618 # David Tolnay (dtolnay)
-start = "2019-05-02"
-end = "2024-07-06"
-
-[[trusted.libc]]
-criteria = "safe-to-deploy"
-user-id = 2915 # Amanieu d'Antras (Amanieu)
-start = "2021-01-27"
-end = "2024-07-06"
-
-[[trusted.libm]]
-criteria = "safe-to-deploy"
-user-id = 2915 # Amanieu d'Antras (Amanieu)
-start = "2022-02-06"
-end = "2024-07-06"
-
-[[trusted.lock_api]]
-criteria = "safe-to-deploy"
-user-id = 2915 # Amanieu d'Antras (Amanieu)
-start = "2019-05-04"
-end = "2024-07-06"
-
-[[trusted.parking_lot]]
-criteria = "safe-to-deploy"
-user-id = 2915 # Amanieu d'Antras (Amanieu)
-start = "2019-05-04"
-end = "2024-07-06"
-
-[[trusted.parking_lot_core]]
-criteria = "safe-to-deploy"
-user-id = 2915 # Amanieu d'Antras (Amanieu)
-start = "2019-05-04"
-end = "2024-07-06"
-
-[[trusted.paste]]
-criteria = "safe-to-deploy"
-user-id = 3618 # David Tolnay (dtolnay)
-start = "2019-03-19"
-end = "2024-07-06"
-
-[[trusted.quote]]
-criteria = "safe-to-deploy"
-user-id = 3618 # David Tolnay (dtolnay)
-start = "2019-04-09"
-end = "2024-07-11"
-
-[[trusted.ryu]]
-criteria = "safe-to-deploy"
-user-id = 3618 # David Tolnay (dtolnay)
-start = "2019-05-02"
-end = "2024-07-06"
-
-[[trusted.scopeguard]]
-criteria = "safe-to-deploy"
-user-id = 2915 # Amanieu d'Antras (Amanieu)
-start = "2020-02-16"
-end = "2024-07-06"
-
-[[trusted.serde]]
-criteria = "safe-to-deploy"
-user-id = 3618 # David Tolnay (dtolnay)
-start = "2019-03-01"
-end = "2024-07-06"
-
-[[trusted.serde_derive]]
-criteria = "safe-to-deploy"
-user-id = 3618 # David Tolnay (dtolnay)
-start = "2019-03-01"
-end = "2024-07-06"
-
-[[trusted.serde_json]]
-criteria = "safe-to-deploy"
-user-id = 3618 # David Tolnay (dtolnay)
-start = "2019-02-28"
-end = "2024-07-06"
-
-[[trusted.syn]]
-criteria = "safe-to-deploy"
-user-id = 3618 # David Tolnay (dtolnay)
-start = "2019-03-01"
-end = "2024-07-06"
-
-[[trusted.thiserror]]
-criteria = "safe-to-deploy"
-user-id = 3618 # David Tolnay (dtolnay)
-start = "2019-10-09"
-end = "2024-07-06"
-
-[[trusted.thiserror-impl]]
-criteria = "safe-to-deploy"
-user-id = 3618 # David Tolnay (dtolnay)
-start = "2019-10-09"
-end = "2024-07-06"
-
-[[trusted.toml]]
-criteria = "safe-to-deploy"
-user-id = 1 # Alex Crichton (alexcrichton)
-start = "2019-05-16"
-end = "2024-07-06"
-
 [[trusted.windows-sys]]
 criteria = "safe-to-deploy"
 user-id = 64539 # Kenny Kerr (kennykerr)
diff --git a/supply-chain/config.toml b/supply-chain/config.toml
index 37e7d2a74..3cc9326d6 100644
--- a/supply-chain/config.toml
+++ b/supply-chain/config.toml
@@ -148,9 +148,6 @@ audit-as-crates-io = true
 [policy.wasmtime-types]
 audit-as-crates-io = true
 
-[policy.wasmtime-versioned-export-macros]
-audit-as-crates-io = false
-
 [policy.wasmtime-wasi]
 audit-as-crates-io = true
 
@@ -221,6 +218,10 @@ criteria = "safe-to-deploy"
 version = "0.7.18"
 criteria = "safe-to-deploy"
 
+[[exemptions.async-trait]]
+version = "0.1.53"
+criteria = "safe-to-deploy"
+
 [[exemptions.autocfg]]
 version = "0.1.8"
 criteria = "safe-to-deploy"
@@ -273,6 +274,18 @@ criteria = "safe-to-deploy"
 version = "0.3.0"
 criteria = "safe-to-deploy"
 
+[[exemptions.clap]]
+version = "3.2.8"
+criteria = "safe-to-deploy"
+
+[[exemptions.clap_derive]]
+version = "3.2.7"
+criteria = "safe-to-deploy"
+
+[[exemptions.clap_lex]]
+version = "0.2.4"
+criteria = "safe-to-deploy"
+
 [[exemptions.console]]
 version = "0.15.0"
 criteria = "safe-to-deploy"
@@ -495,6 +508,10 @@ version = "1.0.0-rc.3"
 criteria = "safe-to-deploy"
 notes = "we are exempting tokio, hyper, and their tightly coupled dependencies by the same authors, expecting that the authors at aws will publish attestions we can import at some point soon"
 
+[[exemptions.indexmap]]
+version = "1.9.1"
+criteria = "safe-to-deploy"
+
 [[exemptions.indicatif]]
 version = "0.13.0"
 criteria = "safe-to-deploy"
@@ -511,6 +528,10 @@ criteria = "safe-to-deploy"
 version = "0.10.3"
 criteria = "safe-to-deploy"
 
+[[exemptions.itoa]]
+version = "1.0.1"
+criteria = "safe-to-deploy"
+
 [[exemptions.jobserver]]
 version = "0.1.24"
 criteria = "safe-to-deploy"
@@ -524,14 +545,26 @@ notes = "dependency of ring for wasm32 browser platform, which our project does
 version = "0.9.6"
 criteria = "safe-to-deploy"
 
+[[exemptions.libc]]
+version = "0.2.133"
+criteria = "safe-to-deploy"
+
 [[exemptions.libloading]]
 version = "0.7.3"
 criteria = "safe-to-deploy"
 
+[[exemptions.libm]]
+version = "0.2.2"
+criteria = "safe-to-deploy"
+
 [[exemptions.listenfd]]
 version = "1.0.0"
 criteria = "safe-to-deploy"
 
+[[exemptions.lock_api]]
+version = "0.4.7"
+criteria = "safe-to-deploy"
+
 [[exemptions.mach]]
 version = "0.3.2"
 criteria = "safe-to-deploy"
@@ -605,6 +638,18 @@ criteria = "safe-to-deploy"
 version = "0.9.0"
 criteria = "safe-to-deploy"
 
+[[exemptions.parking_lot]]
+version = "0.11.2"
+criteria = "safe-to-deploy"
+
+[[exemptions.parking_lot_core]]
+version = "0.8.5"
+criteria = "safe-to-deploy"
+
+[[exemptions.paste]]
+version = "1.0.7"
+criteria = "safe-to-deploy"
+
 [[exemptions.pem-rfc7468]]
 version = "0.2.4"
 criteria = "safe-to-deploy"
@@ -762,10 +807,30 @@ criteria = "safe-to-deploy"
 version = "0.3.0"
 criteria = "safe-to-deploy"
 
+[[exemptions.ryu]]
+version = "1.0.9"
+criteria = "safe-to-deploy"
+
 [[exemptions.same-file]]
 version = "1.0.6"
 criteria = "safe-to-deploy"
 
+[[exemptions.scopeguard]]
+version = "1.1.0"
+criteria = "safe-to-deploy"
+
+[[exemptions.serde]]
+version = "1.0.137"
+criteria = "safe-to-deploy"
+
+[[exemptions.serde_derive]]
+version = "1.0.137"
+criteria = "safe-to-deploy"
+
+[[exemptions.serde_json]]
+version = "1.0.80"
+criteria = "safe-to-deploy"
+
 [[exemptions.sha2]]
 version = "0.9.9"
 criteria = "safe-to-deploy"
@@ -826,6 +891,10 @@ criteria = "safe-to-deploy"
 version = "5.0.3"
 criteria = "safe-to-run"
 
+[[exemptions.syn]]
+version = "1.0.92"
+criteria = "safe-to-deploy"
+
 [[exemptions.target-lexicon]]
 version = "0.12.3"
 criteria = "safe-to-deploy"
@@ -846,6 +915,14 @@ criteria = "safe-to-deploy"
 version = "0.15.0"
 criteria = "safe-to-deploy"
 
+[[exemptions.thiserror]]
+version = "1.0.31"
+criteria = "safe-to-deploy"
+
+[[exemptions.thiserror-impl]]
+version = "1.0.31"
+criteria = "safe-to-deploy"
+
 [[exemptions.thread_local]]
 version = "1.1.4"
 criteria = "safe-to-run"
@@ -863,6 +940,10 @@ notes = "we are exempting tokio, hyper, and their tightly coupled dependencies b
 version = "1.7.0"
 criteria = "safe-to-deploy"
 
+[[exemptions.toml]]
+version = "0.5.9"
+criteria = "safe-to-deploy"
+
 [[exemptions.tracing]]
 version = "0.1.34"
 criteria = "safe-to-deploy"
@@ -888,7 +969,7 @@ version = "1.0.0"
 criteria = "safe-to-deploy"
 
 [[exemptions.v8]]
-version = "0.74.1"
+version = "0.44.3"
 criteria = "safe-to-run"
 
 [[exemptions.wait-timeout]]
diff --git a/supply-chain/imports.lock b/supply-chain/imports.lock
index b81d69fc1..028fe833b 100644
--- a/supply-chain/imports.lock
+++ b/supply-chain/imports.lock
@@ -5,386 +5,194 @@
 version = "0.98.0"
 audited_as = "0.97.1"
 
-[[unpublished.cranelift]]
-version = "0.99.0"
-audited_as = "0.97.1"
-
 [[unpublished.cranelift-bforest]]
 version = "0.98.0"
 audited_as = "0.97.1"
 
-[[unpublished.cranelift-bforest]]
-version = "0.99.0"
-audited_as = "0.97.1"
-
 [[unpublished.cranelift-codegen]]
 version = "0.98.0"
 audited_as = "0.97.1"
 
-[[unpublished.cranelift-codegen]]
-version = "0.99.0"
-audited_as = "0.97.1"
-
 [[unpublished.cranelift-codegen-meta]]
 version = "0.98.0"
 audited_as = "0.97.1"
 
-[[unpublished.cranelift-codegen-meta]]
-version = "0.99.0"
-audited_as = "0.97.1"
-
 [[unpublished.cranelift-codegen-shared]]
 version = "0.98.0"
 audited_as = "0.97.1"
 
-[[unpublished.cranelift-codegen-shared]]
-version = "0.99.0"
-audited_as = "0.97.1"
-
 [[unpublished.cranelift-control]]
 version = "0.98.0"
 audited_as = "0.97.1"
 
-[[unpublished.cranelift-control]]
-version = "0.99.0"
-audited_as = "0.97.1"
-
 [[unpublished.cranelift-entity]]
 version = "0.98.0"
 audited_as = "0.97.1"
 
-[[unpublished.cranelift-entity]]
-version = "0.99.0"
-audited_as = "0.97.1"
-
 [[unpublished.cranelift-frontend]]
 version = "0.98.0"
 audited_as = "0.97.1"
 
-[[unpublished.cranelift-frontend]]
-version = "0.99.0"
-audited_as = "0.97.1"
-
 [[unpublished.cranelift-interpreter]]
 version = "0.98.0"
 audited_as = "0.97.1"
 
-[[unpublished.cranelift-interpreter]]
-version = "0.99.0"
-audited_as = "0.97.1"
-
 [[unpublished.cranelift-isle]]
 version = "0.98.0"
 audited_as = "0.97.1"
 
-[[unpublished.cranelift-isle]]
-version = "0.99.0"
-audited_as = "0.97.1"
-
 [[unpublished.cranelift-jit]]
 version = "0.98.0"
 audited_as = "0.97.1"
 
-[[unpublished.cranelift-jit]]
-version = "0.99.0"
-audited_as = "0.97.1"
-
 [[unpublished.cranelift-module]]
 version = "0.98.0"
 audited_as = "0.97.1"
 
-[[unpublished.cranelift-module]]
-version = "0.99.0"
-audited_as = "0.97.1"
-
 [[unpublished.cranelift-native]]
 version = "0.98.0"
 audited_as = "0.97.1"
 
-[[unpublished.cranelift-native]]
-version = "0.99.0"
-audited_as = "0.97.1"
-
 [[unpublished.cranelift-object]]
 version = "0.98.0"
 audited_as = "0.97.1"
 
-[[unpublished.cranelift-object]]
-version = "0.99.0"
-audited_as = "0.97.1"
-
 [[unpublished.cranelift-reader]]
 version = "0.98.0"
 audited_as = "0.97.1"
 
-[[unpublished.cranelift-reader]]
-version = "0.99.0"
-audited_as = "0.97.1"
-
 [[unpublished.cranelift-serde]]
 version = "0.98.0"
 audited_as = "0.97.1"
 
-[[unpublished.cranelift-serde]]
-version = "0.99.0"
-audited_as = "0.97.1"
-
 [[unpublished.cranelift-wasm]]
 version = "0.98.0"
 audited_as = "0.97.1"
 
-[[unpublished.cranelift-wasm]]
-version = "0.99.0"
-audited_as = "0.97.1"
-
 [[unpublished.wasi-cap-std-sync]]
 version = "11.0.0"
 audited_as = "10.0.1"
 
-[[unpublished.wasi-cap-std-sync]]
-version = "12.0.0"
-audited_as = "10.0.1"
-
 [[unpublished.wasi-common]]
 version = "11.0.0"
 audited_as = "10.0.1"
 
-[[unpublished.wasi-common]]
-version = "12.0.0"
-audited_as = "10.0.1"
-
 [[unpublished.wasi-tokio]]
 version = "11.0.0"
 audited_as = "10.0.1"
 
-[[unpublished.wasi-tokio]]
-version = "12.0.0"
-audited_as = "10.0.1"
-
 [[unpublished.wasmtime]]
 version = "11.0.0"
 audited_as = "10.0.1"
 
-[[unpublished.wasmtime]]
-version = "12.0.0"
-audited_as = "10.0.1"
-
 [[unpublished.wasmtime-asm-macros]]
 version = "11.0.0"
 audited_as = "10.0.1"
 
-[[unpublished.wasmtime-asm-macros]]
-version = "12.0.0"
-audited_as = "10.0.1"
-
 [[unpublished.wasmtime-cache]]
 version = "11.0.0"
 audited_as = "10.0.1"
 
-[[unpublished.wasmtime-cache]]
-version = "12.0.0"
-audited_as = "10.0.1"
-
 [[unpublished.wasmtime-cli]]
 version = "11.0.0"
 audited_as = "10.0.1"
 
-[[unpublished.wasmtime-cli]]
-version = "12.0.0"
-audited_as = "10.0.1"
-
 [[unpublished.wasmtime-cli-flags]]
 version = "11.0.0"
 audited_as = "10.0.1"
 
-[[unpublished.wasmtime-cli-flags]]
-version = "12.0.0"
-audited_as = "10.0.1"
-
 [[unpublished.wasmtime-component-macro]]
 version = "11.0.0"
 audited_as = "10.0.1"
 
-[[unpublished.wasmtime-component-macro]]
-version = "12.0.0"
-audited_as = "10.0.1"
-
 [[unpublished.wasmtime-component-util]]
 version = "11.0.0"
 audited_as = "10.0.1"
 
-[[unpublished.wasmtime-component-util]]
-version = "12.0.0"
-audited_as = "10.0.1"
-
 [[unpublished.wasmtime-cranelift]]
 version = "11.0.0"
 audited_as = "10.0.1"
 
-[[unpublished.wasmtime-cranelift]]
-version = "12.0.0"
-audited_as = "10.0.1"
-
 [[unpublished.wasmtime-cranelift-shared]]
 version = "11.0.0"
 audited_as = "10.0.1"
 
-[[unpublished.wasmtime-cranelift-shared]]
-version = "12.0.0"
-audited_as = "10.0.1"
-
 [[unpublished.wasmtime-environ]]
 version = "11.0.0"
 audited_as = "10.0.1"
 
-[[unpublished.wasmtime-environ]]
-version = "12.0.0"
-audited_as = "10.0.1"
-
 [[unpublished.wasmtime-explorer]]
 version = "11.0.0"
 audited_as = "10.0.1"
 
-[[unpublished.wasmtime-explorer]]
-version = "12.0.0"
-audited_as = "10.0.1"
-
 [[unpublished.wasmtime-fiber]]
 version = "11.0.0"
 audited_as = "10.0.1"
 
-[[unpublished.wasmtime-fiber]]
-version = "12.0.0"
-audited_as = "10.0.1"
-
 [[unpublished.wasmtime-jit]]
 version = "11.0.0"
 audited_as = "10.0.1"
 
-[[unpublished.wasmtime-jit]]
-version = "12.0.0"
-audited_as = "10.0.1"
-
 [[unpublished.wasmtime-jit-debug]]
 version = "11.0.0"
 audited_as = "10.0.1"
 
-[[unpublished.wasmtime-jit-debug]]
-version = "12.0.0"
-audited_as = "10.0.1"
-
 [[unpublished.wasmtime-jit-icache-coherence]]
 version = "11.0.0"
 audited_as = "10.0.1"
 
-[[unpublished.wasmtime-jit-icache-coherence]]
-version = "12.0.0"
-audited_as = "10.0.1"
-
 [[unpublished.wasmtime-runtime]]
 version = "11.0.0"
 audited_as = "10.0.1"
 
-[[unpublished.wasmtime-runtime]]
-version = "12.0.0"
-audited_as = "10.0.1"
-
 [[unpublished.wasmtime-types]]
 version = "11.0.0"
 audited_as = "10.0.1"
 
-[[unpublished.wasmtime-types]]
-version = "12.0.0"
-audited_as = "10.0.1"
-
 [[unpublished.wasmtime-wasi]]
 version = "11.0.0"
 audited_as = "10.0.1"
 
-[[unpublished.wasmtime-wasi]]
-version = "12.0.0"
-audited_as = "10.0.1"
-
 [[unpublished.wasmtime-wasi-crypto]]
 version = "11.0.0"
 audited_as = "10.0.1"
 
-[[unpublished.wasmtime-wasi-crypto]]
-version = "12.0.0"
-audited_as = "10.0.1"
-
 [[unpublished.wasmtime-wasi-http]]
 version = "11.0.0"
 audited_as = "10.0.1"
 
-[[unpublished.wasmtime-wasi-http]]
-version = "12.0.0"
-audited_as = "10.0.1"
-
 [[unpublished.wasmtime-wasi-nn]]
 version = "11.0.0"
 audited_as = "10.0.1"
 
-[[unpublished.wasmtime-wasi-nn]]
-version = "12.0.0"
-audited_as = "10.0.1"
-
 [[unpublished.wasmtime-wasi-threads]]
 version = "11.0.0"
 audited_as = "10.0.1"
 
-[[unpublished.wasmtime-wasi-threads]]
-version = "12.0.0"
-audited_as = "10.0.1"
-
 [[unpublished.wasmtime-wast]]
 version = "11.0.0"
 audited_as = "10.0.1"
 
-[[unpublished.wasmtime-wast]]
-version = "12.0.0"
-audited_as = "10.0.1"
-
 [[unpublished.wasmtime-winch]]
 version = "11.0.0"
 audited_as = "10.0.1"
 
-[[unpublished.wasmtime-winch]]
-version = "12.0.0"
-audited_as = "10.0.1"
-
 [[unpublished.wasmtime-wit-bindgen]]
 version = "11.0.0"
 audited_as = "10.0.1"
 
-[[unpublished.wasmtime-wit-bindgen]]
-version = "12.0.0"
-audited_as = "10.0.1"
-
 [[unpublished.wiggle]]
 version = "11.0.0"
 audited_as = "10.0.1"
 
-[[unpublished.wiggle]]
-version = "12.0.0"
-audited_as = "10.0.1"
-
 [[unpublished.wiggle-generate]]
 version = "11.0.0"
 audited_as = "10.0.1"
 
-[[unpublished.wiggle-generate]]
-version = "12.0.0"
-audited_as = "10.0.1"
-
 [[unpublished.wiggle-macro]]
 version = "11.0.0"
 audited_as = "10.0.1"
 
-[[unpublished.wiggle-macro]]
-version = "12.0.0"
-audited_as = "10.0.1"
-
 [[unpublished.wiggle-test]]
 version = "0.0.0"
 audited_as = "0.1.0"
@@ -393,10 +201,6 @@ audited_as = "0.1.0"
 version = "0.9.0"
 audited_as = "0.8.1"
 
-[[unpublished.winch-codegen]]
-version = "0.10.0"
-audited_as = "0.8.1"
-
 [[publisher.arbitrary]]
 version = "1.3.0"
 when = "2023-03-13"
@@ -404,13 +208,6 @@ user-id = 696
 user-login = "fitzgen"
 user-name = "Nick Fitzgerald"
 
-[[publisher.async-trait]]
-version = "0.1.53"
-when = "2022-03-25"
-user-id = 3618
-user-login = "dtolnay"
-user-name = "David Tolnay"
-
 [[publisher.bumpalo]]
 version = "3.12.0"
 when = "2023-01-17"
@@ -418,27 +215,6 @@ user-id = 696
 user-login = "fitzgen"
 user-name = "Nick Fitzgerald"
 
-[[publisher.clap]]
-version = "3.2.8"
-when = "2022-06-30"
-user-id = 6743
-user-login = "epage"
-user-name = "Ed Page"
-
-[[publisher.clap_derive]]
-version = "3.2.7"
-when = "2022-06-28"
-user-id = 6743
-user-login = "epage"
-user-name = "Ed Page"
-
-[[publisher.clap_lex]]
-version = "0.2.4"
-when = "2022-06-28"
-user-id = 6743
-user-login = "epage"
-user-name = "Ed Page"
-
 [[publisher.cranelift]]
 version = "0.97.1"
 when = "2023-06-21"
@@ -548,90 +324,6 @@ user-id = 696
 user-login = "fitzgen"
 user-name = "Nick Fitzgerald"
 
-[[publisher.equivalent]]
-version = "1.0.1"
-when = "2023-07-10"
-user-id = 539
-user-login = "cuviper"
-user-name = "Josh Stone"
-
-[[publisher.hashbrown]]
-version = "0.14.0"
-when = "2023-06-05"
-user-id = 2915
-user-login = "Amanieu"
-user-name = "Amanieu d'Antras"
-
-[[publisher.indexmap]]
-version = "1.9.1"
-when = "2022-06-21"
-user-id = 539
-user-login = "cuviper"
-user-name = "Josh Stone"
-
-[[publisher.indexmap]]
-version = "2.0.0"
-when = "2023-06-23"
-user-id = 539
-user-login = "cuviper"
-user-name = "Josh Stone"
-
-[[publisher.itoa]]
-version = "1.0.1"
-when = "2021-12-12"
-user-id = 3618
-user-login = "dtolnay"
-user-name = "David Tolnay"
-
-[[publisher.libc]]
-version = "0.2.132"
-when = "2022-08-16"
-user-id = 2915
-user-login = "Amanieu"
-user-name = "Amanieu d'Antras"
-
-[[publisher.libm]]
-version = "0.2.7"
-when = "2023-05-15"
-user-id = 2915
-user-login = "Amanieu"
-user-name = "Amanieu d'Antras"
-
-[[publisher.lock_api]]
-version = "0.4.7"
-when = "2022-03-30"
-user-id = 2915
-user-login = "Amanieu"
-user-name = "Amanieu d'Antras"
-
-[[publisher.parking_lot]]
-version = "0.11.2"
-when = "2021-08-27"
-user-id = 2915
-user-login = "Amanieu"
-user-name = "Amanieu d'Antras"
-
-[[publisher.parking_lot_core]]
-version = "0.8.5"
-when = "2021-08-28"
-user-id = 2915
-user-login = "Amanieu"
-user-name = "Amanieu d'Antras"
-
-[[publisher.paste]]
-version = "1.0.7"
-when = "2022-03-27"
-user-id = 3618
-user-login = "dtolnay"
-user-name = "David Tolnay"
-
-[[publisher.quote]]
-version = "1.0.29"
-when = "2023-06-29"
-user-id = 3618
-user-login = "dtolnay"
-user-name = "David Tolnay"
-
 [[publisher.regalloc2]]
 version = "0.9.1"
 when = "2023-05-31"
@@ -639,103 +331,6 @@ user-id = 187138
 user-login = "elliottt"
 user-name = "Trevor Elliott"
 
-[[publisher.ryu]]
-version = "1.0.9"
-when = "2021-12-12"
-user-id = 3618
-user-login = "dtolnay"
-user-name = "David Tolnay"
-
-[[publisher.scopeguard]]
-version = "1.1.0"
-when = "2020-02-16"
-user-id = 2915
-user-login = "Amanieu"
-user-name = "Amanieu d'Antras"
-
-[[publisher.serde]]
-version = "1.0.137"
-when = "2022-05-01"
-user-id = 3618
-user-login = "dtolnay"
-user-name = "David Tolnay"
-
-[[publisher.serde]]
-version = "1.0.171"
-when = "2023-07-10"
-user-id = 3618
-user-login = "dtolnay"
-user-name = "David Tolnay"
-
-[[publisher.serde_derive]]
-version = "1.0.137"
-when = "2022-05-01"
-user-id = 3618
-user-login = "dtolnay"
-user-name = "David Tolnay"
-
-[[publisher.serde_derive]]
-version = "1.0.171"
-when = "2023-07-10"
-user-id = 3618
-user-login = "dtolnay"
-user-name = "David Tolnay"
-
-[[publisher.serde_json]]
-version = "1.0.80"
-when = "2022-04-30"
-user-id = 3618
-user-login = "dtolnay"
-user-name = "David Tolnay"
-
-[[publisher.spdx]]
-version = "0.10.1"
-when = "2023-04-06"
-user-id = 52553
-user-login = "embark-studios"
-
-[[publisher.syn]]
-version = "1.0.92"
-when = "2022-04-29"
-user-id = 3618
-user-login = "dtolnay"
-user-name = "David Tolnay"
-
-[[publisher.syn]]
-version = "2.0.16"
-when = "2023-05-14"
-user-id = 3618
-user-login = "dtolnay"
-user-name = "David Tolnay"
-
-[[publisher.syn]]
-version = "2.0.25"
-when = "2023-07-09"
-user-id = 3618
-user-login = "dtolnay"
-user-name = "David Tolnay"
-
-[[publisher.thiserror]]
-version = "1.0.31"
-when = "2022-04-30"
-user-id = 3618
-user-login = "dtolnay"
-user-name = "David Tolnay"
-
-[[publisher.thiserror-impl]]
-version = "1.0.31"
-when = "2022-04-30"
-user-id = 3618
-user-login = "dtolnay"
-user-name = "David Tolnay"
-
-[[publisher.toml]]
-version = "0.5.7"
-when = "2020-10-11"
-user-id = 1
-user-login = "alexcrichton"
-user-name = "Alex Crichton"
-
 [[publisher.unicode-segmentation]]
 version = "1.10.1"
 when = "2023-01-31"
@@ -782,13 +377,6 @@ user-id = 1
 user-login = "alexcrichton"
 user-name = "Alex Crichton"
 
-[[publisher.wasm-encoder]]
-version = "0.30.0"
-when = "2023-07-11"
-user-id = 1
-user-login = "alexcrichton"
-user-name = "Alex Crichton"
-
 [[publisher.wasm-metadata]]
 version = "0.8.0"
 when = "2023-05-26"
@@ -796,13 +384,6 @@ user-id = 1
 user-login = "alexcrichton"
 user-name = "Alex Crichton"
 
-[[publisher.wasm-metadata]]
-version = "0.9.0"
-when = "2023-07-11"
-user-id = 1
-user-login = "alexcrichton"
-user-name = "Alex Crichton"
-
 [[publisher.wasm-mutate]]
 version = "0.2.27"
 when = "2023-05-26"
@@ -810,13 +391,6 @@ user-id = 1
 user-login = "alexcrichton"
 user-name = "Alex Crichton"
 
-[[publisher.wasm-mutate]]
-version = "0.2.28"
-when = "2023-07-11"
-user-id = 1
-user-login = "alexcrichton"
-user-name = "Alex Crichton"
-
 [[publisher.wasm-smith]]
 version = "0.12.10"
 when = "2023-05-26"
@@ -824,13 +398,6 @@ user-id = 1
 user-login = "alexcrichton"
 user-name = "Alex Crichton"
 
-[[publisher.wasm-smith]]
-version = "0.12.11"
-when = "2023-07-11"
-user-id = 1
-user-login = "alexcrichton"
-user-name = "Alex Crichton"
-
 [[publisher.wasmparser]]
 version = "0.107.0"
 when = "2023-05-26"
@@ -838,13 +405,6 @@ user-id = 1
 user-login = "alexcrichton"
 user-name = "Alex Crichton"
 
-[[publisher.wasmparser]]
-version = "0.108.0"
-when = "2023-07-11"
-user-id = 1
-user-login = "alexcrichton"
-user-name = "Alex Crichton"
-
 [[publisher.wasmprinter]]
 version = "0.2.59"
 when = "2023-05-26"
@@ -852,13 +412,6 @@ user-id = 1
 user-login = "alexcrichton"
 user-name = "Alex Crichton"
 
-[[publisher.wasmprinter]]
-version = "0.2.60"
-when = "2023-07-11"
-user-id = 1
-user-login = "alexcrichton"
-user-name = "Alex Crichton"
-
 [[publisher.wasmtime]]
 version = "10.0.1"
 when = "2023-06-21"
@@ -1016,13 +569,6 @@ user-id = 1
 user-login = "alexcrichton"
 user-name = "Alex Crichton"
 
-[[publisher.wast]]
-version = "61.0.0"
-when = "2023-07-11"
-user-id = 1
-user-login = "alexcrichton"
-user-name = "Alex Crichton"
-
 [[publisher.wat]]
 version = "1.0.66"
 when = "2023-05-26"
@@ -1030,13 +576,6 @@ user-id = 1
 user-login = "alexcrichton"
 user-name = "Alex Crichton"
 
-[[publisher.wat]]
-version = "1.0.67"
-when = "2023-07-11"
-user-id = 1
-user-login = "alexcrichton"
-user-name = "Alex Crichton"
-
 [[publisher.wiggle]]
 version = "10.0.1"
 when = "2023-06-21"
@@ -1236,13 +775,6 @@ user-id = 1
 user-login = "alexcrichton"
 user-name = "Alex Crichton"
 
-[[publisher.wit-component]]
-version = "0.12.0"
-when = "2023-07-11"
-user-id = 1
-user-login = "alexcrichton"
-user-name = "Alex Crichton"
-
 [[publisher.wit-parser]]
 version = "0.8.0"
 when = "2023-05-26"
@@ -1250,21 +782,6 @@ user-id = 1
 user-login = "alexcrichton"
 user-name = "Alex Crichton"
 
-[[publisher.wit-parser]]
-version = "0.9.0"
-when = "2023-07-11"
-user-id = 1
-user-login = "alexcrichton"
-user-name = "Alex Crichton"
-
-[[audits.embark-studios.wildcard-audits.spdx]]
-who = "Jake Shadle <opensource@embark-studios.com>"
-criteria = "safe-to-deploy"
-user-id = 52553 # embark-studios
-start = "2020-01-01"
-end = "2024-05-23"
-notes = "Maintained by Embark. No unsafe usage or ambient capabilities"
-
 [[audits.embark-studios.audits.anyhow]]
 who = "Johan Andersson <opensource@embark-studios.com>"
 criteria = "safe-to-deploy"
@@ -1360,21 +877,6 @@ who = "David Cook <dcook@divviup.org>"
 criteria = "safe-to-deploy"
 version = "0.9.0"
 
-[[audits.isrg.audits.libc]]
-who = "Brandon Pitman <bran@bran.land>"
-criteria = "safe-to-deploy"
-delta = "0.2.139 -> 0.2.141"
-
-[[audits.isrg.audits.once_cell]]
-who = "Brandon Pitman <bran@bran.land>"
-criteria = "safe-to-deploy"
-delta = "1.17.1 -> 1.17.2"
-
-[[audits.isrg.audits.once_cell]]
-who = "David Cook <dcook@divviup.org>"
-criteria = "safe-to-deploy"
-delta = "1.17.2 -> 1.18.0"
-
 [[audits.isrg.audits.opaque-debug]]
 who = "David Cook <dcook@divviup.org>"
 criteria = "safe-to-deploy"
@@ -1599,18 +1101,6 @@ version = "1.4.0"
 notes = "I have read over the macros, and audited the unsafe code."
 aggregated-from = "https://raw.githubusercontent.com/mozilla/cargo-vet/main/supply-chain/audits.toml"
 
-[[audits.mozilla.audits.libc]]
-who = "Mike Hommey <mh+mozilla@glandium.org>"
-criteria = "safe-to-deploy"
-delta = "0.2.132 -> 0.2.138"
-aggregated-from = "https://hg.mozilla.org/mozilla-central/raw-file/tip/supply-chain/audits.toml"
-
-[[audits.mozilla.audits.libc]]
-who = "Mike Hommey <mh+mozilla@glandium.org>"
-criteria = "safe-to-deploy"
-delta = "0.2.138 -> 0.2.139"
-aggregated-from = "https://hg.mozilla.org/mozilla-central/raw-file/tip/supply-chain/audits.toml"
-
 [[audits.mozilla.audits.log]]
 who = "Mike Hommey <mh+mozilla@glandium.org>"
 criteria = "safe-to-deploy"
@@ -1668,12 +1158,6 @@ criteria = "safe-to-deploy"
 delta = "1.13.1 -> 1.16.0"
 aggregated-from = "https://hg.mozilla.org/mozilla-central/raw-file/tip/supply-chain/audits.toml"
 
-[[audits.mozilla.audits.once_cell]]
-who = "Mike Hommey <mh+mozilla@glandium.org>"
-criteria = "safe-to-deploy"
-delta = "1.16.0 -> 1.17.1"
-aggregated-from = "https://hg.mozilla.org/mozilla-central/raw-file/tip/supply-chain/audits.toml"
-
 [[audits.mozilla.audits.proc-macro2]]
 who = "Nika Layzell <nika@thelayzells.com>"
 criteria = "safe-to-deploy"
@@ -1722,13 +1206,6 @@ criteria = "safe-to-deploy"
 delta = "1.0.49 -> 1.0.51"
 aggregated-from = "https://hg.mozilla.org/mozilla-central/raw-file/tip/supply-chain/audits.toml"
 
-[[audits.mozilla.audits.proc-macro2]]
-who = "Jan-Erik Rediger <jrediger@mozilla.com>"
-criteria = "safe-to-deploy"
-delta = "1.0.57 -> 1.0.59"
-notes = "Enabled on Wasm"
-aggregated-from = "https://raw.githubusercontent.com/mozilla/glean/main/supply-chain/audits.toml"
-
 [[audits.mozilla.audits.quote]]
 who = "Nika Layzell <nika@thelayzells.com>"
 criteria = "safe-to-deploy"
@@ -1811,12 +1288,6 @@ harmless. It will be removed in the next version.
 """
 aggregated-from = "https://hg.mozilla.org/mozilla-central/raw-file/tip/supply-chain/audits.toml"
 
-[[audits.mozilla.audits.toml]]
-who = "Bobby Holley <bobbyholley@gmail.com>"
-criteria = "safe-to-deploy"
-delta = "0.5.7 -> 0.5.9"
-aggregated-from = "https://hg.mozilla.org/mozilla-central/raw-file/tip/supply-chain/audits.toml"
-
 [[audits.mozilla.audits.unicode-normalization]]
 who = "Mike Hommey <mh+mozilla@glandium.org>"
 criteria = "safe-to-deploy"
diff --git a/tests/all/component_model/aot.rs b/tests/all/component_model/aot.rs
index df6e0b663..3b03aef23 100644
--- a/tests/all/component_model/aot.rs
+++ b/tests/all/component_model/aot.rs
@@ -98,24 +98,3 @@ fn cannot_serialize_exported_module() -> Result<()> {
     assert!(module.serialize().is_err());
     Ok(())
 }
-
-#[test]
-fn usable_exported_modules() -> Result<()> {
-    let engine = super::engine();
-    let component = Component::new(
-        &engine,
-        r#"(component
-            (core module $m)
-            (core module $m1 (export "a")
-                (import "" "" (func (param i32)))
-            )
-        )"#,
-    )?;
-    let mut store = Store::new(&engine, ());
-    let instance = Linker::new(&engine).instantiate(&mut store, &component)?;
-    let module = instance.get_module(&mut store, "a").unwrap();
-    let mut core_linker = wasmtime::Linker::new(&engine);
-    core_linker.func_wrap("", "", |_: u32| {})?;
-    core_linker.instantiate(&mut store, &module)?;
-    Ok(())
-}
diff --git a/tests/all/component_model/import.rs b/tests/all/component_model/import.rs
index 705348e9d..be5ba39be 100644
--- a/tests/all/component_model/import.rs
+++ b/tests/all/component_model/import.rs
@@ -169,111 +169,6 @@ fn simple() -> Result<()> {
     Ok(())
 }
 
-#[test]
-fn functions_in_instances() -> Result<()> {
-    let component = r#"
-        (component
-            (type $import-type (instance
-                (export "a" (func (param "a" string)))
-            ))
-            (import (interface "test:test/foo") (instance $import (type $import-type)))
-            (alias export $import "a" (func $log))
-
-            (core module $libc
-                (memory (export "memory") 1)
-
-                (func (export "realloc") (param i32 i32 i32 i32) (result i32)
-                    unreachable)
-            )
-            (core instance $libc (instantiate $libc))
-            (core func $log_lower
-                (canon lower (func $log) (memory $libc "memory") (realloc (func $libc "realloc")))
-            )
-            (core module $m
-                (import "libc" "memory" (memory 1))
-                (import "host" "log" (func $log (param i32 i32)))
-
-                (func (export "call")
-                    i32.const 5
-                    i32.const 11
-                    call $log)
-
-                (data (i32.const 5) "hello world")
-            )
-            (core instance $i (instantiate $m
-                (with "libc" (instance $libc))
-                (with "host" (instance (export "log" (func $log_lower))))
-            ))
-            (func $call
-                (canon lift (core func $i "call"))
-            )
-            (component $c
-                (import "import-call" (func $f))
-                (export "call" (func $f))
-            )
-            (instance $export (instantiate $c
-                (with "import-call" (func $call))
-            ))
-            (export (interface "test:test/foo") (instance $export))
-        )
-    "#;
-
-    let engine = super::engine();
-    let component = Component::new(&engine, component)?;
-    let mut store = Store::new(&engine, None);
-    assert!(store.data().is_none());
-
-    // First, test the static API
-
-    let mut linker = Linker::new(&engine);
-    linker.instance("test:test/foo")?.func_wrap(
-        "a",
-        |mut store: StoreContextMut<'_, Option<String>>, (arg,): (WasmStr,)| -> Result<_> {
-            let s = arg.to_str(&store)?.to_string();
-            assert!(store.data().is_none());
-            *store.data_mut() = Some(s);
-            Ok(())
-        },
-    )?;
-    let instance = linker.instantiate(&mut store, &component)?;
-    let func = instance
-        .exports(&mut store)
-        .instance("test:test/foo")
-        .unwrap()
-        .typed_func::<(), ()>("call")?;
-    func.call(&mut store, ())?;
-    assert_eq!(store.data().as_ref().unwrap(), "hello world");
-
-    // Next, test the dynamic API
-
-    *store.data_mut() = None;
-    let mut linker = Linker::new(&engine);
-    linker.instance("test:test/foo")?.func_new(
-        &component,
-        "a",
-        |mut store: StoreContextMut<'_, Option<String>>, args, _results| {
-            if let Val::String(s) = &args[0] {
-                assert!(store.data().is_none());
-                *store.data_mut() = Some(s.to_string());
-                Ok(())
-            } else {
-                panic!()
-            }
-        },
-    )?;
-    let instance = linker.instantiate(&mut store, &component)?;
-    let func = instance
-        .exports(&mut store)
-        .instance("test:test/foo")
-        .unwrap()
-        .func("call")
-        .unwrap();
-    func.call(&mut store, &[], &mut [])?;
-    assert_eq!(store.data().as_ref().unwrap(), "hello world");
-
-    Ok(())
-}
-
 #[test]
 fn attempt_to_leave_during_malloc() -> Result<()> {
     let component = r#"
diff --git a/tests/all/pooling_allocator.rs b/tests/all/pooling_allocator.rs
index 004a2069b..c34e7896d 100644
--- a/tests/all/pooling_allocator.rs
+++ b/tests/all/pooling_allocator.rs
@@ -665,6 +665,8 @@ fn switch_image_and_non_image() -> Result<()> {
     Ok(())
 }
 
+// NOTE(dhil): this test is sensitive to the layout and (potentially
+// naming of fields) in crates/environ/src/vmoffsets.rs
 #[test]
 #[cfg(target_pointer_width = "64")]
 #[cfg_attr(miri, ignore)]
@@ -676,11 +678,11 @@ fn instance_too_large() -> Result<()> {
 
     let engine = Engine::new(&config)?;
     let expected = "\
-instance allocation for this module requires 240 bytes which exceeds the \
+instance allocation for this module requires 272 bytes which exceeds the \
 configured maximum of 16 bytes; breakdown of allocation requirement:
 
- * 66.67% - 160 bytes - instance state management
- * 6.67% - 16 bytes - jit store state
+ * 64.71% - 176 bytes - instance state management
+ * 5.88% - 16 bytes - jit store state
 ";
     match Module::new(&engine, "(module)") {
         Ok(_) => panic!("should have failed to compile"),
@@ -694,11 +696,11 @@ configured maximum of 16 bytes; breakdown of allocation requirement:
     lots_of_globals.push_str(")");
 
     let expected = "\
-instance allocation for this module requires 1840 bytes which exceeds the \
+instance allocation for this module requires 1872 bytes which exceeds the \
 configured maximum of 16 bytes; breakdown of allocation requirement:
 
- * 8.70% - 160 bytes - instance state management
- * 86.96% - 1600 bytes - defined globals
+ * 9.40% - 176 bytes - instance state management
+ * 85.47% - 1600 bytes - defined globals
 ";
     match Module::new(&engine, &lots_of_globals) {
         Ok(_) => panic!("should have failed to compile"),
diff --git a/tests/all/wast.rs b/tests/all/wast.rs
index b43c17c2b..6a140c716 100644
--- a/tests/all/wast.rs
+++ b/tests/all/wast.rs
@@ -19,12 +19,19 @@ fn run_wast(wast: &str, strategy: Strategy, pooling: bool) -> anyhow::Result<()>
 
     let wast_bytes = std::fs::read(wast).with_context(|| format!("failed to read `{}`", wast))?;
 
+    match strategy {
+        Strategy::Cranelift => {}
+        _ => unimplemented!(),
+    }
+
     let wast = Path::new(wast);
 
     let memory64 = feature_found(wast, "memory64");
     let multi_memory = feature_found(wast, "multi-memory");
     let threads = feature_found(wast, "threads");
-    let function_references = feature_found(wast, "function-references");
+    let typed_continuations = feature_found(wast, "typed-continuations");
+    let exceptions = feature_found(wast, "exception-handling") || typed_continuations;
+    let function_references = feature_found(wast, "function-references") || typed_continuations;
     let reference_types = !(threads && feature_found(wast, "proposals"));
     let relaxed_simd = feature_found(wast, "relaxed-simd");
     let use_shared_memory = feature_found_src(&wast_bytes, "shared_memory")
@@ -35,11 +42,6 @@ fn run_wast(wast: &str, strategy: Strategy, pooling: bool) -> anyhow::Result<()>
         return Ok(());
     }
 
-    let is_cranelift = match strategy {
-        Strategy::Cranelift => true,
-        _ => false,
-    };
-
     let mut cfg = Config::new();
     cfg.wasm_multi_memory(multi_memory)
         .wasm_threads(threads)
@@ -47,15 +49,13 @@ fn run_wast(wast: &str, strategy: Strategy, pooling: bool) -> anyhow::Result<()>
         .wasm_function_references(function_references)
         .wasm_reference_types(reference_types)
         .wasm_relaxed_simd(relaxed_simd)
-        .strategy(strategy);
-
-    if is_cranelift {
-        cfg.cranelift_debug_verifier(true);
-    }
+        .wasm_exceptions(exceptions)
+        .wasm_typed_continuations(typed_continuations)
+        .cranelift_debug_verifier(true);
 
     cfg.wasm_component_model(feature_found(wast, "component-model"));
 
-    if feature_found(wast, "canonicalize-nan") && is_cranelift {
+    if feature_found(wast, "canonicalize-nan") {
         cfg.cranelift_nan_canonicalization(true);
     }
     let test_allocates_lots_of_memory = wast.ends_with("more-than-4gb.wast");
diff --git a/tests/misc_testsuite/typed-continuations/cont_args.wast b/tests/misc_testsuite/typed-continuations/cont_args.wast
new file mode 100644
index 000000000..a78036801
--- /dev/null
+++ b/tests/misc_testsuite/typed-continuations/cont_args.wast
@@ -0,0 +1,104 @@
+;; This file tests passing arguments to functions used has continuations and
+;; returning values from such continuations on ordinary (i.e., non-suspend) exit
+
+(module
+
+  (type $unit_to_unit (func))
+  (type $unit_to_int (func (result i32)))
+  (type $int_to_unit (func (param i32)))
+  (type $int_to_int (func (param i32) (result i32)))
+
+
+  (type $f1_t (func (param i32) (result i32)))
+  (type $f1_ct (cont $f1_t))
+
+  (type $f2_t (func (param i32) (result i32)))
+  (type $f2_ct (cont $f2_t))
+
+  (type $f3_t (func (param i32) (result i32)))
+  (type $f3_ct (cont $f3_t))
+
+  (type $res_unit_to_unit (cont $unit_to_unit))
+  (type $res_int_to_unit (cont $int_to_unit))
+  (type $res_int_to_int (cont $int_to_int))
+  (type $res_unit_to_int (cont $unit_to_int))
+
+  (tag $e1_unit_to_unit)
+  (tag $e2_int_to_unit (param i32))
+  (tag $e3_int_to_int (param i32) (result i32))
+
+  (global $i (mut i32) (i32.const 0))
+
+
+  ;; Used for testing the passing of arguments to continuation function and returning values out of them
+  (func $f1 (export "f1") (param $x i32) (result i32)
+    (global.set  $i (i32.add (global.get $i) (local.get $x)))
+    (suspend $e1_unit_to_unit)
+    (i32.add (i32.const 2) (local.get $x)))
+
+  ;; Used for testing case where no suspend happens at all
+  (func $f2 (export "f2") (param $x i32) (result i32)
+    (global.set  $i (i32.add (global.get $i) (local.get $x)))
+    (i32.add (i32.const 2) (local.get $x)))
+
+  ;; Same as $f1, but additionally passes payloads to and from handler
+  (func $f3 (export "f3") (param $x i32) (result i32)
+    (i32.add (local.get $x) (i32.const 1))
+    (suspend $e3_int_to_int)
+    ;; return x + value returned received back from $e3
+    (i32.add  (local.get $x)))
+
+
+  (func $test_case_1 (export "test_case_1") (result i32)
+    ;; remove this eventually
+    (global.set  $i (i32.const 0))
+    (block $on_e1 (result (ref $res_unit_to_int))
+      (resume $f1_ct (tag $e1_unit_to_unit $on_e1) (i32.const 100) (cont.new $f1_ct (ref.func $f1)))
+      ;; unreachable: we never intend to invoke the resumption when handling
+      ;; $e1 invoked from $f2
+      (unreachable))
+    ;; after on_e1, stack: [resumption]
+    (drop) ;; drop resumption
+    (global.get $i))
+
+  (func $test_case_2 (export "test_case_2") (result i32)
+    ;; remove this eventually
+    (global.set  $i (i32.const 0))
+    ;;(local $finish_f3 (ref $res_unit_to_unit))
+    (block $on_e1 (result (ref $res_unit_to_int))
+      (resume $f1_ct (tag $e1_unit_to_unit $on_e1) (i32.const 49) (cont.new $f1_ct (ref.func $f1)))
+      (unreachable))
+    ;; after on_e1, stack: [resumption]
+    ;;(local.set $finish_f2)
+    (resume $res_unit_to_int)
+    ;; the resume above resumes execution of f2, which finishes without further suspends
+    (i32.add (global.get $i)))
+
+(func $test_case_3 (export "test_case_3") (result i32)
+    ;; remove this eventually
+    (global.set  $i (i32.const 0))
+    (resume $f2_ct (i32.const 49) (cont.new $f2_ct (ref.func $f2)))
+    (i32.add (global.get $i)))
+
+
+(func $test_case_4 (export "test_case_4") (result i32)
+    (local $k (ref $res_int_to_int))
+
+    (block $on_e3 (result i32 (ref $res_int_to_int))
+      (resume $f3_ct (tag $e3_int_to_int $on_e3) (i32.const 49) (cont.new $f3_ct (ref.func $f3)))
+      (unreachable))
+    ;; after on_e3, expected stack: [50 resumption]
+    (local.set $k)
+
+    ;; add 1 to value 50 received from f6 via tag e3, thus passing 51 back to it
+    (i32.add (i32.const 1))
+    (resume $res_int_to_int (local.get $k))
+    ;; expecting to get 49 (original argument to function) + 51 (passed above) back
+    )
+
+)
+
+(assert_return (invoke "test_case_1") (i32.const 100))
+(assert_return (invoke "test_case_2") (i32.const 100))
+(assert_return (invoke "test_case_3") (i32.const 100))
+(assert_return (invoke "test_case_4") (i32.const 100))
diff --git a/tests/misc_testsuite/typed-continuations/cont_bind1.wast b/tests/misc_testsuite/typed-continuations/cont_bind1.wast
new file mode 100644
index 000000000..9ebb5622a
--- /dev/null
+++ b/tests/misc_testsuite/typed-continuations/cont_bind1.wast
@@ -0,0 +1,30 @@
+;; Simple test for cont.bind: cont.bind supplies 0 arguments
+
+(module
+  (type $unit_to_int (func (result i32)))
+  (type $int_int_to_int (func (param i32 i32) (result i32)))
+  (type $int_to_int (func (param i32) (result i32)))
+
+  (type $ct0 (cont $unit_to_int))
+  (type $ct1 (cont $int_int_to_int))
+
+  (tag $e)
+
+  (func $g (param $x i32) (param $y i32) (result i32)
+    (suspend $e)
+    (i32.add (local.get $x) (local.get $y)))
+  (elem declare func $g)
+
+  (func $test (export "test") (result i32)
+    (block $on_e (result (ref $ct0))
+      (i32.const 49) ;; consumed by resume
+      (i32.const 51) ;; consumed by resume
+      (cont.new $ct1 (ref.func $g))
+      (cont.bind $ct1 $ct1)
+      (resume $ct1 (tag $e $on_e))
+      (unreachable))
+    ;; on_e
+    (resume $ct0))
+)
+
+(assert_return (invoke "test") (i32.const 100))
diff --git a/tests/misc_testsuite/typed-continuations/cont_bind2.wast b/tests/misc_testsuite/typed-continuations/cont_bind2.wast
new file mode 100644
index 000000000..430a5b4f1
--- /dev/null
+++ b/tests/misc_testsuite/typed-continuations/cont_bind2.wast
@@ -0,0 +1,31 @@
+;; Simple test for cont.bind: cont.bind turns 2-arg continution into 1-arg one before calling resume
+
+(module
+  (type $unit_to_int (func (result i32)))
+  (type $int_int_to_int (func (param i32 i32) (result i32)))
+  (type $int_to_int (func (param i32) (result i32)))
+
+  (type $ct0 (cont $unit_to_int))
+  (type $ct1 (cont $int_to_int))
+  (type $ct2 (cont $int_int_to_int))
+
+  (tag $e)
+
+  (func $g (param $x i32) (param $y i32) (result i32)
+    (suspend $e)
+    (i32.add (local.get $x) (local.get $y)))
+  (elem declare func $g)
+
+  (func $test (export "test") (result i32)
+    (block $on_e (result (ref $ct0))
+      (i32.const 49) ;; consumed by resume
+      (i32.const 51) ;; consumed by cont.bind
+      (cont.new $ct2 (ref.func $g))
+      (cont.bind $ct2 $ct1)
+      (resume $ct1 (tag $e $on_e))
+      (unreachable))
+    ;; on_e
+    (resume $ct0))
+)
+
+(assert_return (invoke "test") (i32.const 100))
diff --git a/tests/misc_testsuite/typed-continuations/cont_bind3.wast b/tests/misc_testsuite/typed-continuations/cont_bind3.wast
new file mode 100644
index 000000000..e1496728b
--- /dev/null
+++ b/tests/misc_testsuite/typed-continuations/cont_bind3.wast
@@ -0,0 +1,40 @@
+;; Testing cont.bind on continuations received from suspending rather than cont.new.
+
+(module
+  (type $unit_to_int (func (result i32)))
+  (type $int_to_unit (func (param i32)))
+  (type $int_to_int (func (param i32) (result i32)))
+  (type $2int_to_int (func (param i32 i32) (result i32)))
+  (type $3int_to_int (func (param i32 i32 i32) (result i32)))
+
+  (type $ct0 (cont $unit_to_int))
+  (type $ct1 (cont $3int_to_int))
+  (type $ct2 (cont $2int_to_int))
+  (type $ct3 (cont $int_to_int))
+
+  (tag $e (param i32 i32) (result i32 i32 i32))
+
+  (func $g (result i32)
+    (suspend $e (i32.const 5) (i32.const 15))
+    (i32.add)
+    (i32.add))
+  (elem declare func $g)
+
+  (func $test (export "test") (result i32)
+    (local $k (ref $ct1))
+    (i32.const 35) ;; to be consumed by second call to cont.resume
+    (i32.const 45) ;; to be consumed by second call to cont.bind
+    (block $on_e (result i32 i32 (ref $ct1))
+      (resume $ct0 (tag $e $on_e) (cont.new  $ct0 (ref.func $g)))
+      (unreachable))
+    ;; on_e:
+    (local.set $k)
+    (i32.add) ;; add two values received from $e, leave on stack to be consumed by first call to cont.bind
+    (local.get $k)
+    (cont.bind $ct1 $ct2) ;; consumes the result (= 20) of the addition two lines earlier
+    (cont.bind $ct2 $ct3) ;; consumes the constant value 45 put on stack earlier
+    (resume $ct3) ;; consumes the constant value 35 put on stack earlier
+    )
+)
+
+(assert_return (invoke "test") (i32.const 100))
diff --git a/tests/misc_testsuite/typed-continuations/cont_bind4.wast b/tests/misc_testsuite/typed-continuations/cont_bind4.wast
new file mode 100644
index 000000000..b5fe2009a
--- /dev/null
+++ b/tests/misc_testsuite/typed-continuations/cont_bind4.wast
@@ -0,0 +1,103 @@
+;; Testing that the creation of the necessary payload buffers works as expect,
+;; even when the same continuation object is suspended multiple times
+
+(module
+  (type $unit_to_int (func (result i32)))
+  (type $int_to_unit (func (param i32)))
+  (type $int_to_int (func (param i32) (result i32)))
+  (type $2int_to_int (func (param i32 i32) (result i32)))
+  (type $3int_to_int (func (param i32 i32 i32) (result i32)))
+
+  (type $ct0 (cont $int_to_int))
+  (type $ct1 (cont $unit_to_int))
+  (type $ct2 (cont $2int_to_int))
+
+  (global $checker (mut i32) (i32.const 0))
+
+  (func $check_stack (param $expected i32) (param $actual i32) (result i32)
+    (if (result i32)
+      (i32.xor (local.get $expected) (local.get $actual))
+      (then (unreachable))
+      (else (local.get $actual))))
+
+  (func $check_stack2
+        (param $expected1 i32)
+        (param $expected2 i32)
+        (param $actual1 i32)
+        (param $actual2 i32)
+        (result i32 i32)
+    (if
+      (i32.xor (local.get $expected1) (local.get $actual1))
+      (then (unreachable))
+      (else))
+    (if
+      (i32.xor (local.get $expected2) (local.get $actual2))
+      (then (unreachable))
+      (else))
+    (local.get $actual1)
+    (local.get $actual2))
+
+
+  (tag $e (param i32) (result i32))
+  (tag $f (param i32 i32) (result i32 i32))
+
+  (func $g (param $x i32) (result i32)
+    (i32.add (local.get $x) (i32.const 1))
+    (call $check_stack (i32.const 10))
+    (suspend $e)
+    (call $check_stack (i32.const 15))
+    (i32.add (i32.const 5))
+    (call $check_stack (i32.const 20))
+    (suspend $e)
+    (call $check_stack (i32.const 25))
+    (i32.const 30)
+    (suspend $f)
+    (call $check_stack2 (i32.const 35) (i32.const 40))
+    (i32.add))
+  (elem declare func $g)
+
+  (func $test (export "test") (result i32)
+    (local $k1 (ref $ct0))
+    (local $k2 (ref $ct1))
+    (local $k3 (ref $ct2))
+    (local $i i32)
+
+    (block $on_e1 (result i32 (ref $ct0))
+      (i32.const 9)
+      (cont.new  $ct0 (ref.func $g))
+      (cont.bind $ct0 $ct1) ;; binding 9 here as value of parameter $x of $g
+      (resume $ct1 (tag $e $on_e1))
+      (unreachable))
+    (local.set $k1)
+    (call $check_stack (i32.const 10))
+    (i32.add (i32.const 5))
+    (call $check_stack (i32.const 15))
+    (cont.bind $ct0 $ct1 (local.get $k1)) ;; binding 15
+    (local.set $k2)
+
+
+    (block $on_e2 (result i32 (ref $ct0))
+      (resume $ct1 (tag $e $on_e2) (local.get $k2))
+      (unreachable))
+    (local.set $k1)
+    (call $check_stack (i32.const 20))
+    (i32.add (i32.const 5))
+    (call $check_stack (i32.const 25))
+    (cont.bind $ct0 $ct1 (local.get $k1)) ;; binding 25
+    (local.set $k2)
+    (block $on_f (result i32 i32 (ref $ct2))
+      (resume $ct1 (tag $f $on_f) (local.get $k2))
+      (unreachable))
+    (local.set $k3)
+    (call $check_stack2 (i32.const 25) (i32.const 30))
+    (i32.add (i32.const 10))
+    (local.set $i)
+    (i32.add (i32.const 10))
+    (local.get $i)
+    (call $check_stack2 (i32.const 35) (i32.const 40))
+    (local.get $k3)
+    (cont.bind $ct2 $ct1) ;; binding 35, 40
+    (resume $ct1))
+)
+
+(assert_return (invoke "test") (i32.const 75))
diff --git a/tests/misc_testsuite/typed-continuations/cont_nary.wast b/tests/misc_testsuite/typed-continuations/cont_nary.wast
new file mode 100644
index 000000000..00ea4f378
--- /dev/null
+++ b/tests/misc_testsuite/typed-continuations/cont_nary.wast
@@ -0,0 +1,89 @@
+;; Tests using support for n-ary continuations
+;; Uses a function as continuation that has 3 param and 5 return values
+;; Uses tag that has 4 elements of payloads
+;; All of these mix i32 and i64 values
+
+
+(module
+  (type $unit_to_unit (func))
+  (type $unit_to_int (func (result i32)))
+  (type $int_to_unit (func (param i32)))
+  (type $int_to_int (func (param i32) (result i32)))
+
+
+  ;; type of function f
+  (type $f_t
+        (func
+         (param i64 i32 i64)
+         (result i32 i64 i32 i64 i32)))
+  (type $f_ct (cont $f_t))
+
+
+  ;; type of the resumption we expect to see in our handler for $e
+  (type $res_ft
+        (func
+         (param i64 i32 i64 i32)
+         (result i32 i64 i32 i64 i32)))
+  (type $res (cont $res_ft))
+
+  ;; This is 10^10, which exceeds what can be stored in any 32 bit type
+  (global $big i64 (i64.const 10_000_000_000))
+
+  (tag $e
+       (param i32 i64 i32 i64)
+       (result i64 i32 i64 i32))
+
+
+
+  (func $f (export "f")
+        (param $x i64) (param $y i32) (param $z i64)
+        (result i32 i64 i32 i64 i32)
+
+    ;; value to stay on the stack as part of return values
+    (i32.const 1)
+
+    ;; values to be passed to $e
+    (i32.const 10)
+    (local.get $z)
+    (local.get $y)
+    (local.get $x)
+    (suspend $e)
+  )
+
+  (func $test (export "test") (result i32 i64)
+    (local $i64_acc i64)
+    (local $i32_acc i32)
+    (local $k (ref $res))
+    (local.set $i64_acc (i64.const 0))
+    (local.set $i32_acc (i32.const 0))
+
+
+    (block $on_e (result i32 i64 i32 i64 (ref $res)) ;; lets call these values v1 v2 v3 v4 k
+      (global.get $big)
+      (i32.const 100)
+      (i64.mul (global.get $big) (i64.const 10))
+      (resume $f_ct (tag $e $on_e) (cont.new $f_ct (ref.func $f)))
+      (unreachable))
+    ;; after on_e
+    (local.set $k)
+    (i32.const 1000)
+    ;; We pass v2 v3 v4 123 as arguments to the continuation, leaving v1 on the stack
+    (resume $res (local.get $k))
+    ;; We now have v1 and the five return values of $f on the stack, i.e. [i32 i32 i64 i32 i64 i32]
+    ;; Lets accumulate them
+    ;;
+
+    (local.set $i32_acc (i32.add (local.get $i32_acc)))
+    (local.set $i64_acc (i64.add (local.get $i64_acc)))
+    (local.set $i32_acc (i32.add (local.get $i32_acc)))
+    (local.set $i64_acc (i64.add (local.get $i64_acc)))
+    (local.set $i32_acc (i32.add (local.get $i32_acc)))
+    (local.set $i32_acc (i32.add (local.get $i32_acc)))
+
+    ;; ;; Set up return values
+    (local.get $i32_acc)
+    (local.get $i64_acc))
+
+)
+
+(assert_return (invoke "test") (i32.const 1111) (i64.const 110_000_000_000))
diff --git a/tests/misc_testsuite/typed-continuations/cont_new.wast b/tests/misc_testsuite/typed-continuations/cont_new.wast
new file mode 100644
index 000000000..b18eb6224
--- /dev/null
+++ b/tests/misc_testsuite/typed-continuations/cont_new.wast
@@ -0,0 +1,16 @@
+(module
+  (type $ft (func))
+  (type $ct (cont $ft))
+
+  (func $noop)
+  (elem declare func $noop)
+
+  (func $make-cont (result (ref $ct))
+     (cont.new $ct (ref.func $noop)))
+
+  (func $f (export "f") (result i32)
+     (call $make-cont)
+     (ref.is_null))
+)
+
+(assert_return (invoke "f") (i32.const 0))
\ No newline at end of file
diff --git a/tests/misc_testsuite/typed-continuations/cont_resume.wast b/tests/misc_testsuite/typed-continuations/cont_resume.wast
new file mode 100644
index 000000000..a24f1407a
--- /dev/null
+++ b/tests/misc_testsuite/typed-continuations/cont_resume.wast
@@ -0,0 +1,17 @@
+(module
+  (type $ft (func))
+  (type $ct (cont $ft))
+
+  (global $i (mut i32) (i32.const 0))
+
+  (func $g
+    (global.set $i (i32.const 42)))
+  (elem declare func $g)
+
+  (func $f (export "f") (result i32)
+    (global.set $i (i32.const 99))
+    (resume $ct (cont.new $ct (ref.func $g)))
+    (global.get $i))
+)
+
+(assert_return (invoke "f") (i32.const 42))
\ No newline at end of file
diff --git a/tests/misc_testsuite/typed-continuations/cont_resume1.wast b/tests/misc_testsuite/typed-continuations/cont_resume1.wast
new file mode 100644
index 000000000..e444225b5
--- /dev/null
+++ b/tests/misc_testsuite/typed-continuations/cont_resume1.wast
@@ -0,0 +1,27 @@
+(module
+  (type $ft_init (func))
+  (type $ct_init (cont $ft_init))
+  (type $ft (func (param i32)))
+  (type $ct (cont $ft))
+  (tag $yield (result i32))
+
+  (global $i (mut i32) (i32.const 0))
+
+  (func $g
+    (suspend $yield)
+    (global.set $i))
+  (elem declare func $g)
+
+  (func $f (export "f") (result i32)
+    (local $k (ref null $ct))
+    (global.set $i (i32.const 99))
+    (block $on_yield (result (ref $ct))
+      (resume $ct_init (tag $yield $on_yield) (cont.new $ct_init (ref.func $g)))
+      (unreachable))
+    ;; on_yield
+    (local.set $k)
+    (resume $ct (i32.const 42) (local.get $k))
+    (global.get $i))
+)
+
+(assert_return (invoke "f") (i32.const 42))
\ No newline at end of file
diff --git a/tests/misc_testsuite/typed-continuations/cont_resume2.wast b/tests/misc_testsuite/typed-continuations/cont_resume2.wast
new file mode 100644
index 000000000..b31d7ce2a
--- /dev/null
+++ b/tests/misc_testsuite/typed-continuations/cont_resume2.wast
@@ -0,0 +1,64 @@
+;; This test requires the following to work:
+;; 1. Passing arguments to tags and receiving values back at suspend sites
+;; 2. Passing values to a continuation obtained from a handler
+;; 3. Receving values once a resumed continuation returns oridinarly
+
+;; Not tested: Passing values when resuming a continuation obtained from
+;; cont.new rather than a handler
+
+;; TODO(frank-emrich) Replace this with more fine-grained tests in the future
+
+(module
+
+  (type $int_to_int (func (param i32) (result i32)))
+
+  (type $cont_int_to_int (cont $int_to_int))
+
+
+  (type $g_type (func (result i32)))
+  (type $g_ct (cont $g_type))
+
+
+  (tag $e0 (param i32) (result i32)) ;; never actually invoked
+  (tag $e1 (param i32) (result i32))
+  (tag $e2 (param i32) (result i32))
+  (tag $e3 (param i32) (result i32)) ;; never actually invoked
+
+
+  (func $g (result i32)
+    (suspend $e1 (i32.const 42))
+    (suspend $e2) ;; passes value obtained from doing $e on to $f
+    (i32.add (i32.const 21)))
+  (elem declare func $g)
+
+  (func $f (export "f") (result i32)
+    (local $c (ref $cont_int_to_int))
+    (block $on_e0_e2_e3 (result i32 (ref $cont_int_to_int))
+      (block $on_e1 (result i32 (ref $cont_int_to_int))
+        ;; We know that $e0, e2, e3 won't actually be performed here, but add a handler
+        ;; to test the switching logic
+        (resume $g_ct
+          (tag $e0 $on_e0_e2_e3)
+          (tag $e1 $on_e1)
+          (tag $e2 $on_e0_e2_e3)
+          (tag $e3 $on_e0_e2_e3)
+          (cont.new $g_ct (ref.func $g)))
+        (unreachable))
+      ;; after $on_e1
+      (local.set $c)
+      ;; stack now contains the value that $g passed to $e1, we manipulate it
+      (i32.add (i32.const 13))
+      (local.get $c)
+      (resume $cont_int_to_int (tag $e2 $on_e0_e2_e3))
+      (unreachable))
+    ;; after $on_e0_e2_e3
+    ;; stack contains value that $g passed to $e2 and continuation
+    ;; We manipulate the value again before resuming the continuation
+    (local.set $c)
+    (i32.add (i32.const 24))
+    (local.get $c)
+    (resume $cont_int_to_int)
+    ))
+
+
+(assert_return (invoke "f") (i32.const 100))
diff --git a/tests/misc_testsuite/typed-continuations/cont_resume_return.wast b/tests/misc_testsuite/typed-continuations/cont_resume_return.wast
new file mode 100644
index 000000000..96f341dc7
--- /dev/null
+++ b/tests/misc_testsuite/typed-continuations/cont_resume_return.wast
@@ -0,0 +1,13 @@
+(module
+  (type $ft (func (result i32)))
+  (type $ct (cont $ft))
+
+  (func $g (result i32)
+    (i32.const 42))
+  (elem declare func $g)
+
+  (func $f (export "f") (result i32)
+    (resume $ct (cont.new $ct (ref.func $g))))
+)
+
+(assert_return (invoke "f") (i32.const 42))
\ No newline at end of file
diff --git a/tests/misc_testsuite/typed-continuations/cont_return.wast b/tests/misc_testsuite/typed-continuations/cont_return.wast
new file mode 100644
index 000000000..b6fbd7a41
--- /dev/null
+++ b/tests/misc_testsuite/typed-continuations/cont_return.wast
@@ -0,0 +1,16 @@
+;; Test returning value from continuation function without any suspending
+
+(module
+
+  (type $g_type (func (result i32)))
+  (type $g_ct (cont $g_type))
+
+  (func $g (result i32)
+    (i32.const 100))
+  (elem declare func $g)
+
+  (func $f (export "f") (result i32)
+    (resume $g_ct
+      (cont.new $g_ct (ref.func $g)))))
+
+(assert_return (invoke "f") (i32.const 100))
diff --git a/tests/misc_testsuite/typed-continuations/cont_suspend.wast b/tests/misc_testsuite/typed-continuations/cont_suspend.wast
new file mode 100644
index 000000000..c57d96e3c
--- /dev/null
+++ b/tests/misc_testsuite/typed-continuations/cont_suspend.wast
@@ -0,0 +1,25 @@
+;; Small continuation resume test
+;; expected output:
+;; 1 : i32
+;; 2 : i32
+;; 3 : i32
+(module
+  (func $print (import "spectest" "print_i32") (param i32) (result))
+  (type $ft (func))
+  (type $ct (cont $ft))
+  (tag $h)
+  (func $f (export "f")
+    (suspend $h)
+    (call $print (i32.const 2)))
+  (func (export "run") (result i32)
+    (call $print (i32.const 1))
+    (block $on_h (result (ref $ct))
+      (resume $ct (tag $h $on_h)
+                  (cont.new $ct (ref.func $f)))
+      (unreachable))
+    (drop)
+    (call $print (i32.const 3))
+    (return (i32.const 42)))
+)
+
+(assert_return (invoke "run") (i32.const 42))
diff --git a/tests/misc_testsuite/winch/block.wast b/tests/misc_testsuite/winch/block.wast
deleted file mode 100644
index 2d433b1e1..000000000
--- a/tests/misc_testsuite/winch/block.wast
+++ /dev/null
@@ -1,161 +0,0 @@
-;; Test `block` operator
-
-(module
-  ;; Auxiliary definition
-  (memory 1)
-
-  (func $dummy)
-
-  (func (export "empty")
-    (block)
-    (block $l)
-  )
-
-  (func (export "singular") (result i32)
-    (block (nop))
-    (block (result i32) (i32.const 7))
-  )
-
-  (func (export "nested") (result i32)
-    (block (result i32)
-      (block (call $dummy) (block) (nop))
-      (block (result i32) (call $dummy) (i32.const 9))
-    )
-  )
-
-  (func (export "deep") (result i32)
-    (block (result i32) (block (result i32)
-      (block (result i32) (block (result i32)
-        (block (result i32) (block (result i32)
-          (block (result i32) (block (result i32)
-            (block (result i32) (block (result i32)
-              (block (result i32) (block (result i32)
-                (block (result i32) (block (result i32)
-                  (block (result i32) (block (result i32)
-                    (block (result i32) (block (result i32)
-                      (block (result i32) (block (result i32)
-                        (block (result i32) (block (result i32)
-                          (block (result i32) (block (result i32)
-                            (block (result i32) (block (result i32)
-                              (block (result i32) (block (result i32)
-                                (block (result i32) (block (result i32)
-                                  (block (result i32) (block (result i32)
-                                    (block (result i32) (block (result i32)
-                                      (block (result i32) (block (result i32)
-                                        (block (result i32) (block (result i32)
-                                          (call $dummy) (i32.const 150)
-                                        ))
-                                      ))
-                                    ))
-                                  ))
-                                ))
-                              ))
-                            ))
-                          ))
-                        ))
-                      ))
-                    ))
-                  ))
-                ))
-              ))
-            ))
-          ))
-        ))
-      ))
-    ))
-  )
-
-  (func (export "as-if-condition")
-    (block (result i32) (i32.const 1)) (if (then (call $dummy)))
-  )
-  (func (export "as-if-then") (result i32)
-    (if (result i32) (i32.const 1) (then (block (result i32) (i32.const 1))) (else (i32.const 2)))
-  )
-  (func (export "as-if-else") (result i32)
-    (if (result i32) (i32.const 1) (then (i32.const 2)) (else (block (result i32) (i32.const 1))))
-  )
-
-  (func (export "as-br_if-first") (result i32)
-    (block (result i32) (br_if 0 (block (result i32) (i32.const 1)) (i32.const 2)))
-  )
-  (func (export "as-br_if-last") (result i32)
-    (block (result i32) (br_if 0 (i32.const 2) (block (result i32) (i32.const 1))))
-  )
-
-
-  (func $f (param i32) (result i32) (local.get 0))
-
-  (func (export "as-call-value") (result i32)
-    (call $f (block (result i32) (i32.const 1)))
-  )
-  (func (export "as-return-value") (result i32)
-    (block (result i32) (i32.const 1)) (return)
-  )
-  (func (export "as-br-value") (result i32)
-    (block (result i32) (br 0 (block (result i32) (i32.const 1))))
-  )
-  (func (export "as-local.set-value") (result i32)
-    (local i32) (local.set 0 (block (result i32) (i32.const 1))) (local.get 0)
-  )
-
-  (func (export "as-unary-operand") (result i32)
-    (i32.ctz (block (result i32) (call $dummy) (i32.const 13)))
-  )
-  (func (export "as-binary-operand") (result i32)
-    (i32.mul
-      (block (result i32) (call $dummy) (i32.const 3))
-      (block (result i32) (call $dummy) (i32.const 4))
-    )
-  )
-  (func (export "as-test-operand") (result i32)
-    (i32.eqz (block (result i32) (call $dummy) (i32.const 13)))
-  )
-  (func (export "break-value") (result i32)
-    (block (result i32) (br 0 (i32.const 18)) (i32.const 19))
-  )
-  (func (export "break-inner") (result i32)
-    (local i32)
-    (local.set 0 (i32.const 0))
-    (local.set 0 (i32.add (local.get 0) (block (result i32) (block (result i32) (br 1 (i32.const 0x1))))))
-    (local.set 0 (i32.add (local.get 0) (block (result i32) (block (br 0)) (i32.const 0x2))))
-    (local.set 0
-      (i32.add (local.get 0) (block (result i32) (i32.ctz (br 0 (i32.const 0x4)))))
-    )
-    (local.set 0
-      (i32.add (local.get 0) (block (result i32) (i32.ctz (block (result i32) (br 1 (i32.const 0x8))))))
-    )
-    (local.get 0)
-  )
-
-  (func (export "effects") (result i32)
-    (local i32)
-    (block
-      (local.set 0 (i32.const 1))
-      (local.set 0 (i32.mul (local.get 0) (i32.const 3)))
-      (local.set 0 (i32.sub (local.get 0) (i32.const 5)))
-      (local.set 0 (i32.mul (local.get 0) (i32.const 7)))
-      (br 0)
-      (local.set 0 (i32.mul (local.get 0) (i32.const 100)))
-    )
-    (i32.eq (local.get 0) (i32.const -14))
-  )
-)
-
-(assert_return (invoke "empty"))
-(assert_return (invoke "singular") (i32.const 7))
-(assert_return (invoke "nested") (i32.const 9))
-(assert_return (invoke "deep") (i32.const 150))
-(assert_return (invoke "as-if-condition"))
-(assert_return (invoke "as-if-then") (i32.const 1))
-(assert_return (invoke "as-if-else") (i32.const 2))
-(assert_return (invoke "as-br_if-first") (i32.const 1))
-(assert_return (invoke "as-br_if-last") (i32.const 2))
-(assert_return (invoke "as-call-value") (i32.const 1))
-(assert_return (invoke "as-return-value") (i32.const 1))
-(assert_return (invoke "as-br-value") (i32.const 1))
-(assert_return (invoke "as-local.set-value") (i32.const 1))
-(assert_return (invoke "as-unary-operand") (i32.const 0))
-(assert_return (invoke "as-binary-operand") (i32.const 12))
-(assert_return (invoke "as-test-operand") (i32.const 0))
-(assert_return (invoke "break-inner") (i32.const 0xf))
-(assert_return (invoke "effects") (i32.const 1))
diff --git a/tests/misc_testsuite/winch/br.wast b/tests/misc_testsuite/winch/br.wast
deleted file mode 100644
index af653bcb0..000000000
--- a/tests/misc_testsuite/winch/br.wast
+++ /dev/null
@@ -1,156 +0,0 @@
-;; Test `br` operator
-
-(module
-  ;; Auxiliary definition
-  (func $dummy)
-
-  (func (export "type-i32-value") (result i32)
-    (block (result i32) (i32.ctz (br 0 (i32.const 1))))
-  )
-  (func (export "type-i64-value") (result i64)
-    (block (result i64) (i64.ctz (br 0 (i64.const 2))))
-  )
-
-  (func (export "as-block-first")
-    (block (br 0) (call $dummy))
-  )
-  (func (export "as-block-mid")
-    (block (call $dummy) (br 0) (call $dummy))
-  )
-  (func (export "as-block-last")
-    (block (nop) (call $dummy) (br 0))
-  )
-  (func (export "as-block-value") (result i32)
-    (block (result i32) (nop) (call $dummy) (br 0 (i32.const 2)))
-  )
-
-  (func (export "as-loop-first") (result i32)
-    (block (result i32) (loop (result i32) (br 1 (i32.const 3)) (i32.const 2)))
-  )
-  (func (export "as-loop-mid") (result i32)
-    (block (result i32)
-      (loop (result i32) (call $dummy) (br 1 (i32.const 4)) (i32.const 2))
-    )
-  )
-  (func (export "as-loop-last") (result i32)
-    (block (result i32)
-      (loop (result i32) (nop) (call $dummy) (br 1 (i32.const 5)))
-    )
-  )
-
-  (func (export "as-br-value") (result i32)
-    (block (result i32) (br 0 (br 0 (i32.const 9))))
-  )
-
-  (func (export "as-br_if-cond")
-    (block (br_if 0 (br 0)))
-  )
-
-  (func (export "as-return-value") (result i64)
-    (block (result i64) (return (br 0 (i64.const 7))))
-  )
-
-  (func (export "as-if-cond") (result i32)
-    (block (result i32)
-      (if (result i32) (br 0 (i32.const 2))
-        (then (i32.const 0))
-        (else (i32.const 1))
-      )
-    )
-  )
-  (func (export "as-if-then") (param i32 i32) (result i32)
-    (block (result i32)
-      (if (result i32) (local.get 0)
-        (then (br 1 (i32.const 3)))
-        (else (local.get 1))
-      )
-    )
-  )
-  (func (export "as-if-else") (param i32 i32) (result i32)
-    (block (result i32)
-      (if (result i32) (local.get 0)
-        (then (local.get 1))
-        (else (br 1 (i32.const 4)))
-      )
-    )
-  )
-
-
-  (func $f (param i32 i32 i32) (result i32) (i32.const -1))
-  (func (export "as-call-first") (result i32)
-    (block (result i32)
-      (call $f (br 0 (i32.const 12)) (i32.const 2) (i32.const 3))
-    )
-  )
-  (func (export "as-call-mid") (result i32)
-    (block (result i32)
-      (call $f (i32.const 1) (br 0 (i32.const 13)) (i32.const 3))
-    )
-  )
-  (func (export "as-call-last") (result i32)
-    (block (result i32)
-      (call $f (i32.const 1) (i32.const 2) (br 0 (i32.const 14)))
-    )
-  )
-  (func (export "as-call-all") (result i32)
-    (block (result i32) (call $f (br 0 (i32.const 15))))
-  )
-
-  (func (export "as-binary-left") (result i32)
-    (block (result i32) (i32.add (br 0 (i32.const 3)) (i32.const 10)))
-  )
-  (func (export "as-binary-right") (result i64)
-    (block (result i64) (i64.sub (i64.const 10) (br 0 (i64.const 45))))
-  )
-  (func (export "as-binary-both") (result i32)
-    (block (result i32) (i32.add (br 0 (i32.const 46))))
-  )
-
-  (func (export "as-test-operand") (result i32)
-    (block (result i32) (i32.eqz (br 0 (i32.const 44))))
-  )
-
-  (func (export "nested-block-value") (result i32)
-    (i32.add
-      (i32.const 1)
-      (block (result i32)
-        (call $dummy)
-        (i32.add (i32.const 4) (br 0 (i32.const 8)))
-      )
-    )
-  )
-)
-
-(assert_return (invoke "type-i32-value") (i32.const 1))
-(assert_return (invoke "type-i64-value") (i64.const 2))
-(assert_return (invoke "as-block-first"))
-(assert_return (invoke "as-block-mid"))
-(assert_return (invoke "as-block-last"))
-(assert_return (invoke "as-block-value") (i32.const 2))
-(assert_return (invoke "as-loop-first") (i32.const 3))
-(assert_return (invoke "as-loop-mid") (i32.const 4))
-(assert_return (invoke "as-loop-last") (i32.const 5))
-(assert_return (invoke "as-br-value") (i32.const 9))
-(assert_return (invoke "as-br_if-cond"))
-(assert_return (invoke "as-return-value") (i64.const 7))
-
-(assert_return (invoke "as-if-cond") (i32.const 2))
-(assert_return (invoke "as-if-then" (i32.const 1) (i32.const 6)) (i32.const 3))
-(assert_return (invoke "as-if-then" (i32.const 0) (i32.const 6)) (i32.const 6))
-(assert_return (invoke "as-if-else" (i32.const 0) (i32.const 6)) (i32.const 4))
-(assert_return (invoke "as-if-else" (i32.const 1) (i32.const 6)) (i32.const 6))
-
-(assert_return (invoke "as-call-first") (i32.const 12))
-(assert_return (invoke "as-call-mid") (i32.const 13))
-(assert_return (invoke "as-call-last") (i32.const 14))
-(assert_return (invoke "as-call-all") (i32.const 15))
-
-
-(assert_return (invoke "as-binary-left") (i32.const 3))
-(assert_return (invoke "as-binary-right") (i64.const 45))
-(assert_return (invoke "as-binary-both") (i32.const 46))
-
-(assert_return (invoke "as-test-operand") (i32.const 44))
-
-(assert_return (invoke "nested-block-value") (i32.const 9))
-
diff --git a/tests/misc_testsuite/winch/br_if.wast b/tests/misc_testsuite/winch/br_if.wast
deleted file mode 100644
index 088433ccf..000000000
--- a/tests/misc_testsuite/winch/br_if.wast
+++ /dev/null
@@ -1,159 +0,0 @@
-;; Test `br_if` operator
-
-(module
-  (func $dummy)
-
-  (func (export "type-i32-value") (result i32)
-    (block (result i32) (i32.ctz (br_if 0 (i32.const 1) (i32.const 1))))
-  )
-  (func (export "type-i64-value") (result i64)
-    (block (result i64) (i64.ctz (br_if 0 (i64.const 2) (i32.const 1))))
-  )
-
-  (func (export "as-block-first") (param i32) (result i32)
-    (block (br_if 0 (local.get 0)) (return (i32.const 2))) (i32.const 3)
-  )
-  (func (export "as-block-mid") (param i32) (result i32)
-    (block (call $dummy) (br_if 0 (local.get 0)) (return (i32.const 2)))
-    (i32.const 3)
-  )
-  (func (export "as-block-last") (param i32)
-    (block (call $dummy) (call $dummy) (br_if 0 (local.get 0)))
-  )
-  (func (export "as-block-last-value") (param i32) (result i32)
-    (block (result i32)
-      (call $dummy) (call $dummy) (br_if 0 (i32.const 11) (local.get 0))
-    )
-  )
-
-  (func (export "as-loop-first") (param i32) (result i32)
-    (block (loop (br_if 1 (local.get 0)) (return (i32.const 2)))) (i32.const 3)
-  )
-  (func (export "as-loop-mid") (param i32) (result i32)
-    (block (loop (call $dummy) (br_if 1 (local.get 0)) (return (i32.const 2))))
-    (i32.const 4)
-  )
-  (func (export "as-loop-last") (param i32)
-    (loop (call $dummy) (br_if 1 (local.get 0)))
-  )
-
-  (func (export "as-br-value") (result i32)
-    (block (result i32) (br 0 (br_if 0 (i32.const 1) (i32.const 2))))
-  )
-
-  (func (export "as-br_if-cond")
-    (block (br_if 0 (br_if 0 (i32.const 1) (i32.const 1))))
-  )
-
-  (func (export "as-return-value") (result i64)
-    (block (result i64) (return (br_if 0 (i64.const 1) (i32.const 2))))
-  )
-
-  (func (export "as-if-cond") (param i32) (result i32)
-    (block (result i32)
-      (if (result i32)
-        (br_if 0 (i32.const 1) (local.get 0))
-        (then (i32.const 2))
-        (else (i32.const 3))
-      )
-    )
-  )
-  (func (export "as-if-then") (param i32 i32)
-    (block
-      (if (local.get 0) (then (br_if 1 (local.get 1))) (else (call $dummy)))
-    )
-  )
-  (func (export "as-if-else") (param i32 i32)
-    (block
-      (if (local.get 0) (then (call $dummy)) (else (br_if 1 (local.get 1))))
-    )
-  )
-
- (func $f (param i32 i32 i32) (result i32) (i32.const -1))
- (func (export "as-call-first") (result i32)
-    (block (result i32)
-      (call $f
-        (br_if 0 (i32.const 12) (i32.const 1)) (i32.const 2) (i32.const 3)
-      )
-    )
-  )
-  (func (export "as-call-mid") (result i32)
-    (block (result i32)
-      (call $f
-        (i32.const 1) (br_if 0 (i32.const 13) (i32.const 1)) (i32.const 3)
-      )
-    )
-  )
-  (func (export "as-call-last") (result i32)
-    (block (result i32)
-      (call $f
-        (i32.const 1) (i32.const 2) (br_if 0 (i32.const 14) (i32.const 1))
-      )
-    )
-  )
-
-  (func (export "as-local.set-value") (param i32) (result i32)
-    (local i32)
-    (block (result i32)
-      (local.set 0 (br_if 0 (i32.const 17) (local.get 0)))
-      (i32.const -1)
-    )
-  )
-
-  (func (export "as-binary-left") (result i32)
-    (block (result i32) (i32.add (br_if 0 (i32.const 1) (i32.const 1)) (i32.const 10)))
-  )
-  (func (export "as-binary-right") (result i32)
-    (block (result i32) (i32.sub (i32.const 10) (br_if 0 (i32.const 1) (i32.const 1))))
-  )
-  (func (export "as-test-operand") (result i32)
-    (block (result i32) (i32.eqz (br_if 0 (i32.const 0) (i32.const 1))))
-  )
-  (func (export "as-compare-left") (result i32)
-    (block (result i32) (i32.le_u (br_if 0 (i32.const 1) (i32.const 1)) (i32.const 10)))
-  )
-  (func (export "as-compare-right") (result i32)
-    (block (result i32) (i32.ne (i32.const 10) (br_if 0 (i32.const 1) (i32.const 42))))
-  )
-)
-
-
-(assert_return (invoke "type-i32-value") (i32.const 1))
-(assert_return (invoke "type-i64-value") (i64.const 2))
-(assert_return (invoke "as-block-first" (i32.const 0)) (i32.const 2))
-(assert_return (invoke "as-block-first" (i32.const 1)) (i32.const 3))
-(assert_return (invoke "as-block-mid" (i32.const 0)) (i32.const 2))
-(assert_return (invoke "as-block-mid" (i32.const 1)) (i32.const 3))
-(assert_return (invoke "as-block-last" (i32.const 0)))
-(assert_return (invoke "as-block-last" (i32.const 1)))
-(assert_return (invoke "as-block-last-value" (i32.const 0)) (i32.const 11))
-(assert_return (invoke "as-block-last-value" (i32.const 1)) (i32.const 11))
-(assert_return (invoke "as-loop-first" (i32.const 0)) (i32.const 2))
-(assert_return (invoke "as-loop-first" (i32.const 1)) (i32.const 3))
-(assert_return (invoke "as-loop-mid" (i32.const 0)) (i32.const 2))
-(assert_return (invoke "as-loop-mid" (i32.const 1)) (i32.const 4))
-(assert_return (invoke "as-loop-last" (i32.const 0)))
-(assert_return (invoke "as-loop-last" (i32.const 1)))
-(assert_return (invoke "as-br-value") (i32.const 1))
-(assert_return (invoke "as-br_if-cond"))
-(assert_return (invoke "as-return-value") (i64.const 1))
-(assert_return (invoke "as-if-cond" (i32.const 0)) (i32.const 2))
-(assert_return (invoke "as-if-cond" (i32.const 1)) (i32.const 1))
-(assert_return (invoke "as-if-then" (i32.const 0) (i32.const 0)))
-(assert_return (invoke "as-if-then" (i32.const 4) (i32.const 0)))
-(assert_return (invoke "as-if-then" (i32.const 0) (i32.const 1)))
-(assert_return (invoke "as-if-then" (i32.const 4) (i32.const 1)))
-(assert_return (invoke "as-if-else" (i32.const 0) (i32.const 0)))
-(assert_return (invoke "as-if-else" (i32.const 3) (i32.const 0)))
-(assert_return (invoke "as-if-else" (i32.const 0) (i32.const 1)))
-(assert_return (invoke "as-if-else" (i32.const 3) (i32.const 1)))
-(assert_return (invoke "as-call-first") (i32.const 12))
-(assert_return (invoke "as-call-mid") (i32.const 13))
-(assert_return (invoke "as-call-last") (i32.const 14))
-(assert_return (invoke "as-local.set-value" (i32.const 0)) (i32.const -1))
-(assert_return (invoke "as-local.set-value" (i32.const 1)) (i32.const 17))
-(assert_return (invoke "as-binary-left") (i32.const 1))
-(assert_return (invoke "as-binary-right") (i32.const 1))
-(assert_return (invoke "as-test-operand") (i32.const 0))
-(assert_return (invoke "as-compare-left") (i32.const 1))
-(assert_return (invoke "as-compare-right") (i32.const 1))
diff --git a/tests/misc_testsuite/winch/call.wast b/tests/misc_testsuite/winch/call.wast
deleted file mode 100644
index db90832d3..000000000
--- a/tests/misc_testsuite/winch/call.wast
+++ /dev/null
@@ -1,179 +0,0 @@
-;; Test `call` operator
-
-
-(module
-  ;; Auxiliary definitions
-  (func $const-i32 (result i32) (i32.const 0x132))
-  (func $const-i64 (result i64) (i64.const 0x164))
-
-  (func $id-i32 (param i32) (result i32) (local.get 0))
-  (func $id-i64 (param i64) (result i64) (local.get 0))
-
-  (func $i32-i64 (param i32 i64) (result i64) (local.get 1))
-
-  ;; Typing
-
-  (func (export "type-i32") (result i32) (call $const-i32))
-  (func (export "type-i64") (result i64) (call $const-i64))
-
-  (func (export "type-first-i32") (result i32) (call $id-i32 (i32.const 32)))
-  (func (export "type-first-i64") (result i64) (call $id-i64 (i64.const 64)))
-
-  (func (export "type-second-i64") (result i64)
-    (call $i32-i64 (i32.const 32) (i64.const 64))
-  )
-
-  ;; Recursion
-
-  (func $fac (export "fac") (param i64) (result i64)
-    (if (result i64) (i64.eqz (local.get 0))
-      (then (i64.const 1))
-      (else
-        (i64.mul
-          (local.get 0)
-          (call $fac (i64.sub (local.get 0) (i64.const 1)))
-        )
-      )
-    )
-  )
-
-  (func $fac-acc (export "fac-acc") (param i64 i64) (result i64)
-    (if (result i64) (i64.eqz (local.get 0))
-      (then (local.get 1))
-      (else
-        (call $fac-acc
-          (i64.sub (local.get 0) (i64.const 1))
-          (i64.mul (local.get 0) (local.get 1))
-        )
-      )
-    )
-  )
-
-  (func $fib (export "fib") (param i64) (result i64)
-    (if (result i64) (i64.le_u (local.get 0) (i64.const 1))
-      (then (i64.const 1))
-      (else
-        (i64.add
-          (call $fib (i64.sub (local.get 0) (i64.const 2)))
-          (call $fib (i64.sub (local.get 0) (i64.const 1)))
-        )
-      )
-    )
-  )
-
-  (func $even (export "even") (param i64) (result i32)
-    (if (result i32) (i64.eqz (local.get 0))
-      (then (i32.const 44))
-      (else (call $odd (i64.sub (local.get 0) (i64.const 1))))
-    )
-  )
-  (func $odd (export "odd") (param i64) (result i32)
-    (if (result i32) (i64.eqz (local.get 0))
-      (then (i32.const 99))
-      (else (call $even (i64.sub (local.get 0) (i64.const 1))))
-    )
-  )
-
-  ;; Stack exhaustion
-
-  ;; Implementations are required to have every call consume some abstract
-  ;; resource towards exhausting some abstract finite limit, such that
-  ;; infinitely recursive test cases reliably trap in finite time. This is
-  ;; because otherwise applications could come to depend on it on those
-  ;; implementations and be incompatible with implementations that don't do
-  ;; it (or don't do it under the same circumstances).
-
-  (func $runaway (export "runaway") (call $runaway))
-
-  (func $mutual-runaway1 (export "mutual-runaway") (call $mutual-runaway2))
-  (func $mutual-runaway2 (call $mutual-runaway1))
-
-  ;; As parameter of control constructs and instructions
-
-  (memory 1)
-
-  (func (export "as-if-condition") (result i32)
-    (if (result i32) (call $const-i32) (then (i32.const 1)) (else (i32.const 2)))
-  )
-
-  (func (export "as-br_if-first") (result i32)
-    (block (result i32) (br_if 0 (call $const-i32) (i32.const 2)))
-  )
-  (func (export "as-br_if-last") (result i32)
-    (block (result i32) (br_if 0 (i32.const 2) (call $const-i32)))
-  )
-
-
-  (func (export "as-return-value") (result i32)
-    (call $const-i32) (return)
-  )
-  (func (export "as-br-value") (result i32)
-    (block (result i32) (br 0 (call $const-i32)))
-  )
-  (func (export "as-local.set-value") (result i32)
-    (local i32) (local.set 0 (call $const-i32)) (local.get 0)
-  )
-  (func $dummy (param i32) (result i32) (local.get 0))
-
-  (func (export "as-binary-left") (result i32)
-    (block (result i32) (i32.add (call $dummy (i32.const 1)) (i32.const 10)))
-  )
-  (func (export "as-binary-right") (result i32)
-    (block (result i32) (i32.sub (i32.const 10) (call $dummy (i32.const 1))))
-  )
-
-  (func (export "as-test-operand") (result i32)
-    (block (result i32) (i32.eqz (call $dummy (i32.const 1))))
-  )
-
-  (func (export "as-compare-left") (result i32)
-    (block (result i32) (i32.le_u (call $dummy (i32.const 1)) (i32.const 10)))
-  )
-  (func (export "as-compare-right") (result i32)
-    (block (result i32) (i32.ne (i32.const 10) (call $dummy (i32.const 1))))
-  )
-)
-
-(assert_return (invoke "type-i32") (i32.const 0x132))
-(assert_return (invoke "type-i64") (i64.const 0x164))
-(assert_return (invoke "type-first-i32") (i32.const 32))
-(assert_return (invoke "type-first-i64") (i64.const 64))
-(assert_return (invoke "type-second-i64") (i64.const 64))
-
-(assert_return (invoke "fac" (i64.const 0)) (i64.const 1))
-(assert_return (invoke "fac" (i64.const 1)) (i64.const 1))
-(assert_return (invoke "fac" (i64.const 5)) (i64.const 120))
-(assert_return (invoke "fac" (i64.const 25)) (i64.const 7034535277573963776))
-(assert_return (invoke "fac-acc" (i64.const 0) (i64.const 1)) (i64.const 1))
-(assert_return (invoke "fac-acc" (i64.const 1) (i64.const 1)) (i64.const 1))
-(assert_return (invoke "fac-acc" (i64.const 5) (i64.const 1)) (i64.const 120))
-(assert_return
-  (invoke "fac-acc" (i64.const 25) (i64.const 1))
-  (i64.const 7034535277573963776)
-)
-
-(assert_return (invoke "fib" (i64.const 0)) (i64.const 1))
-(assert_return (invoke "fib" (i64.const 1)) (i64.const 1))
-(assert_return (invoke "fib" (i64.const 2)) (i64.const 2))
-(assert_return (invoke "fib" (i64.const 5)) (i64.const 8))
-(assert_return (invoke "fib" (i64.const 20)) (i64.const 10946))
-(assert_return (invoke "even" (i64.const 0)) (i32.const 44))
-(assert_return (invoke "even" (i64.const 1)) (i32.const 99))
-(assert_return (invoke "even" (i64.const 100)) (i32.const 44))
-(assert_return (invoke "even" (i64.const 77)) (i32.const 99))
-(assert_return (invoke "odd" (i64.const 0)) (i32.const 99))
-(assert_return (invoke "odd" (i64.const 1)) (i32.const 44))
-(assert_return (invoke "odd" (i64.const 200)) (i32.const 99))
-(assert_return (invoke "odd" (i64.const 77)) (i32.const 44))
-(assert_return (invoke "as-if-condition") (i32.const 1))
-(assert_return (invoke "as-br_if-first") (i32.const 0x132))
-(assert_return (invoke "as-br_if-last") (i32.const 2))
-(assert_return (invoke "as-return-value") (i32.const 0x132))
-(assert_return (invoke "as-br-value") (i32.const 0x132))
-(assert_return (invoke "as-local.set-value") (i32.const 0x132))
-
-(assert_return (invoke "as-binary-left") (i32.const 11))
-(assert_return (invoke "as-binary-right") (i32.const 9))
-(assert_return (invoke "as-test-operand") (i32.const 0))
-(assert_return (invoke "as-compare-left") (i32.const 1))
-(assert_return (invoke "as-compare-right") (i32.const 1))
diff --git a/tests/misc_testsuite/winch/globals.wast b/tests/misc_testsuite/winch/globals.wast
deleted file mode 100644
index fa2a8f75f..000000000
--- a/tests/misc_testsuite/winch/globals.wast
+++ /dev/null
@@ -1,154 +0,0 @@
-;; Test globals
-
-(module
-  (global (import "spectest" "global_i32") i32)
-  (global (import "spectest" "global_i64") i64)
-
-  (global $a i32 (i32.const -2))
-  (global $b i64 (i64.const -5))
-
-  (global $x (mut i32) (i32.const -12))
-  (global $y (mut i64) (i64.const -15))
-
-  (global $z1 i32 (global.get 0))
-  (global $z2 i64 (global.get 1))
-
-  (func (export "get-a") (result i32) (global.get $a))
-  (func (export "get-b") (result i64) (global.get $b))
-  (func (export "get-x") (result i32) (global.get $x))
-  (func (export "get-y") (result i64) (global.get $y))
-  (func (export "get-z1") (result i32) (global.get $z1))
-  (func (export "get-z2") (result i64) (global.get $z2))
-  (func (export "set-x") (param i32) (global.set $x (local.get 0)))
-  (func (export "set-y") (param i64) (global.set $y (local.get 0)))
-
-  ;; As the argument of control constructs and instructions
-
-  (memory 1)
-
-  (func $dummy)
-
-  (func (export "as-loop-first") (result i32)
-    (loop (result i32)
-      (global.get $x) (call $dummy) (call $dummy)
-    )
-  )
-  (func (export "as-loop-mid") (result i32)
-    (loop (result i32)
-      (call $dummy) (global.get $x) (call $dummy)
-    )
-  )
-  (func (export "as-loop-last") (result i32)
-    (loop (result i32)
-      (call $dummy) (call $dummy) (global.get $x)
-    )
-  )
-
-  (func (export "as-if-condition") (result i32)
-    (if (result i32) (global.get $x)
-      (then (call $dummy) (i32.const 2))
-      (else (call $dummy) (i32.const 3))
-    )
-  )
-  (func (export "as-if-then") (result i32)
-    (if (result i32) (i32.const 1)
-      (then (global.get $x)) (else (i32.const 2))
-    )
-  )
-  (func (export "as-if-else") (result i32)
-    (if (result i32) (i32.const 0)
-      (then (i32.const 2)) (else (global.get $x))
-    )
-  )
-
-  (func (export "as-br_if-first") (result i32)
-    (block (result i32)
-      (br_if 0 (global.get $x) (i32.const 2))
-      (return (i32.const 3))
-    )
-  )
-  (func (export "as-br_if-last") (result i32)
-    (block (result i32)
-      (br_if 0 (i32.const 2) (global.get $x))
-      (return (i32.const 3))
-    )
-  )
-
-  (func $f (param i32) (result i32) (local.get 0))
-  (func (export "as-call-value") (result i32)
-    (call $f (global.get $x))
-  )
-
-  (func (export "as-return-value") (result i32)
-    (global.get $x) (return)
-  )
-  (func (export "as-br-value") (result i32)
-    (block (result i32) (br 0 (global.get $x)))
-  )
-
-  (func (export "as-local.set-value") (param i32) (result i32)
-    (local.set 0 (global.get $x))
-    (local.get 0)
-  )
-  (func (export "as-local.tee-value") (param i32) (result i32)
-    (local.tee 0 (global.get $x))
-  )
-  (func (export "as-global.set-value") (result i32)
-    (global.set $x (global.get $x))
-    (global.get $x)
-  )
-
-  (func (export "as-unary-operand") (result i32)
-    (i32.eqz (global.get $x))
-  )
-  (func (export "as-binary-operand") (result i32)
-    (i32.mul
-      (global.get $x) (global.get $x)
-    )
-  )
-  (func (export "as-compare-operand") (result i32)
-    (i32.gt_u
-      (global.get 0) (i32.const 1)
-    )
-  )
-)
-
-(assert_return (invoke "get-a") (i32.const -2))
-(assert_return (invoke "get-b") (i64.const -5))
-(assert_return (invoke "get-x") (i32.const -12))
-(assert_return (invoke "get-y") (i64.const -15))
-(assert_return (invoke "get-z1") (i32.const 666))
-(assert_return (invoke "get-z2") (i64.const 666))
-
-(assert_return (invoke "set-x" (i32.const 6)))
-(assert_return (invoke "set-y" (i64.const 7)))
-
-(assert_return (invoke "get-x") (i32.const 6))
-(assert_return (invoke "get-y") (i64.const 7))
-
-(assert_return (invoke "get-x") (i32.const 6))
-(assert_return (invoke "get-y") (i64.const 7))
-
-(assert_return (invoke "as-loop-first") (i32.const 6))
-(assert_return (invoke "as-loop-mid") (i32.const 6))
-(assert_return (invoke "as-loop-last") (i32.const 6))
-
-(assert_return (invoke "as-if-condition") (i32.const 2))
-(assert_return (invoke "as-if-then") (i32.const 6))
-(assert_return (invoke "as-if-else") (i32.const 6))
-
-(assert_return (invoke "as-br_if-first") (i32.const 6))
-(assert_return (invoke "as-br_if-last") (i32.const 2))
-
-(assert_return (invoke "as-call-value") (i32.const 6))
-
-(assert_return (invoke "as-return-value") (i32.const 6))
-(assert_return (invoke "as-br-value") (i32.const 6))
-
-(assert_return (invoke "as-local.set-value" (i32.const 1)) (i32.const 6))
-(assert_return (invoke "as-local.tee-value" (i32.const 1)) (i32.const 6))
-(assert_return (invoke "as-global.set-value") (i32.const 6))
-
-(assert_return (invoke "as-unary-operand") (i32.const 0))
-(assert_return (invoke "as-binary-operand") (i32.const 36))
-(assert_return (invoke "as-compare-operand") (i32.const 1))
diff --git a/tests/misc_testsuite/winch/i32.wast b/tests/misc_testsuite/winch/i32.wast
deleted file mode 100644
index 8a06d0914..000000000
--- a/tests/misc_testsuite/winch/i32.wast
+++ /dev/null
@@ -1,422 +0,0 @@
-;; i32 operations
-
-(module
-  (func (export "add") (param $x i32) (param $y i32) (result i32) (i32.add (local.get $x) (local.get $y)))
-  (func (export "sub") (param $x i32) (param $y i32) (result i32) (i32.sub (local.get $x) (local.get $y)))
-  (func (export "mul") (param $x i32) (param $y i32) (result i32) (i32.mul (local.get $x) (local.get $y)))
-  (func (export "div_s") (param $x i32) (param $y i32) (result i32) (i32.div_s (local.get $x) (local.get $y)))
-  (func (export "div_u") (param $x i32) (param $y i32) (result i32) (i32.div_u (local.get $x) (local.get $y)))
-  (func (export "rem_s") (param $x i32) (param $y i32) (result i32) (i32.rem_s (local.get $x) (local.get $y)))
-  (func (export "rem_u") (param $x i32) (param $y i32) (result i32) (i32.rem_u (local.get $x) (local.get $y)))
-  (func (export "and") (param $x i32) (param $y i32) (result i32) (i32.and (local.get $x) (local.get $y)))
-  (func (export "or") (param $x i32) (param $y i32) (result i32) (i32.or (local.get $x) (local.get $y)))
-  (func (export "xor") (param $x i32) (param $y i32) (result i32) (i32.xor (local.get $x) (local.get $y)))
-  (func (export "shl") (param $x i32) (param $y i32) (result i32) (i32.shl (local.get $x) (local.get $y)))
-  (func (export "shr_s") (param $x i32) (param $y i32) (result i32) (i32.shr_s (local.get $x) (local.get $y)))
-  (func (export "shr_u") (param $x i32) (param $y i32) (result i32) (i32.shr_u (local.get $x) (local.get $y)))
-  (func (export "rotl") (param $x i32) (param $y i32) (result i32) (i32.rotl (local.get $x) (local.get $y)))
-  (func (export "rotr") (param $x i32) (param $y i32) (result i32) (i32.rotr (local.get $x) (local.get $y)))
-  (func (export "clz") (param $x i32) (result i32) (i32.clz (local.get $x)))
-  (func (export "ctz") (param $x i32) (result i32) (i32.ctz (local.get $x)))
-  (func (export "popcnt") (param $x i32) (result i32) (i32.popcnt (local.get $x)))
-  (func (export "eqz") (param $x i32) (result i32) (i32.eqz (local.get $x)))
-  (func (export "eq") (param $x i32) (param $y i32) (result i32) (i32.eq (local.get $x) (local.get $y)))
-  (func (export "ne") (param $x i32) (param $y i32) (result i32) (i32.ne (local.get $x) (local.get $y)))
-  (func (export "lt_s") (param $x i32) (param $y i32) (result i32) (i32.lt_s (local.get $x) (local.get $y)))
-  (func (export "lt_u") (param $x i32) (param $y i32) (result i32) (i32.lt_u (local.get $x) (local.get $y)))
-  (func (export "le_s") (param $x i32) (param $y i32) (result i32) (i32.le_s (local.get $x) (local.get $y)))
-  (func (export "le_u") (param $x i32) (param $y i32) (result i32) (i32.le_u (local.get $x) (local.get $y)))
-  (func (export "gt_s") (param $x i32) (param $y i32) (result i32) (i32.gt_s (local.get $x) (local.get $y)))
-  (func (export "gt_u") (param $x i32) (param $y i32) (result i32) (i32.gt_u (local.get $x) (local.get $y)))
-  (func (export "ge_s") (param $x i32) (param $y i32) (result i32) (i32.ge_s (local.get $x) (local.get $y)))
-  (func (export "ge_u") (param $x i32) (param $y i32) (result i32) (i32.ge_u (local.get $x) (local.get $y)))
-)
-
-(assert_return (invoke "add" (i32.const 1) (i32.const 1)) (i32.const 2))
-(assert_return (invoke "add" (i32.const 1) (i32.const 0)) (i32.const 1))
-(assert_return (invoke "add" (i32.const -1) (i32.const -1)) (i32.const -2))
-(assert_return (invoke "add" (i32.const -1) (i32.const 1)) (i32.const 0))
-(assert_return (invoke "add" (i32.const 0x7fffffff) (i32.const 1)) (i32.const 0x80000000))
-(assert_return (invoke "add" (i32.const 0x80000000) (i32.const -1)) (i32.const 0x7fffffff))
-(assert_return (invoke "add" (i32.const 0x80000000) (i32.const 0x80000000)) (i32.const 0))
-(assert_return (invoke "add" (i32.const 0x3fffffff) (i32.const 1)) (i32.const 0x40000000))
-
-(assert_return (invoke "sub" (i32.const 1) (i32.const 1)) (i32.const 0))
-(assert_return (invoke "sub" (i32.const 1) (i32.const 0)) (i32.const 1))
-(assert_return (invoke "sub" (i32.const -1) (i32.const -1)) (i32.const 0))
-(assert_return (invoke "sub" (i32.const 0x7fffffff) (i32.const -1)) (i32.const 0x80000000))
-(assert_return (invoke "sub" (i32.const 0x80000000) (i32.const 1)) (i32.const 0x7fffffff))
-(assert_return (invoke "sub" (i32.const 0x80000000) (i32.const 0x80000000)) (i32.const 0))
-(assert_return (invoke "sub" (i32.const 0x3fffffff) (i32.const -1)) (i32.const 0x40000000))
-
-(assert_return (invoke "mul" (i32.const 1) (i32.const 1)) (i32.const 1))
-(assert_return (invoke "mul" (i32.const 1) (i32.const 0)) (i32.const 0))
-(assert_return (invoke "mul" (i32.const -1) (i32.const -1)) (i32.const 1))
-(assert_return (invoke "mul" (i32.const 0x10000000) (i32.const 4096)) (i32.const 0))
-(assert_return (invoke "mul" (i32.const 0x80000000) (i32.const 0)) (i32.const 0))
-(assert_return (invoke "mul" (i32.const 0x80000000) (i32.const -1)) (i32.const 0x80000000))
-(assert_return (invoke "mul" (i32.const 0x7fffffff) (i32.const -1)) (i32.const 0x80000001))
-(assert_return (invoke "mul" (i32.const 0x01234567) (i32.const 0x76543210)) (i32.const 0x358e7470))
-(assert_return (invoke "mul" (i32.const 0x7fffffff) (i32.const 0x7fffffff)) (i32.const 1))
-
-(assert_trap (invoke "div_s" (i32.const 1) (i32.const 0)) "integer divide by zero")
-(assert_trap (invoke "div_s" (i32.const 0) (i32.const 0)) "integer divide by zero")
-(assert_trap (invoke "div_s" (i32.const 0x80000000) (i32.const -1)) "integer overflow")
-(assert_trap (invoke "div_s" (i32.const 0x80000000) (i32.const 0)) "integer divide by zero")
-(assert_return (invoke "div_s" (i32.const 1) (i32.const 1)) (i32.const 1))
-(assert_return (invoke "div_s" (i32.const 0) (i32.const 1)) (i32.const 0))
-(assert_return (invoke "div_s" (i32.const 0) (i32.const -1)) (i32.const 0))
-(assert_return (invoke "div_s" (i32.const -1) (i32.const -1)) (i32.const 1))
-(assert_return (invoke "div_s" (i32.const 0x80000000) (i32.const 2)) (i32.const 0xc0000000))
-(assert_return (invoke "div_s" (i32.const 0x80000001) (i32.const 1000)) (i32.const 0xffdf3b65))
-(assert_return (invoke "div_s" (i32.const 5) (i32.const 2)) (i32.const 2))
-(assert_return (invoke "div_s" (i32.const -5) (i32.const 2)) (i32.const -2))
-(assert_return (invoke "div_s" (i32.const 5) (i32.const -2)) (i32.const -2))
-(assert_return (invoke "div_s" (i32.const -5) (i32.const -2)) (i32.const 2))
-(assert_return (invoke "div_s" (i32.const 7) (i32.const 3)) (i32.const 2))
-(assert_return (invoke "div_s" (i32.const -7) (i32.const 3)) (i32.const -2))
-(assert_return (invoke "div_s" (i32.const 7) (i32.const -3)) (i32.const -2))
-(assert_return (invoke "div_s" (i32.const -7) (i32.const -3)) (i32.const 2))
-(assert_return (invoke "div_s" (i32.const 11) (i32.const 5)) (i32.const 2))
-(assert_return (invoke "div_s" (i32.const 17) (i32.const 7)) (i32.const 2))
-
-(assert_trap (invoke "div_u" (i32.const 1) (i32.const 0)) "integer divide by zero")
-(assert_trap (invoke "div_u" (i32.const 0) (i32.const 0)) "integer divide by zero")
-(assert_return (invoke "div_u" (i32.const 1) (i32.const 1)) (i32.const 1))
-(assert_return (invoke "div_u" (i32.const 0) (i32.const 1)) (i32.const 0))
-(assert_return (invoke "div_u" (i32.const -1) (i32.const -1)) (i32.const 1))
-(assert_return (invoke "div_u" (i32.const 0x80000000) (i32.const -1)) (i32.const 0))
-(assert_return (invoke "div_u" (i32.const 0x80000000) (i32.const 2)) (i32.const 0x40000000))
-(assert_return (invoke "div_u" (i32.const 0x8ff00ff0) (i32.const 0x10001)) (i32.const 0x8fef))
-(assert_return (invoke "div_u" (i32.const 0x80000001) (i32.const 1000)) (i32.const 0x20c49b))
-(assert_return (invoke "div_u" (i32.const 5) (i32.const 2)) (i32.const 2))
-(assert_return (invoke "div_u" (i32.const -5) (i32.const 2)) (i32.const 0x7ffffffd))
-(assert_return (invoke "div_u" (i32.const 5) (i32.const -2)) (i32.const 0))
-(assert_return (invoke "div_u" (i32.const -5) (i32.const -2)) (i32.const 0))
-(assert_return (invoke "div_u" (i32.const 7) (i32.const 3)) (i32.const 2))
-(assert_return (invoke "div_u" (i32.const 11) (i32.const 5)) (i32.const 2))
-(assert_return (invoke "div_u" (i32.const 17) (i32.const 7)) (i32.const 2))
-
-(assert_trap (invoke "rem_s" (i32.const 1) (i32.const 0)) "integer divide by zero")
-(assert_trap (invoke "rem_s" (i32.const 0) (i32.const 0)) "integer divide by zero")
-(assert_return (invoke "rem_s" (i32.const 0x7fffffff) (i32.const -1)) (i32.const 0))
-(assert_return (invoke "rem_s" (i32.const 1) (i32.const 1)) (i32.const 0))
-(assert_return (invoke "rem_s" (i32.const 0) (i32.const 1)) (i32.const 0))
-(assert_return (invoke "rem_s" (i32.const 0) (i32.const -1)) (i32.const 0))
-(assert_return (invoke "rem_s" (i32.const -1) (i32.const -1)) (i32.const 0))
-(assert_return (invoke "rem_s" (i32.const 0x80000000) (i32.const -1)) (i32.const 0))
-(assert_return (invoke "rem_s" (i32.const 0x80000000) (i32.const 2)) (i32.const 0))
-(assert_return (invoke "rem_s" (i32.const 0x80000001) (i32.const 1000)) (i32.const -647))
-(assert_return (invoke "rem_s" (i32.const 5) (i32.const 2)) (i32.const 1))
-(assert_return (invoke "rem_s" (i32.const -5) (i32.const 2)) (i32.const -1))
-(assert_return (invoke "rem_s" (i32.const 5) (i32.const -2)) (i32.const 1))
-(assert_return (invoke "rem_s" (i32.const -5) (i32.const -2)) (i32.const -1))
-(assert_return (invoke "rem_s" (i32.const 7) (i32.const 3)) (i32.const 1))
-(assert_return (invoke "rem_s" (i32.const -7) (i32.const 3)) (i32.const -1))
-(assert_return (invoke "rem_s" (i32.const 7) (i32.const -3)) (i32.const 1))
-(assert_return (invoke "rem_s" (i32.const -7) (i32.const -3)) (i32.const -1))
-(assert_return (invoke "rem_s" (i32.const 11) (i32.const 5)) (i32.const 1))
-(assert_return (invoke "rem_s" (i32.const 17) (i32.const 7)) (i32.const 3))
-
-(assert_trap (invoke "rem_u" (i32.const 1) (i32.const 0)) "integer divide by zero")
-(assert_trap (invoke "rem_u" (i32.const 0) (i32.const 0)) "integer divide by zero")
-(assert_return (invoke "rem_u" (i32.const 1) (i32.const 1)) (i32.const 0))
-(assert_return (invoke "rem_u" (i32.const 0) (i32.const 1)) (i32.const 0))
-(assert_return (invoke "rem_u" (i32.const -1) (i32.const -1)) (i32.const 0))
-(assert_return (invoke "rem_u" (i32.const 0x80000000) (i32.const -1)) (i32.const 0x80000000))
-(assert_return (invoke "rem_u" (i32.const 0x80000000) (i32.const 2)) (i32.const 0))
-(assert_return (invoke "rem_u" (i32.const 0x8ff00ff0) (i32.const 0x10001)) (i32.const 0x8001))
-(assert_return (invoke "rem_u" (i32.const 0x80000001) (i32.const 1000)) (i32.const 649))
-(assert_return (invoke "rem_u" (i32.const 5) (i32.const 2)) (i32.const 1))
-(assert_return (invoke "rem_u" (i32.const -5) (i32.const 2)) (i32.const 1))
-(assert_return (invoke "rem_u" (i32.const 5) (i32.const -2)) (i32.const 5))
-(assert_return (invoke "rem_u" (i32.const -5) (i32.const -2)) (i32.const -5))
-(assert_return (invoke "rem_u" (i32.const 7) (i32.const 3)) (i32.const 1))
-(assert_return (invoke "rem_u" (i32.const 11) (i32.const 5)) (i32.const 1))
-(assert_return (invoke "rem_u" (i32.const 17) (i32.const 7)) (i32.const 3))
-
-(assert_return (invoke "and" (i32.const 1) (i32.const 0)) (i32.const 0))
-(assert_return (invoke "and" (i32.const 0) (i32.const 1)) (i32.const 0))
-(assert_return (invoke "and" (i32.const 1) (i32.const 1)) (i32.const 1))
-(assert_return (invoke "and" (i32.const 0) (i32.const 0)) (i32.const 0))
-(assert_return (invoke "and" (i32.const 0x7fffffff) (i32.const 0x80000000)) (i32.const 0))
-(assert_return (invoke "and" (i32.const 0x7fffffff) (i32.const -1)) (i32.const 0x7fffffff))
-(assert_return (invoke "and" (i32.const 0xf0f0ffff) (i32.const 0xfffff0f0)) (i32.const 0xf0f0f0f0))
-(assert_return (invoke "and" (i32.const 0xffffffff) (i32.const 0xffffffff)) (i32.const 0xffffffff))
-
-(assert_return (invoke "or" (i32.const 1) (i32.const 0)) (i32.const 1))
-(assert_return (invoke "or" (i32.const 0) (i32.const 1)) (i32.const 1))
-(assert_return (invoke "or" (i32.const 1) (i32.const 1)) (i32.const 1))
-(assert_return (invoke "or" (i32.const 0) (i32.const 0)) (i32.const 0))
-(assert_return (invoke "or" (i32.const 0x7fffffff) (i32.const 0x80000000)) (i32.const -1))
-(assert_return (invoke "or" (i32.const 0x80000000) (i32.const 0)) (i32.const 0x80000000))
-(assert_return (invoke "or" (i32.const 0xf0f0ffff) (i32.const 0xfffff0f0)) (i32.const 0xffffffff))
-(assert_return (invoke "or" (i32.const 0xffffffff) (i32.const 0xffffffff)) (i32.const 0xffffffff))
-
-(assert_return (invoke "xor" (i32.const 1) (i32.const 0)) (i32.const 1))
-(assert_return (invoke "xor" (i32.const 0) (i32.const 1)) (i32.const 1))
-(assert_return (invoke "xor" (i32.const 1) (i32.const 1)) (i32.const 0))
-(assert_return (invoke "xor" (i32.const 0) (i32.const 0)) (i32.const 0))
-(assert_return (invoke "xor" (i32.const 0x7fffffff) (i32.const 0x80000000)) (i32.const -1))
-(assert_return (invoke "xor" (i32.const 0x80000000) (i32.const 0)) (i32.const 0x80000000))
-(assert_return (invoke "xor" (i32.const -1) (i32.const 0x80000000)) (i32.const 0x7fffffff))
-(assert_return (invoke "xor" (i32.const -1) (i32.const 0x7fffffff)) (i32.const 0x80000000))
-(assert_return (invoke "xor" (i32.const 0xf0f0ffff) (i32.const 0xfffff0f0)) (i32.const 0x0f0f0f0f))
-(assert_return (invoke "xor" (i32.const 0xffffffff) (i32.const 0xffffffff)) (i32.const 0))
-
-(assert_return (invoke "shl" (i32.const 1) (i32.const 1)) (i32.const 2))
-(assert_return (invoke "shl" (i32.const 1) (i32.const 0)) (i32.const 1))
-(assert_return (invoke "shl" (i32.const 0x7fffffff) (i32.const 1)) (i32.const 0xfffffffe))
-(assert_return (invoke "shl" (i32.const 0xffffffff) (i32.const 1)) (i32.const 0xfffffffe))
-(assert_return (invoke "shl" (i32.const 0x80000000) (i32.const 1)) (i32.const 0))
-(assert_return (invoke "shl" (i32.const 0x40000000) (i32.const 1)) (i32.const 0x80000000))
-(assert_return (invoke "shl" (i32.const 1) (i32.const 31)) (i32.const 0x80000000))
-(assert_return (invoke "shl" (i32.const 1) (i32.const 32)) (i32.const 1))
-(assert_return (invoke "shl" (i32.const 1) (i32.const 33)) (i32.const 2))
-(assert_return (invoke "shl" (i32.const 1) (i32.const -1)) (i32.const 0x80000000))
-(assert_return (invoke "shl" (i32.const 1) (i32.const 0x7fffffff)) (i32.const 0x80000000))
-
-(assert_return (invoke "shr_s" (i32.const 1) (i32.const 1)) (i32.const 0))
-(assert_return (invoke "shr_s" (i32.const 1) (i32.const 0)) (i32.const 1))
-(assert_return (invoke "shr_s" (i32.const -1) (i32.const 1)) (i32.const -1))
-(assert_return (invoke "shr_s" (i32.const 0x7fffffff) (i32.const 1)) (i32.const 0x3fffffff))
-(assert_return (invoke "shr_s" (i32.const 0x80000000) (i32.const 1)) (i32.const 0xc0000000))
-(assert_return (invoke "shr_s" (i32.const 0x40000000) (i32.const 1)) (i32.const 0x20000000))
-(assert_return (invoke "shr_s" (i32.const 1) (i32.const 32)) (i32.const 1))
-(assert_return (invoke "shr_s" (i32.const 1) (i32.const 33)) (i32.const 0))
-(assert_return (invoke "shr_s" (i32.const 1) (i32.const -1)) (i32.const 0))
-(assert_return (invoke "shr_s" (i32.const 1) (i32.const 0x7fffffff)) (i32.const 0))
-(assert_return (invoke "shr_s" (i32.const 1) (i32.const 0x80000000)) (i32.const 1))
-(assert_return (invoke "shr_s" (i32.const 0x80000000) (i32.const 31)) (i32.const -1))
-(assert_return (invoke "shr_s" (i32.const -1) (i32.const 32)) (i32.const -1))
-(assert_return (invoke "shr_s" (i32.const -1) (i32.const 33)) (i32.const -1))
-(assert_return (invoke "shr_s" (i32.const -1) (i32.const -1)) (i32.const -1))
-(assert_return (invoke "shr_s" (i32.const -1) (i32.const 0x7fffffff)) (i32.const -1))
-(assert_return (invoke "shr_s" (i32.const -1) (i32.const 0x80000000)) (i32.const -1))
-
-(assert_return (invoke "shr_u" (i32.const 1) (i32.const 1)) (i32.const 0))
-(assert_return (invoke "shr_u" (i32.const 1) (i32.const 0)) (i32.const 1))
-(assert_return (invoke "shr_u" (i32.const -1) (i32.const 1)) (i32.const 0x7fffffff))
-(assert_return (invoke "shr_u" (i32.const 0x7fffffff) (i32.const 1)) (i32.const 0x3fffffff))
-(assert_return (invoke "shr_u" (i32.const 0x80000000) (i32.const 1)) (i32.const 0x40000000))
-(assert_return (invoke "shr_u" (i32.const 0x40000000) (i32.const 1)) (i32.const 0x20000000))
-(assert_return (invoke "shr_u" (i32.const 1) (i32.const 32)) (i32.const 1))
-(assert_return (invoke "shr_u" (i32.const 1) (i32.const 33)) (i32.const 0))
-(assert_return (invoke "shr_u" (i32.const 1) (i32.const -1)) (i32.const 0))
-(assert_return (invoke "shr_u" (i32.const 1) (i32.const 0x7fffffff)) (i32.const 0))
-(assert_return (invoke "shr_u" (i32.const 1) (i32.const 0x80000000)) (i32.const 1))
-(assert_return (invoke "shr_u" (i32.const 0x80000000) (i32.const 31)) (i32.const 1))
-(assert_return (invoke "shr_u" (i32.const -1) (i32.const 32)) (i32.const -1))
-(assert_return (invoke "shr_u" (i32.const -1) (i32.const 33)) (i32.const 0x7fffffff))
-(assert_return (invoke "shr_u" (i32.const -1) (i32.const -1)) (i32.const 1))
-(assert_return (invoke "shr_u" (i32.const -1) (i32.const 0x7fffffff)) (i32.const 1))
-(assert_return (invoke "shr_u" (i32.const -1) (i32.const 0x80000000)) (i32.const -1))
-
-(assert_return (invoke "rotl" (i32.const 1) (i32.const 1)) (i32.const 2))
-(assert_return (invoke "rotl" (i32.const 1) (i32.const 0)) (i32.const 1))
-(assert_return (invoke "rotl" (i32.const -1) (i32.const 1)) (i32.const -1))
-(assert_return (invoke "rotl" (i32.const 1) (i32.const 32)) (i32.const 1))
-(assert_return (invoke "rotl" (i32.const 0xabcd9876) (i32.const 1)) (i32.const 0x579b30ed))
-(assert_return (invoke "rotl" (i32.const 0xfe00dc00) (i32.const 4)) (i32.const 0xe00dc00f))
-(assert_return (invoke "rotl" (i32.const 0xb0c1d2e3) (i32.const 5)) (i32.const 0x183a5c76))
-(assert_return (invoke "rotl" (i32.const 0x00008000) (i32.const 37)) (i32.const 0x00100000))
-(assert_return (invoke "rotl" (i32.const 0xb0c1d2e3) (i32.const 0xff05)) (i32.const 0x183a5c76))
-(assert_return (invoke "rotl" (i32.const 0x769abcdf) (i32.const 0xffffffed)) (i32.const 0x579beed3))
-(assert_return (invoke "rotl" (i32.const 0x769abcdf) (i32.const 0x8000000d)) (i32.const 0x579beed3))
-(assert_return (invoke "rotl" (i32.const 1) (i32.const 31)) (i32.const 0x80000000))
-(assert_return (invoke "rotl" (i32.const 0x80000000) (i32.const 1)) (i32.const 1))
-
-(assert_return (invoke "rotr" (i32.const 1) (i32.const 1)) (i32.const 0x80000000))
-(assert_return (invoke "rotr" (i32.const 1) (i32.const 0)) (i32.const 1))
-(assert_return (invoke "rotr" (i32.const -1) (i32.const 1)) (i32.const -1))
-(assert_return (invoke "rotr" (i32.const 1) (i32.const 32)) (i32.const 1))
-(assert_return (invoke "rotr" (i32.const 0xff00cc00) (i32.const 1)) (i32.const 0x7f806600))
-(assert_return (invoke "rotr" (i32.const 0x00080000) (i32.const 4)) (i32.const 0x00008000))
-(assert_return (invoke "rotr" (i32.const 0xb0c1d2e3) (i32.const 5)) (i32.const 0x1d860e97))
-(assert_return (invoke "rotr" (i32.const 0x00008000) (i32.const 37)) (i32.const 0x00000400))
-(assert_return (invoke "rotr" (i32.const 0xb0c1d2e3) (i32.const 0xff05)) (i32.const 0x1d860e97))
-(assert_return (invoke "rotr" (i32.const 0x769abcdf) (i32.const 0xffffffed)) (i32.const 0xe6fbb4d5))
-(assert_return (invoke "rotr" (i32.const 0x769abcdf) (i32.const 0x8000000d)) (i32.const 0xe6fbb4d5))
-(assert_return (invoke "rotr" (i32.const 1) (i32.const 31)) (i32.const 2))
-(assert_return (invoke "rotr" (i32.const 0x80000000) (i32.const 31)) (i32.const 1))
-
-(assert_return (invoke "clz" (i32.const 0xffffffff)) (i32.const 0))
-(assert_return (invoke "clz" (i32.const 0)) (i32.const 32))
-(assert_return (invoke "clz" (i32.const 0x00008000)) (i32.const 16))
-(assert_return (invoke "clz" (i32.const 0xff)) (i32.const 24))
-(assert_return (invoke "clz" (i32.const 0x80000000)) (i32.const 0))
-(assert_return (invoke "clz" (i32.const 1)) (i32.const 31))
-(assert_return (invoke "clz" (i32.const 2)) (i32.const 30))
-(assert_return (invoke "clz" (i32.const 0x7fffffff)) (i32.const 1))
-
-(assert_return (invoke "ctz" (i32.const -1)) (i32.const 0))
-(assert_return (invoke "ctz" (i32.const 0)) (i32.const 32))
-(assert_return (invoke "ctz" (i32.const 0x00008000)) (i32.const 15))
-(assert_return (invoke "ctz" (i32.const 0x00010000)) (i32.const 16))
-(assert_return (invoke "ctz" (i32.const 0x80000000)) (i32.const 31))
-(assert_return (invoke "ctz" (i32.const 0x7fffffff)) (i32.const 0))
-
-(assert_return (invoke "popcnt" (i32.const -1)) (i32.const 32))
-(assert_return (invoke "popcnt" (i32.const 0)) (i32.const 0))
-(assert_return (invoke "popcnt" (i32.const 0x00008000)) (i32.const 1))
-(assert_return (invoke "popcnt" (i32.const 0x80008000)) (i32.const 2))
-(assert_return (invoke "popcnt" (i32.const 0x7fffffff)) (i32.const 31))
-(assert_return (invoke "popcnt" (i32.const 0xAAAAAAAA)) (i32.const 16))
-(assert_return (invoke "popcnt" (i32.const 0x55555555)) (i32.const 16))
-(assert_return (invoke "popcnt" (i32.const 0xDEADBEEF)) (i32.const 24))
-
-(assert_return (invoke "eqz" (i32.const 0)) (i32.const 1))
-(assert_return (invoke "eqz" (i32.const 1)) (i32.const 0))
-(assert_return (invoke "eqz" (i32.const 0x80000000)) (i32.const 0))
-(assert_return (invoke "eqz" (i32.const 0x7fffffff)) (i32.const 0))
-(assert_return (invoke "eqz" (i32.const 0xffffffff)) (i32.const 0))
-
-(assert_return (invoke "eq" (i32.const 0) (i32.const 0)) (i32.const 1))
-(assert_return (invoke "eq" (i32.const 1) (i32.const 1)) (i32.const 1))
-(assert_return (invoke "eq" (i32.const -1) (i32.const 1)) (i32.const 0))
-(assert_return (invoke "eq" (i32.const 0x80000000) (i32.const 0x80000000)) (i32.const 1))
-(assert_return (invoke "eq" (i32.const 0x7fffffff) (i32.const 0x7fffffff)) (i32.const 1))
-(assert_return (invoke "eq" (i32.const -1) (i32.const -1)) (i32.const 1))
-(assert_return (invoke "eq" (i32.const 1) (i32.const 0)) (i32.const 0))
-(assert_return (invoke "eq" (i32.const 0) (i32.const 1)) (i32.const 0))
-(assert_return (invoke "eq" (i32.const 0x80000000) (i32.const 0)) (i32.const 0))
-(assert_return (invoke "eq" (i32.const 0) (i32.const 0x80000000)) (i32.const 0))
-(assert_return (invoke "eq" (i32.const 0x80000000) (i32.const -1)) (i32.const 0))
-(assert_return (invoke "eq" (i32.const -1) (i32.const 0x80000000)) (i32.const 0))
-(assert_return (invoke "eq" (i32.const 0x80000000) (i32.const 0x7fffffff)) (i32.const 0))
-(assert_return (invoke "eq" (i32.const 0x7fffffff) (i32.const 0x80000000)) (i32.const 0))
-
-(assert_return (invoke "ne" (i32.const 0) (i32.const 0)) (i32.const 0))
-(assert_return (invoke "ne" (i32.const 1) (i32.const 1)) (i32.const 0))
-(assert_return (invoke "ne" (i32.const -1) (i32.const 1)) (i32.const 1))
-(assert_return (invoke "ne" (i32.const 0x80000000) (i32.const 0x80000000)) (i32.const 0))
-(assert_return (invoke "ne" (i32.const 0x7fffffff) (i32.const 0x7fffffff)) (i32.const 0))
-(assert_return (invoke "ne" (i32.const -1) (i32.const -1)) (i32.const 0))
-(assert_return (invoke "ne" (i32.const 1) (i32.const 0)) (i32.const 1))
-(assert_return (invoke "ne" (i32.const 0) (i32.const 1)) (i32.const 1))
-(assert_return (invoke "ne" (i32.const 0x80000000) (i32.const 0)) (i32.const 1))
-(assert_return (invoke "ne" (i32.const 0) (i32.const 0x80000000)) (i32.const 1))
-(assert_return (invoke "ne" (i32.const 0x80000000) (i32.const -1)) (i32.const 1))
-(assert_return (invoke "ne" (i32.const -1) (i32.const 0x80000000)) (i32.const 1))
-(assert_return (invoke "ne" (i32.const 0x80000000) (i32.const 0x7fffffff)) (i32.const 1))
-(assert_return (invoke "ne" (i32.const 0x7fffffff) (i32.const 0x80000000)) (i32.const 1))
-
-(assert_return (invoke "lt_s" (i32.const 0) (i32.const 0)) (i32.const 0))
-(assert_return (invoke "lt_s" (i32.const 1) (i32.const 1)) (i32.const 0))
-(assert_return (invoke "lt_s" (i32.const -1) (i32.const 1)) (i32.const 1))
-(assert_return (invoke "lt_s" (i32.const 0x80000000) (i32.const 0x80000000)) (i32.const 0))
-(assert_return (invoke "lt_s" (i32.const 0x7fffffff) (i32.const 0x7fffffff)) (i32.const 0))
-(assert_return (invoke "lt_s" (i32.const -1) (i32.const -1)) (i32.const 0))
-(assert_return (invoke "lt_s" (i32.const 1) (i32.const 0)) (i32.const 0))
-(assert_return (invoke "lt_s" (i32.const 0) (i32.const 1)) (i32.const 1))
-(assert_return (invoke "lt_s" (i32.const 0x80000000) (i32.const 0)) (i32.const 1))
-(assert_return (invoke "lt_s" (i32.const 0) (i32.const 0x80000000)) (i32.const 0))
-(assert_return (invoke "lt_s" (i32.const 0x80000000) (i32.const -1)) (i32.const 1))
-(assert_return (invoke "lt_s" (i32.const -1) (i32.const 0x80000000)) (i32.const 0))
-(assert_return (invoke "lt_s" (i32.const 0x80000000) (i32.const 0x7fffffff)) (i32.const 1))
-(assert_return (invoke "lt_s" (i32.const 0x7fffffff) (i32.const 0x80000000)) (i32.const 0))
-
-(assert_return (invoke "lt_u" (i32.const 0) (i32.const 0)) (i32.const 0))
-(assert_return (invoke "lt_u" (i32.const 1) (i32.const 1)) (i32.const 0))
-(assert_return (invoke "lt_u" (i32.const -1) (i32.const 1)) (i32.const 0))
-(assert_return (invoke "lt_u" (i32.const 0x80000000) (i32.const 0x80000000)) (i32.const 0))
-(assert_return (invoke "lt_u" (i32.const 0x7fffffff) (i32.const 0x7fffffff)) (i32.const 0))
-(assert_return (invoke "lt_u" (i32.const -1) (i32.const -1)) (i32.const 0))
-(assert_return (invoke "lt_u" (i32.const 1) (i32.const 0)) (i32.const 0))
-(assert_return (invoke "lt_u" (i32.const 0) (i32.const 1)) (i32.const 1))
-(assert_return (invoke "lt_u" (i32.const 0x80000000) (i32.const 0)) (i32.const 0))
-(assert_return (invoke "lt_u" (i32.const 0) (i32.const 0x80000000)) (i32.const 1))
-(assert_return (invoke "lt_u" (i32.const 0x80000000) (i32.const -1)) (i32.const 1))
-(assert_return (invoke "lt_u" (i32.const -1) (i32.const 0x80000000)) (i32.const 0))
-(assert_return (invoke "lt_u" (i32.const 0x80000000) (i32.const 0x7fffffff)) (i32.const 0))
-(assert_return (invoke "lt_u" (i32.const 0x7fffffff) (i32.const 0x80000000)) (i32.const 1))
-
-(assert_return (invoke "le_s" (i32.const 0) (i32.const 0)) (i32.const 1))
-(assert_return (invoke "le_s" (i32.const 1) (i32.const 1)) (i32.const 1))
-(assert_return (invoke "le_s" (i32.const -1) (i32.const 1)) (i32.const 1))
-(assert_return (invoke "le_s" (i32.const 0x80000000) (i32.const 0x80000000)) (i32.const 1))
-(assert_return (invoke "le_s" (i32.const 0x7fffffff) (i32.const 0x7fffffff)) (i32.const 1))
-(assert_return (invoke "le_s" (i32.const -1) (i32.const -1)) (i32.const 1))
-(assert_return (invoke "le_s" (i32.const 1) (i32.const 0)) (i32.const 0))
-(assert_return (invoke "le_s" (i32.const 0) (i32.const 1)) (i32.const 1))
-(assert_return (invoke "le_s" (i32.const 0x80000000) (i32.const 0)) (i32.const 1))
-(assert_return (invoke "le_s" (i32.const 0) (i32.const 0x80000000)) (i32.const 0))
-(assert_return (invoke "le_s" (i32.const 0x80000000) (i32.const -1)) (i32.const 1))
-(assert_return (invoke "le_s" (i32.const -1) (i32.const 0x80000000)) (i32.const 0))
-(assert_return (invoke "le_s" (i32.const 0x80000000) (i32.const 0x7fffffff)) (i32.const 1))
-(assert_return (invoke "le_s" (i32.const 0x7fffffff) (i32.const 0x80000000)) (i32.const 0))
-
-(assert_return (invoke "le_u" (i32.const 0) (i32.const 0)) (i32.const 1))
-(assert_return (invoke "le_u" (i32.const 1) (i32.const 1)) (i32.const 1))
-(assert_return (invoke "le_u" (i32.const -1) (i32.const 1)) (i32.const 0))
-(assert_return (invoke "le_u" (i32.const 0x80000000) (i32.const 0x80000000)) (i32.const 1))
-(assert_return (invoke "le_u" (i32.const 0x7fffffff) (i32.const 0x7fffffff)) (i32.const 1))
-(assert_return (invoke "le_u" (i32.const -1) (i32.const -1)) (i32.const 1))
-(assert_return (invoke "le_u" (i32.const 1) (i32.const 0)) (i32.const 0))
-(assert_return (invoke "le_u" (i32.const 0) (i32.const 1)) (i32.const 1))
-(assert_return (invoke "le_u" (i32.const 0x80000000) (i32.const 0)) (i32.const 0))
-(assert_return (invoke "le_u" (i32.const 0) (i32.const 0x80000000)) (i32.const 1))
-(assert_return (invoke "le_u" (i32.const 0x80000000) (i32.const -1)) (i32.const 1))
-(assert_return (invoke "le_u" (i32.const -1) (i32.const 0x80000000)) (i32.const 0))
-(assert_return (invoke "le_u" (i32.const 0x80000000) (i32.const 0x7fffffff)) (i32.const 0))
-(assert_return (invoke "le_u" (i32.const 0x7fffffff) (i32.const 0x80000000)) (i32.const 1))
-
-(assert_return (invoke "gt_s" (i32.const 0) (i32.const 0)) (i32.const 0))
-(assert_return (invoke "gt_s" (i32.const 1) (i32.const 1)) (i32.const 0))
-(assert_return (invoke "gt_s" (i32.const -1) (i32.const 1)) (i32.const 0))
-(assert_return (invoke "gt_s" (i32.const 0x80000000) (i32.const 0x80000000)) (i32.const 0))
-(assert_return (invoke "gt_s" (i32.const 0x7fffffff) (i32.const 0x7fffffff)) (i32.const 0))
-(assert_return (invoke "gt_s" (i32.const -1) (i32.const -1)) (i32.const 0))
-(assert_return (invoke "gt_s" (i32.const 1) (i32.const 0)) (i32.const 1))
-(assert_return (invoke "gt_s" (i32.const 0) (i32.const 1)) (i32.const 0))
-(assert_return (invoke "gt_s" (i32.const 0x80000000) (i32.const 0)) (i32.const 0))
-(assert_return (invoke "gt_s" (i32.const 0) (i32.const 0x80000000)) (i32.const 1))
-(assert_return (invoke "gt_s" (i32.const 0x80000000) (i32.const -1)) (i32.const 0))
-(assert_return (invoke "gt_s" (i32.const -1) (i32.const 0x80000000)) (i32.const 1))
-(assert_return (invoke "gt_s" (i32.const 0x80000000) (i32.const 0x7fffffff)) (i32.const 0))
-(assert_return (invoke "gt_s" (i32.const 0x7fffffff) (i32.const 0x80000000)) (i32.const 1))
-
-(assert_return (invoke "gt_u" (i32.const 0) (i32.const 0)) (i32.const 0))
-(assert_return (invoke "gt_u" (i32.const 1) (i32.const 1)) (i32.const 0))
-(assert_return (invoke "gt_u" (i32.const -1) (i32.const 1)) (i32.const 1))
-(assert_return (invoke "gt_u" (i32.const 0x80000000) (i32.const 0x80000000)) (i32.const 0))
-(assert_return (invoke "gt_u" (i32.const 0x7fffffff) (i32.const 0x7fffffff)) (i32.const 0))
-(assert_return (invoke "gt_u" (i32.const -1) (i32.const -1)) (i32.const 0))
-(assert_return (invoke "gt_u" (i32.const 1) (i32.const 0)) (i32.const 1))
-(assert_return (invoke "gt_u" (i32.const 0) (i32.const 1)) (i32.const 0))
-(assert_return (invoke "gt_u" (i32.const 0x80000000) (i32.const 0)) (i32.const 1))
-(assert_return (invoke "gt_u" (i32.const 0) (i32.const 0x80000000)) (i32.const 0))
-(assert_return (invoke "gt_u" (i32.const 0x80000000) (i32.const -1)) (i32.const 0))
-(assert_return (invoke "gt_u" (i32.const -1) (i32.const 0x80000000)) (i32.const 1))
-(assert_return (invoke "gt_u" (i32.const 0x80000000) (i32.const 0x7fffffff)) (i32.const 1))
-(assert_return (invoke "gt_u" (i32.const 0x7fffffff) (i32.const 0x80000000)) (i32.const 0))
-
-(assert_return (invoke "ge_s" (i32.const 0) (i32.const 0)) (i32.const 1))
-(assert_return (invoke "ge_s" (i32.const 1) (i32.const 1)) (i32.const 1))
-(assert_return (invoke "ge_s" (i32.const -1) (i32.const 1)) (i32.const 0))
-(assert_return (invoke "ge_s" (i32.const 0x80000000) (i32.const 0x80000000)) (i32.const 1))
-(assert_return (invoke "ge_s" (i32.const 0x7fffffff) (i32.const 0x7fffffff)) (i32.const 1))
-(assert_return (invoke "ge_s" (i32.const -1) (i32.const -1)) (i32.const 1))
-(assert_return (invoke "ge_s" (i32.const 1) (i32.const 0)) (i32.const 1))
-(assert_return (invoke "ge_s" (i32.const 0) (i32.const 1)) (i32.const 0))
-(assert_return (invoke "ge_s" (i32.const 0x80000000) (i32.const 0)) (i32.const 0))
-(assert_return (invoke "ge_s" (i32.const 0) (i32.const 0x80000000)) (i32.const 1))
-(assert_return (invoke "ge_s" (i32.const 0x80000000) (i32.const -1)) (i32.const 0))
-(assert_return (invoke "ge_s" (i32.const -1) (i32.const 0x80000000)) (i32.const 1))
-(assert_return (invoke "ge_s" (i32.const 0x80000000) (i32.const 0x7fffffff)) (i32.const 0))
-(assert_return (invoke "ge_s" (i32.const 0x7fffffff) (i32.const 0x80000000)) (i32.const 1))
-
-(assert_return (invoke "ge_u" (i32.const 0) (i32.const 0)) (i32.const 1))
-(assert_return (invoke "ge_u" (i32.const 1) (i32.const 1)) (i32.const 1))
-(assert_return (invoke "ge_u" (i32.const -1) (i32.const 1)) (i32.const 1))
-(assert_return (invoke "ge_u" (i32.const 0x80000000) (i32.const 0x80000000)) (i32.const 1))
-(assert_return (invoke "ge_u" (i32.const 0x7fffffff) (i32.const 0x7fffffff)) (i32.const 1))
-(assert_return (invoke "ge_u" (i32.const -1) (i32.const -1)) (i32.const 1))
-(assert_return (invoke "ge_u" (i32.const 1) (i32.const 0)) (i32.const 1))
-(assert_return (invoke "ge_u" (i32.const 0) (i32.const 1)) (i32.const 0))
-(assert_return (invoke "ge_u" (i32.const 0x80000000) (i32.const 0)) (i32.const 1))
-(assert_return (invoke "ge_u" (i32.const 0) (i32.const 0x80000000)) (i32.const 0))
-(assert_return (invoke "ge_u" (i32.const 0x80000000) (i32.const -1)) (i32.const 0))
-(assert_return (invoke "ge_u" (i32.const -1) (i32.const 0x80000000)) (i32.const 1))
-(assert_return (invoke "ge_u" (i32.const 0x80000000) (i32.const 0x7fffffff)) (i32.const 1))
-(assert_return (invoke "ge_u" (i32.const 0x7fffffff) (i32.const 0x80000000)) (i32.const 0))
diff --git a/tests/misc_testsuite/winch/i64.wast b/tests/misc_testsuite/winch/i64.wast
deleted file mode 100644
index 1783c6178..000000000
--- a/tests/misc_testsuite/winch/i64.wast
+++ /dev/null
@@ -1,422 +0,0 @@
-;; i64 operations
-
-(module
-  (func (export "add") (param $x i64) (param $y i64) (result i64) (i64.add (local.get $x) (local.get $y)))
-  (func (export "sub") (param $x i64) (param $y i64) (result i64) (i64.sub (local.get $x) (local.get $y)))
-  (func (export "mul") (param $x i64) (param $y i64) (result i64) (i64.mul (local.get $x) (local.get $y)))
-  (func (export "div_s") (param $x i64) (param $y i64) (result i64) (i64.div_s (local.get $x) (local.get $y)))
-  (func (export "div_u") (param $x i64) (param $y i64) (result i64) (i64.div_u (local.get $x) (local.get $y)))
-  (func (export "rem_s") (param $x i64) (param $y i64) (result i64) (i64.rem_s (local.get $x) (local.get $y)))
-  (func (export "rem_u") (param $x i64) (param $y i64) (result i64) (i64.rem_u (local.get $x) (local.get $y)))
-  (func (export "and") (param $x i64) (param $y i64) (result i64) (i64.and (local.get $x) (local.get $y)))
-  (func (export "or") (param $x i64) (param $y i64) (result i64) (i64.or (local.get $x) (local.get $y)))
-  (func (export "xor") (param $x i64) (param $y i64) (result i64) (i64.xor (local.get $x) (local.get $y)))
-  (func (export "shl") (param $x i64) (param $y i64) (result i64) (i64.shl (local.get $x) (local.get $y)))
-  (func (export "shr_s") (param $x i64) (param $y i64) (result i64) (i64.shr_s (local.get $x) (local.get $y)))
-  (func (export "shr_u") (param $x i64) (param $y i64) (result i64) (i64.shr_u (local.get $x) (local.get $y)))
-  (func (export "rotl") (param $x i64) (param $y i64) (result i64) (i64.rotl (local.get $x) (local.get $y)))
-  (func (export "rotr") (param $x i64) (param $y i64) (result i64) (i64.rotr (local.get $x) (local.get $y)))
-  (func (export "clz") (param $x i64) (result i64) (i64.clz (local.get $x)))
-  (func (export "ctz") (param $x i64) (result i64) (i64.ctz (local.get $x)))
-  (func (export "popcnt") (param $x i64) (result i64) (i64.popcnt (local.get $x)))
-  (func (export "eqz") (param $x i64) (result i32) (i64.eqz (local.get $x)))
-  (func (export "eq") (param $x i64) (param $y i64) (result i32) (i64.eq (local.get $x) (local.get $y)))
-  (func (export "ne") (param $x i64) (param $y i64) (result i32) (i64.ne (local.get $x) (local.get $y)))
-  (func (export "lt_s") (param $x i64) (param $y i64) (result i32) (i64.lt_s (local.get $x) (local.get $y)))
-  (func (export "lt_u") (param $x i64) (param $y i64) (result i32) (i64.lt_u (local.get $x) (local.get $y)))
-  (func (export "le_s") (param $x i64) (param $y i64) (result i32) (i64.le_s (local.get $x) (local.get $y)))
-  (func (export "le_u") (param $x i64) (param $y i64) (result i32) (i64.le_u (local.get $x) (local.get $y)))
-  (func (export "gt_s") (param $x i64) (param $y i64) (result i32) (i64.gt_s (local.get $x) (local.get $y)))
-  (func (export "gt_u") (param $x i64) (param $y i64) (result i32) (i64.gt_u (local.get $x) (local.get $y)))
-  (func (export "ge_s") (param $x i64) (param $y i64) (result i32) (i64.ge_s (local.get $x) (local.get $y)))
-  (func (export "ge_u") (param $x i64) (param $y i64) (result i32) (i64.ge_u (local.get $x) (local.get $y)))
-)
-
-(assert_return (invoke "add" (i64.const 1) (i64.const 1)) (i64.const 2))
-(assert_return (invoke "add" (i64.const 1) (i64.const 0)) (i64.const 1))
-(assert_return (invoke "add" (i64.const -1) (i64.const -1)) (i64.const -2))
-(assert_return (invoke "add" (i64.const -1) (i64.const 1)) (i64.const 0))
-(assert_return (invoke "add" (i64.const 0x7fffffffffffffff) (i64.const 1)) (i64.const 0x8000000000000000))
-(assert_return (invoke "add" (i64.const 0x8000000000000000) (i64.const -1)) (i64.const 0x7fffffffffffffff))
-(assert_return (invoke "add" (i64.const 0x8000000000000000) (i64.const 0x8000000000000000)) (i64.const 0))
-(assert_return (invoke "add" (i64.const 0x3fffffff) (i64.const 1)) (i64.const 0x40000000))
-
-(assert_return (invoke "sub" (i64.const 1) (i64.const 1)) (i64.const 0))
-(assert_return (invoke "sub" (i64.const 1) (i64.const 0)) (i64.const 1))
-(assert_return (invoke "sub" (i64.const -1) (i64.const -1)) (i64.const 0))
-(assert_return (invoke "sub" (i64.const 0x7fffffffffffffff) (i64.const -1)) (i64.const 0x8000000000000000))
-(assert_return (invoke "sub" (i64.const 0x8000000000000000) (i64.const 1)) (i64.const 0x7fffffffffffffff))
-(assert_return (invoke "sub" (i64.const 0x8000000000000000) (i64.const 0x8000000000000000)) (i64.const 0))
-(assert_return (invoke "sub" (i64.const 0x3fffffff) (i64.const -1)) (i64.const 0x40000000))
-
-(assert_return (invoke "mul" (i64.const 1) (i64.const 1)) (i64.const 1))
-(assert_return (invoke "mul" (i64.const 1) (i64.const 0)) (i64.const 0))
-(assert_return (invoke "mul" (i64.const -1) (i64.const -1)) (i64.const 1))
-(assert_return (invoke "mul" (i64.const 0x1000000000000000) (i64.const 4096)) (i64.const 0))
-(assert_return (invoke "mul" (i64.const 0x8000000000000000) (i64.const 0)) (i64.const 0))
-(assert_return (invoke "mul" (i64.const 0x8000000000000000) (i64.const -1)) (i64.const 0x8000000000000000))
-(assert_return (invoke "mul" (i64.const 0x7fffffffffffffff) (i64.const -1)) (i64.const 0x8000000000000001))
-(assert_return (invoke "mul" (i64.const 0x0123456789abcdef) (i64.const 0xfedcba9876543210)) (i64.const 0x2236d88fe5618cf0))
-(assert_return (invoke "mul" (i64.const 0x7fffffffffffffff) (i64.const 0x7fffffffffffffff)) (i64.const 1))
-
-(assert_trap (invoke "div_s" (i64.const 1) (i64.const 0)) "integer divide by zero")
-(assert_trap (invoke "div_s" (i64.const 0) (i64.const 0)) "integer divide by zero")
-(assert_trap (invoke "div_s" (i64.const 0x8000000000000000) (i64.const -1)) "integer overflow")
-(assert_trap (invoke "div_s" (i64.const 0x8000000000000000) (i64.const 0)) "integer divide by zero")
-(assert_return (invoke "div_s" (i64.const 1) (i64.const 1)) (i64.const 1))
-(assert_return (invoke "div_s" (i64.const 0) (i64.const 1)) (i64.const 0))
-(assert_return (invoke "div_s" (i64.const 0) (i64.const -1)) (i64.const 0))
-(assert_return (invoke "div_s" (i64.const -1) (i64.const -1)) (i64.const 1))
-(assert_return (invoke "div_s" (i64.const 0x8000000000000000) (i64.const 2)) (i64.const 0xc000000000000000))
-(assert_return (invoke "div_s" (i64.const 0x8000000000000001) (i64.const 1000)) (i64.const 0xffdf3b645a1cac09))
-(assert_return (invoke "div_s" (i64.const 5) (i64.const 2)) (i64.const 2))
-(assert_return (invoke "div_s" (i64.const -5) (i64.const 2)) (i64.const -2))
-(assert_return (invoke "div_s" (i64.const 5) (i64.const -2)) (i64.const -2))
-(assert_return (invoke "div_s" (i64.const -5) (i64.const -2)) (i64.const 2))
-(assert_return (invoke "div_s" (i64.const 7) (i64.const 3)) (i64.const 2))
-(assert_return (invoke "div_s" (i64.const -7) (i64.const 3)) (i64.const -2))
-(assert_return (invoke "div_s" (i64.const 7) (i64.const -3)) (i64.const -2))
-(assert_return (invoke "div_s" (i64.const -7) (i64.const -3)) (i64.const 2))
-(assert_return (invoke "div_s" (i64.const 11) (i64.const 5)) (i64.const 2))
-(assert_return (invoke "div_s" (i64.const 17) (i64.const 7)) (i64.const 2))
-
-(assert_trap (invoke "div_u" (i64.const 1) (i64.const 0)) "integer divide by zero")
-(assert_trap (invoke "div_u" (i64.const 0) (i64.const 0)) "integer divide by zero")
-(assert_return (invoke "div_u" (i64.const 1) (i64.const 1)) (i64.const 1))
-(assert_return (invoke "div_u" (i64.const 0) (i64.const 1)) (i64.const 0))
-(assert_return (invoke "div_u" (i64.const -1) (i64.const -1)) (i64.const 1))
-(assert_return (invoke "div_u" (i64.const 0x8000000000000000) (i64.const -1)) (i64.const 0))
-(assert_return (invoke "div_u" (i64.const 0x8000000000000000) (i64.const 2)) (i64.const 0x4000000000000000))
-(assert_return (invoke "div_u" (i64.const 0x8ff00ff00ff00ff0) (i64.const 0x100000001)) (i64.const 0x8ff00fef))
-(assert_return (invoke "div_u" (i64.const 0x8000000000000001) (i64.const 1000)) (i64.const 0x20c49ba5e353f7))
-(assert_return (invoke "div_u" (i64.const 5) (i64.const 2)) (i64.const 2))
-(assert_return (invoke "div_u" (i64.const -5) (i64.const 2)) (i64.const 0x7ffffffffffffffd))
-(assert_return (invoke "div_u" (i64.const 5) (i64.const -2)) (i64.const 0))
-(assert_return (invoke "div_u" (i64.const -5) (i64.const -2)) (i64.const 0))
-(assert_return (invoke "div_u" (i64.const 7) (i64.const 3)) (i64.const 2))
-(assert_return (invoke "div_u" (i64.const 11) (i64.const 5)) (i64.const 2))
-(assert_return (invoke "div_u" (i64.const 17) (i64.const 7)) (i64.const 2))
-
-(assert_trap (invoke "rem_s" (i64.const 1) (i64.const 0)) "integer divide by zero")
-(assert_trap (invoke "rem_s" (i64.const 0) (i64.const 0)) "integer divide by zero")
-(assert_return (invoke "rem_s" (i64.const 0x7fffffffffffffff) (i64.const -1)) (i64.const 0))
-(assert_return (invoke "rem_s" (i64.const 1) (i64.const 1)) (i64.const 0))
-(assert_return (invoke "rem_s" (i64.const 0) (i64.const 1)) (i64.const 0))
-(assert_return (invoke "rem_s" (i64.const 0) (i64.const -1)) (i64.const 0))
-(assert_return (invoke "rem_s" (i64.const -1) (i64.const -1)) (i64.const 0))
-(assert_return (invoke "rem_s" (i64.const 0x8000000000000000) (i64.const -1)) (i64.const 0))
-(assert_return (invoke "rem_s" (i64.const 0x8000000000000000) (i64.const 2)) (i64.const 0))
-(assert_return (invoke "rem_s" (i64.const 0x8000000000000001) (i64.const 1000)) (i64.const -807))
-(assert_return (invoke "rem_s" (i64.const 5) (i64.const 2)) (i64.const 1))
-(assert_return (invoke "rem_s" (i64.const -5) (i64.const 2)) (i64.const -1))
-(assert_return (invoke "rem_s" (i64.const 5) (i64.const -2)) (i64.const 1))
-(assert_return (invoke "rem_s" (i64.const -5) (i64.const -2)) (i64.const -1))
-(assert_return (invoke "rem_s" (i64.const 7) (i64.const 3)) (i64.const 1))
-(assert_return (invoke "rem_s" (i64.const -7) (i64.const 3)) (i64.const -1))
-(assert_return (invoke "rem_s" (i64.const 7) (i64.const -3)) (i64.const 1))
-(assert_return (invoke "rem_s" (i64.const -7) (i64.const -3)) (i64.const -1))
-(assert_return (invoke "rem_s" (i64.const 11) (i64.const 5)) (i64.const 1))
-(assert_return (invoke "rem_s" (i64.const 17) (i64.const 7)) (i64.const 3))
-
-(assert_trap (invoke "rem_u" (i64.const 1) (i64.const 0)) "integer divide by zero")
-(assert_trap (invoke "rem_u" (i64.const 0) (i64.const 0)) "integer divide by zero")
-(assert_return (invoke "rem_u" (i64.const 1) (i64.const 1)) (i64.const 0))
-(assert_return (invoke "rem_u" (i64.const 0) (i64.const 1)) (i64.const 0))
-(assert_return (invoke "rem_u" (i64.const -1) (i64.const -1)) (i64.const 0))
-(assert_return (invoke "rem_u" (i64.const 0x8000000000000000) (i64.const -1)) (i64.const 0x8000000000000000))
-(assert_return (invoke "rem_u" (i64.const 0x8000000000000000) (i64.const 2)) (i64.const 0))
-(assert_return (invoke "rem_u" (i64.const 0x8ff00ff00ff00ff0) (i64.const 0x100000001)) (i64.const 0x80000001))
-(assert_return (invoke "rem_u" (i64.const 0x8000000000000001) (i64.const 1000)) (i64.const 809))
-(assert_return (invoke "rem_u" (i64.const 5) (i64.const 2)) (i64.const 1))
-(assert_return (invoke "rem_u" (i64.const -5) (i64.const 2)) (i64.const 1))
-(assert_return (invoke "rem_u" (i64.const 5) (i64.const -2)) (i64.const 5))
-(assert_return (invoke "rem_u" (i64.const -5) (i64.const -2)) (i64.const -5))
-(assert_return (invoke "rem_u" (i64.const 7) (i64.const 3)) (i64.const 1))
-(assert_return (invoke "rem_u" (i64.const 11) (i64.const 5)) (i64.const 1))
-(assert_return (invoke "rem_u" (i64.const 17) (i64.const 7)) (i64.const 3))
-
-(assert_return (invoke "and" (i64.const 1) (i64.const 0)) (i64.const 0))
-(assert_return (invoke "and" (i64.const 0) (i64.const 1)) (i64.const 0))
-(assert_return (invoke "and" (i64.const 1) (i64.const 1)) (i64.const 1))
-(assert_return (invoke "and" (i64.const 0) (i64.const 0)) (i64.const 0))
-(assert_return (invoke "and" (i64.const 0x7fffffffffffffff) (i64.const 0x8000000000000000)) (i64.const 0))
-(assert_return (invoke "and" (i64.const 0x7fffffffffffffff) (i64.const -1)) (i64.const 0x7fffffffffffffff))
-(assert_return (invoke "and" (i64.const 0xf0f0ffff) (i64.const 0xfffff0f0)) (i64.const 0xf0f0f0f0))
-(assert_return (invoke "and" (i64.const 0xffffffffffffffff) (i64.const 0xffffffffffffffff)) (i64.const 0xffffffffffffffff))
-
-(assert_return (invoke "or" (i64.const 1) (i64.const 0)) (i64.const 1))
-(assert_return (invoke "or" (i64.const 0) (i64.const 1)) (i64.const 1))
-(assert_return (invoke "or" (i64.const 1) (i64.const 1)) (i64.const 1))
-(assert_return (invoke "or" (i64.const 0) (i64.const 0)) (i64.const 0))
-(assert_return (invoke "or" (i64.const 0x7fffffffffffffff) (i64.const 0x8000000000000000)) (i64.const -1))
-(assert_return (invoke "or" (i64.const 0x8000000000000000) (i64.const 0)) (i64.const 0x8000000000000000))
-(assert_return (invoke "or" (i64.const 0xf0f0ffff) (i64.const 0xfffff0f0)) (i64.const 0xffffffff))
-(assert_return (invoke "or" (i64.const 0xffffffffffffffff) (i64.const 0xffffffffffffffff)) (i64.const 0xffffffffffffffff))
-
-(assert_return (invoke "xor" (i64.const 1) (i64.const 0)) (i64.const 1))
-(assert_return (invoke "xor" (i64.const 0) (i64.const 1)) (i64.const 1))
-(assert_return (invoke "xor" (i64.const 1) (i64.const 1)) (i64.const 0))
-(assert_return (invoke "xor" (i64.const 0) (i64.const 0)) (i64.const 0))
-(assert_return (invoke "xor" (i64.const 0x7fffffffffffffff) (i64.const 0x8000000000000000)) (i64.const -1))
-(assert_return (invoke "xor" (i64.const 0x8000000000000000) (i64.const 0)) (i64.const 0x8000000000000000))
-(assert_return (invoke "xor" (i64.const -1) (i64.const 0x8000000000000000)) (i64.const 0x7fffffffffffffff))
-(assert_return (invoke "xor" (i64.const -1) (i64.const 0x7fffffffffffffff)) (i64.const 0x8000000000000000))
-(assert_return (invoke "xor" (i64.const 0xf0f0ffff) (i64.const 0xfffff0f0)) (i64.const 0x0f0f0f0f))
-(assert_return (invoke "xor" (i64.const 0xffffffffffffffff) (i64.const 0xffffffffffffffff)) (i64.const 0))
-
-(assert_return (invoke "shl" (i64.const 1) (i64.const 1)) (i64.const 2))
-(assert_return (invoke "shl" (i64.const 1) (i64.const 0)) (i64.const 1))
-(assert_return (invoke "shl" (i64.const 0x7fffffffffffffff) (i64.const 1)) (i64.const 0xfffffffffffffffe))
-(assert_return (invoke "shl" (i64.const 0xffffffffffffffff) (i64.const 1)) (i64.const 0xfffffffffffffffe))
-(assert_return (invoke "shl" (i64.const 0x8000000000000000) (i64.const 1)) (i64.const 0))
-(assert_return (invoke "shl" (i64.const 0x4000000000000000) (i64.const 1)) (i64.const 0x8000000000000000))
-(assert_return (invoke "shl" (i64.const 1) (i64.const 63)) (i64.const 0x8000000000000000))
-(assert_return (invoke "shl" (i64.const 1) (i64.const 64)) (i64.const 1))
-(assert_return (invoke "shl" (i64.const 1) (i64.const 65)) (i64.const 2))
-(assert_return (invoke "shl" (i64.const 1) (i64.const -1)) (i64.const 0x8000000000000000))
-(assert_return (invoke "shl" (i64.const 1) (i64.const 0x7fffffffffffffff)) (i64.const 0x8000000000000000))
-
-(assert_return (invoke "shr_s" (i64.const 1) (i64.const 1)) (i64.const 0))
-(assert_return (invoke "shr_s" (i64.const 1) (i64.const 0)) (i64.const 1))
-(assert_return (invoke "shr_s" (i64.const -1) (i64.const 1)) (i64.const -1))
-(assert_return (invoke "shr_s" (i64.const 0x7fffffffffffffff) (i64.const 1)) (i64.const 0x3fffffffffffffff))
-(assert_return (invoke "shr_s" (i64.const 0x8000000000000000) (i64.const 1)) (i64.const 0xc000000000000000))
-(assert_return (invoke "shr_s" (i64.const 0x4000000000000000) (i64.const 1)) (i64.const 0x2000000000000000))
-(assert_return (invoke "shr_s" (i64.const 1) (i64.const 64)) (i64.const 1))
-(assert_return (invoke "shr_s" (i64.const 1) (i64.const 65)) (i64.const 0))
-(assert_return (invoke "shr_s" (i64.const 1) (i64.const -1)) (i64.const 0))
-(assert_return (invoke "shr_s" (i64.const 1) (i64.const 0x7fffffffffffffff)) (i64.const 0))
-(assert_return (invoke "shr_s" (i64.const 1) (i64.const 0x8000000000000000)) (i64.const 1))
-(assert_return (invoke "shr_s" (i64.const 0x8000000000000000) (i64.const 63)) (i64.const -1))
-(assert_return (invoke "shr_s" (i64.const -1) (i64.const 64)) (i64.const -1))
-(assert_return (invoke "shr_s" (i64.const -1) (i64.const 65)) (i64.const -1))
-(assert_return (invoke "shr_s" (i64.const -1) (i64.const -1)) (i64.const -1))
-(assert_return (invoke "shr_s" (i64.const -1) (i64.const 0x7fffffffffffffff)) (i64.const -1))
-(assert_return (invoke "shr_s" (i64.const -1) (i64.const 0x8000000000000000)) (i64.const -1))
-
-(assert_return (invoke "shr_u" (i64.const 1) (i64.const 1)) (i64.const 0))
-(assert_return (invoke "shr_u" (i64.const 1) (i64.const 0)) (i64.const 1))
-(assert_return (invoke "shr_u" (i64.const -1) (i64.const 1)) (i64.const 0x7fffffffffffffff))
-(assert_return (invoke "shr_u" (i64.const 0x7fffffffffffffff) (i64.const 1)) (i64.const 0x3fffffffffffffff))
-(assert_return (invoke "shr_u" (i64.const 0x8000000000000000) (i64.const 1)) (i64.const 0x4000000000000000))
-(assert_return (invoke "shr_u" (i64.const 0x4000000000000000) (i64.const 1)) (i64.const 0x2000000000000000))
-(assert_return (invoke "shr_u" (i64.const 1) (i64.const 64)) (i64.const 1))
-(assert_return (invoke "shr_u" (i64.const 1) (i64.const 65)) (i64.const 0))
-(assert_return (invoke "shr_u" (i64.const 1) (i64.const -1)) (i64.const 0))
-(assert_return (invoke "shr_u" (i64.const 1) (i64.const 0x7fffffffffffffff)) (i64.const 0))
-(assert_return (invoke "shr_u" (i64.const 1) (i64.const 0x8000000000000000)) (i64.const 1))
-(assert_return (invoke "shr_u" (i64.const 0x8000000000000000) (i64.const 63)) (i64.const 1))
-(assert_return (invoke "shr_u" (i64.const -1) (i64.const 64)) (i64.const -1))
-(assert_return (invoke "shr_u" (i64.const -1) (i64.const 65)) (i64.const 0x7fffffffffffffff))
-(assert_return (invoke "shr_u" (i64.const -1) (i64.const -1)) (i64.const 1))
-(assert_return (invoke "shr_u" (i64.const -1) (i64.const 0x7fffffffffffffff)) (i64.const 1))
-(assert_return (invoke "shr_u" (i64.const -1) (i64.const 0x8000000000000000)) (i64.const -1))
-
-(assert_return (invoke "rotl" (i64.const 1) (i64.const 1)) (i64.const 2))
-(assert_return (invoke "rotl" (i64.const 1) (i64.const 0)) (i64.const 1))
-(assert_return (invoke "rotl" (i64.const -1) (i64.const 1)) (i64.const -1))
-(assert_return (invoke "rotl" (i64.const 1) (i64.const 64)) (i64.const 1))
-(assert_return (invoke "rotl" (i64.const 0xabcd987602468ace) (i64.const 1)) (i64.const 0x579b30ec048d159d))
-(assert_return (invoke "rotl" (i64.const 0xfe000000dc000000) (i64.const 4)) (i64.const 0xe000000dc000000f))
-(assert_return (invoke "rotl" (i64.const 0xabcd1234ef567809) (i64.const 53)) (i64.const 0x013579a2469deacf))
-(assert_return (invoke "rotl" (i64.const 0xabd1234ef567809c) (i64.const 63)) (i64.const 0x55e891a77ab3c04e))
-(assert_return (invoke "rotl" (i64.const 0xabcd1234ef567809) (i64.const 0xf5)) (i64.const 0x013579a2469deacf))
-(assert_return (invoke "rotl" (i64.const 0xabcd7294ef567809) (i64.const 0xffffffffffffffed)) (i64.const 0xcf013579ae529dea))
-(assert_return (invoke "rotl" (i64.const 0xabd1234ef567809c) (i64.const 0x800000000000003f)) (i64.const 0x55e891a77ab3c04e))
-(assert_return (invoke "rotl" (i64.const 1) (i64.const 63)) (i64.const 0x8000000000000000))
-(assert_return (invoke "rotl" (i64.const 0x8000000000000000) (i64.const 1)) (i64.const 1))
-
-(assert_return (invoke "rotr" (i64.const 1) (i64.const 1)) (i64.const 0x8000000000000000))
-(assert_return (invoke "rotr" (i64.const 1) (i64.const 0)) (i64.const 1))
-(assert_return (invoke "rotr" (i64.const -1) (i64.const 1)) (i64.const -1))
-(assert_return (invoke "rotr" (i64.const 1) (i64.const 64)) (i64.const 1))
-(assert_return (invoke "rotr" (i64.const 0xabcd987602468ace) (i64.const 1)) (i64.const 0x55e6cc3b01234567))
-(assert_return (invoke "rotr" (i64.const 0xfe000000dc000000) (i64.const 4)) (i64.const 0x0fe000000dc00000))
-(assert_return (invoke "rotr" (i64.const 0xabcd1234ef567809) (i64.const 53)) (i64.const 0x6891a77ab3c04d5e))
-(assert_return (invoke "rotr" (i64.const 0xabd1234ef567809c) (i64.const 63)) (i64.const 0x57a2469deacf0139))
-(assert_return (invoke "rotr" (i64.const 0xabcd1234ef567809) (i64.const 0xf5)) (i64.const 0x6891a77ab3c04d5e))
-(assert_return (invoke "rotr" (i64.const 0xabcd7294ef567809) (i64.const 0xffffffffffffffed)) (i64.const 0x94a77ab3c04d5e6b))
-(assert_return (invoke "rotr" (i64.const 0xabd1234ef567809c) (i64.const 0x800000000000003f)) (i64.const 0x57a2469deacf0139))
-(assert_return (invoke "rotr" (i64.const 1) (i64.const 63)) (i64.const 2))
-(assert_return (invoke "rotr" (i64.const 0x8000000000000000) (i64.const 63)) (i64.const 1))
-
-(assert_return (invoke "clz" (i64.const 0xffffffffffffffff)) (i64.const 0))
-(assert_return (invoke "clz" (i64.const 0)) (i64.const 64))
-(assert_return (invoke "clz" (i64.const 0x00008000)) (i64.const 48))
-(assert_return (invoke "clz" (i64.const 0xff)) (i64.const 56))
-(assert_return (invoke "clz" (i64.const 0x8000000000000000)) (i64.const 0))
-(assert_return (invoke "clz" (i64.const 1)) (i64.const 63))
-(assert_return (invoke "clz" (i64.const 2)) (i64.const 62))
-(assert_return (invoke "clz" (i64.const 0x7fffffffffffffff)) (i64.const 1))
-
-(assert_return (invoke "ctz" (i64.const -1)) (i64.const 0))
-(assert_return (invoke "ctz" (i64.const 0)) (i64.const 64))
-(assert_return (invoke "ctz" (i64.const 0x00008000)) (i64.const 15))
-(assert_return (invoke "ctz" (i64.const 0x00010000)) (i64.const 16))
-(assert_return (invoke "ctz" (i64.const 0x8000000000000000)) (i64.const 63))
-(assert_return (invoke "ctz" (i64.const 0x7fffffffffffffff)) (i64.const 0))
-
-(assert_return (invoke "popcnt" (i64.const -1)) (i64.const 64))
-(assert_return (invoke "popcnt" (i64.const 0)) (i64.const 0))
-(assert_return (invoke "popcnt" (i64.const 0x00008000)) (i64.const 1))
-(assert_return (invoke "popcnt" (i64.const 0x8000800080008000)) (i64.const 4))
-(assert_return (invoke "popcnt" (i64.const 0x7fffffffffffffff)) (i64.const 63))
-(assert_return (invoke "popcnt" (i64.const 0xAAAAAAAA55555555)) (i64.const 32))
-(assert_return (invoke "popcnt" (i64.const 0x99999999AAAAAAAA)) (i64.const 32))
-(assert_return (invoke "popcnt" (i64.const 0xDEADBEEFDEADBEEF)) (i64.const 48))
-
-(assert_return (invoke "eqz" (i64.const 0)) (i32.const 1))
-(assert_return (invoke "eqz" (i64.const 1)) (i32.const 0))
-(assert_return (invoke "eqz" (i64.const 0x8000000000000000)) (i32.const 0))
-(assert_return (invoke "eqz" (i64.const 0x7fffffffffffffff)) (i32.const 0))
-(assert_return (invoke "eqz" (i64.const 0xffffffffffffffff)) (i32.const 0))
-
-(assert_return (invoke "eq" (i64.const 0) (i64.const 0)) (i32.const 1))
-(assert_return (invoke "eq" (i64.const 1) (i64.const 1)) (i32.const 1))
-(assert_return (invoke "eq" (i64.const -1) (i64.const 1)) (i32.const 0))
-(assert_return (invoke "eq" (i64.const 0x8000000000000000) (i64.const 0x8000000000000000)) (i32.const 1))
-(assert_return (invoke "eq" (i64.const 0x7fffffffffffffff) (i64.const 0x7fffffffffffffff)) (i32.const 1))
-(assert_return (invoke "eq" (i64.const -1) (i64.const -1)) (i32.const 1))
-(assert_return (invoke "eq" (i64.const 1) (i64.const 0)) (i32.const 0))
-(assert_return (invoke "eq" (i64.const 0) (i64.const 1)) (i32.const 0))
-(assert_return (invoke "eq" (i64.const 0x8000000000000000) (i64.const 0)) (i32.const 0))
-(assert_return (invoke "eq" (i64.const 0) (i64.const 0x8000000000000000)) (i32.const 0))
-(assert_return (invoke "eq" (i64.const 0x8000000000000000) (i64.const -1)) (i32.const 0))
-(assert_return (invoke "eq" (i64.const -1) (i64.const 0x8000000000000000)) (i32.const 0))
-(assert_return (invoke "eq" (i64.const 0x8000000000000000) (i64.const 0x7fffffffffffffff)) (i32.const 0))
-(assert_return (invoke "eq" (i64.const 0x7fffffffffffffff) (i64.const 0x8000000000000000)) (i32.const 0))
-
-(assert_return (invoke "ne" (i64.const 0) (i64.const 0)) (i32.const 0))
-(assert_return (invoke "ne" (i64.const 1) (i64.const 1)) (i32.const 0))
-(assert_return (invoke "ne" (i64.const -1) (i64.const 1)) (i32.const 1))
-(assert_return (invoke "ne" (i64.const 0x8000000000000000) (i64.const 0x8000000000000000)) (i32.const 0))
-(assert_return (invoke "ne" (i64.const 0x7fffffffffffffff) (i64.const 0x7fffffffffffffff)) (i32.const 0))
-(assert_return (invoke "ne" (i64.const -1) (i64.const -1)) (i32.const 0))
-(assert_return (invoke "ne" (i64.const 1) (i64.const 0)) (i32.const 1))
-(assert_return (invoke "ne" (i64.const 0) (i64.const 1)) (i32.const 1))
-(assert_return (invoke "ne" (i64.const 0x8000000000000000) (i64.const 0)) (i32.const 1))
-(assert_return (invoke "ne" (i64.const 0) (i64.const 0x8000000000000000)) (i32.const 1))
-(assert_return (invoke "ne" (i64.const 0x8000000000000000) (i64.const -1)) (i32.const 1))
-(assert_return (invoke "ne" (i64.const -1) (i64.const 0x8000000000000000)) (i32.const 1))
-(assert_return (invoke "ne" (i64.const 0x8000000000000000) (i64.const 0x7fffffffffffffff)) (i32.const 1))
-(assert_return (invoke "ne" (i64.const 0x7fffffffffffffff) (i64.const 0x8000000000000000)) (i32.const 1))
-
-(assert_return (invoke "lt_s" (i64.const 0) (i64.const 0)) (i32.const 0))
-(assert_return (invoke "lt_s" (i64.const 1) (i64.const 1)) (i32.const 0))
-(assert_return (invoke "lt_s" (i64.const -1) (i64.const 1)) (i32.const 1))
-(assert_return (invoke "lt_s" (i64.const 0x8000000000000000) (i64.const 0x8000000000000000)) (i32.const 0))
-(assert_return (invoke "lt_s" (i64.const 0x7fffffffffffffff) (i64.const 0x7fffffffffffffff)) (i32.const 0))
-(assert_return (invoke "lt_s" (i64.const -1) (i64.const -1)) (i32.const 0))
-(assert_return (invoke "lt_s" (i64.const 1) (i64.const 0)) (i32.const 0))
-(assert_return (invoke "lt_s" (i64.const 0) (i64.const 1)) (i32.const 1))
-(assert_return (invoke "lt_s" (i64.const 0x8000000000000000) (i64.const 0)) (i32.const 1))
-(assert_return (invoke "lt_s" (i64.const 0) (i64.const 0x8000000000000000)) (i32.const 0))
-(assert_return (invoke "lt_s" (i64.const 0x8000000000000000) (i64.const -1)) (i32.const 1))
-(assert_return (invoke "lt_s" (i64.const -1) (i64.const 0x8000000000000000)) (i32.const 0))
-(assert_return (invoke "lt_s" (i64.const 0x8000000000000000) (i64.const 0x7fffffffffffffff)) (i32.const 1))
-(assert_return (invoke "lt_s" (i64.const 0x7fffffffffffffff) (i64.const 0x8000000000000000)) (i32.const 0))
-
-(assert_return (invoke "lt_u" (i64.const 0) (i64.const 0)) (i32.const 0))
-(assert_return (invoke "lt_u" (i64.const 1) (i64.const 1)) (i32.const 0))
-(assert_return (invoke "lt_u" (i64.const -1) (i64.const 1)) (i32.const 0))
-(assert_return (invoke "lt_u" (i64.const 0x8000000000000000) (i64.const 0x8000000000000000)) (i32.const 0))
-(assert_return (invoke "lt_u" (i64.const 0x7fffffffffffffff) (i64.const 0x7fffffffffffffff)) (i32.const 0))
-(assert_return (invoke "lt_u" (i64.const -1) (i64.const -1)) (i32.const 0))
-(assert_return (invoke "lt_u" (i64.const 1) (i64.const 0)) (i32.const 0))
-(assert_return (invoke "lt_u" (i64.const 0) (i64.const 1)) (i32.const 1))
-(assert_return (invoke "lt_u" (i64.const 0x8000000000000000) (i64.const 0)) (i32.const 0))
-(assert_return (invoke "lt_u" (i64.const 0) (i64.const 0x8000000000000000)) (i32.const 1))
-(assert_return (invoke "lt_u" (i64.const 0x8000000000000000) (i64.const -1)) (i32.const 1))
-(assert_return (invoke "lt_u" (i64.const -1) (i64.const 0x8000000000000000)) (i32.const 0))
-(assert_return (invoke "lt_u" (i64.const 0x8000000000000000) (i64.const 0x7fffffffffffffff)) (i32.const 0))
-(assert_return (invoke "lt_u" (i64.const 0x7fffffffffffffff) (i64.const 0x8000000000000000)) (i32.const 1))
-
-(assert_return (invoke "le_s" (i64.const 0) (i64.const 0)) (i32.const 1))
-(assert_return (invoke "le_s" (i64.const 1) (i64.const 1)) (i32.const 1))
-(assert_return (invoke "le_s" (i64.const -1) (i64.const 1)) (i32.const 1))
-(assert_return (invoke "le_s" (i64.const 0x8000000000000000) (i64.const 0x8000000000000000)) (i32.const 1))
-(assert_return (invoke "le_s" (i64.const 0x7fffffffffffffff) (i64.const 0x7fffffffffffffff)) (i32.const 1))
-(assert_return (invoke "le_s" (i64.const -1) (i64.const -1)) (i32.const 1))
-(assert_return (invoke "le_s" (i64.const 1) (i64.const 0)) (i32.const 0))
-(assert_return (invoke "le_s" (i64.const 0) (i64.const 1)) (i32.const 1))
-(assert_return (invoke "le_s" (i64.const 0x8000000000000000) (i64.const 0)) (i32.const 1))
-(assert_return (invoke "le_s" (i64.const 0) (i64.const 0x8000000000000000)) (i32.const 0))
-(assert_return (invoke "le_s" (i64.const 0x8000000000000000) (i64.const -1)) (i32.const 1))
-(assert_return (invoke "le_s" (i64.const -1) (i64.const 0x8000000000000000)) (i32.const 0))
-(assert_return (invoke "le_s" (i64.const 0x8000000000000000) (i64.const 0x7fffffffffffffff)) (i32.const 1))
-(assert_return (invoke "le_s" (i64.const 0x7fffffffffffffff) (i64.const 0x8000000000000000)) (i32.const 0))
-
-(assert_return (invoke "le_u" (i64.const 0) (i64.const 0)) (i32.const 1))
-(assert_return (invoke "le_u" (i64.const 1) (i64.const 1)) (i32.const 1))
-(assert_return (invoke "le_u" (i64.const -1) (i64.const 1)) (i32.const 0))
-(assert_return (invoke "le_u" (i64.const 0x8000000000000000) (i64.const 0x8000000000000000)) (i32.const 1))
-(assert_return (invoke "le_u" (i64.const 0x7fffffffffffffff) (i64.const 0x7fffffffffffffff)) (i32.const 1))
-(assert_return (invoke "le_u" (i64.const -1) (i64.const -1)) (i32.const 1))
-(assert_return (invoke "le_u" (i64.const 1) (i64.const 0)) (i32.const 0))
-(assert_return (invoke "le_u" (i64.const 0) (i64.const 1)) (i32.const 1))
-(assert_return (invoke "le_u" (i64.const 0x8000000000000000) (i64.const 0)) (i32.const 0))
-(assert_return (invoke "le_u" (i64.const 0) (i64.const 0x8000000000000000)) (i32.const 1))
-(assert_return (invoke "le_u" (i64.const 0x8000000000000000) (i64.const -1)) (i32.const 1))
-(assert_return (invoke "le_u" (i64.const -1) (i64.const 0x8000000000000000)) (i32.const 0))
-(assert_return (invoke "le_u" (i64.const 0x8000000000000000) (i64.const 0x7fffffffffffffff)) (i32.const 0))
-(assert_return (invoke "le_u" (i64.const 0x7fffffffffffffff) (i64.const 0x8000000000000000)) (i32.const 1))
-
-(assert_return (invoke "gt_s" (i64.const 0) (i64.const 0)) (i32.const 0))
-(assert_return (invoke "gt_s" (i64.const 1) (i64.const 1)) (i32.const 0))
-(assert_return (invoke "gt_s" (i64.const -1) (i64.const 1)) (i32.const 0))
-(assert_return (invoke "gt_s" (i64.const 0x8000000000000000) (i64.const 0x8000000000000000)) (i32.const 0))
-(assert_return (invoke "gt_s" (i64.const 0x7fffffffffffffff) (i64.const 0x7fffffffffffffff)) (i32.const 0))
-(assert_return (invoke "gt_s" (i64.const -1) (i64.const -1)) (i32.const 0))
-(assert_return (invoke "gt_s" (i64.const 1) (i64.const 0)) (i32.const 1))
-(assert_return (invoke "gt_s" (i64.const 0) (i64.const 1)) (i32.const 0))
-(assert_return (invoke "gt_s" (i64.const 0x8000000000000000) (i64.const 0)) (i32.const 0))
-(assert_return (invoke "gt_s" (i64.const 0) (i64.const 0x8000000000000000)) (i32.const 1))
-(assert_return (invoke "gt_s" (i64.const 0x8000000000000000) (i64.const -1)) (i32.const 0))
-(assert_return (invoke "gt_s" (i64.const -1) (i64.const 0x8000000000000000)) (i32.const 1))
-(assert_return (invoke "gt_s" (i64.const 0x8000000000000000) (i64.const 0x7fffffffffffffff)) (i32.const 0))
-(assert_return (invoke "gt_s" (i64.const 0x7fffffffffffffff) (i64.const 0x8000000000000000)) (i32.const 1))
-
-(assert_return (invoke "gt_u" (i64.const 0) (i64.const 0)) (i32.const 0))
-(assert_return (invoke "gt_u" (i64.const 1) (i64.const 1)) (i32.const 0))
-(assert_return (invoke "gt_u" (i64.const -1) (i64.const 1)) (i32.const 1))
-(assert_return (invoke "gt_u" (i64.const 0x8000000000000000) (i64.const 0x8000000000000000)) (i32.const 0))
-(assert_return (invoke "gt_u" (i64.const 0x7fffffffffffffff) (i64.const 0x7fffffffffffffff)) (i32.const 0))
-(assert_return (invoke "gt_u" (i64.const -1) (i64.const -1)) (i32.const 0))
-(assert_return (invoke "gt_u" (i64.const 1) (i64.const 0)) (i32.const 1))
-(assert_return (invoke "gt_u" (i64.const 0) (i64.const 1)) (i32.const 0))
-(assert_return (invoke "gt_u" (i64.const 0x8000000000000000) (i64.const 0)) (i32.const 1))
-(assert_return (invoke "gt_u" (i64.const 0) (i64.const 0x8000000000000000)) (i32.const 0))
-(assert_return (invoke "gt_u" (i64.const 0x8000000000000000) (i64.const -1)) (i32.const 0))
-(assert_return (invoke "gt_u" (i64.const -1) (i64.const 0x8000000000000000)) (i32.const 1))
-(assert_return (invoke "gt_u" (i64.const 0x8000000000000000) (i64.const 0x7fffffffffffffff)) (i32.const 1))
-(assert_return (invoke "gt_u" (i64.const 0x7fffffffffffffff) (i64.const 0x8000000000000000)) (i32.const 0))
-
-(assert_return (invoke "ge_s" (i64.const 0) (i64.const 0)) (i32.const 1))
-(assert_return (invoke "ge_s" (i64.const 1) (i64.const 1)) (i32.const 1))
-(assert_return (invoke "ge_s" (i64.const -1) (i64.const 1)) (i32.const 0))
-(assert_return (invoke "ge_s" (i64.const 0x8000000000000000) (i64.const 0x8000000000000000)) (i32.const 1))
-(assert_return (invoke "ge_s" (i64.const 0x7fffffffffffffff) (i64.const 0x7fffffffffffffff)) (i32.const 1))
-(assert_return (invoke "ge_s" (i64.const -1) (i64.const -1)) (i32.const 1))
-(assert_return (invoke "ge_s" (i64.const 1) (i64.const 0)) (i32.const 1))
-(assert_return (invoke "ge_s" (i64.const 0) (i64.const 1)) (i32.const 0))
-(assert_return (invoke "ge_s" (i64.const 0x8000000000000000) (i64.const 0)) (i32.const 0))
-(assert_return (invoke "ge_s" (i64.const 0) (i64.const 0x8000000000000000)) (i32.const 1))
-(assert_return (invoke "ge_s" (i64.const 0x8000000000000000) (i64.const -1)) (i32.const 0))
-(assert_return (invoke "ge_s" (i64.const -1) (i64.const 0x8000000000000000)) (i32.const 1))
-(assert_return (invoke "ge_s" (i64.const 0x8000000000000000) (i64.const 0x7fffffffffffffff)) (i32.const 0))
-(assert_return (invoke "ge_s" (i64.const 0x7fffffffffffffff) (i64.const 0x8000000000000000)) (i32.const 1))
-
-(assert_return (invoke "ge_u" (i64.const 0) (i64.const 0)) (i32.const 1))
-(assert_return (invoke "ge_u" (i64.const 1) (i64.const 1)) (i32.const 1))
-(assert_return (invoke "ge_u" (i64.const -1) (i64.const 1)) (i32.const 1))
-(assert_return (invoke "ge_u" (i64.const 0x8000000000000000) (i64.const 0x8000000000000000)) (i32.const 1))
-(assert_return (invoke "ge_u" (i64.const 0x7fffffffffffffff) (i64.const 0x7fffffffffffffff)) (i32.const 1))
-(assert_return (invoke "ge_u" (i64.const -1) (i64.const -1)) (i32.const 1))
-(assert_return (invoke "ge_u" (i64.const 1) (i64.const 0)) (i32.const 1))
-(assert_return (invoke "ge_u" (i64.const 0) (i64.const 1)) (i32.const 0))
-(assert_return (invoke "ge_u" (i64.const 0x8000000000000000) (i64.const 0)) (i32.const 1))
-(assert_return (invoke "ge_u" (i64.const 0) (i64.const 0x8000000000000000)) (i32.const 0))
-(assert_return (invoke "ge_u" (i64.const 0x8000000000000000) (i64.const -1)) (i32.const 0))
-(assert_return (invoke "ge_u" (i64.const -1) (i64.const 0x8000000000000000)) (i32.const 1))
-(assert_return (invoke "ge_u" (i64.const 0x8000000000000000) (i64.const 0x7fffffffffffffff)) (i32.const 1))
-(assert_return (invoke "ge_u" (i64.const 0x7fffffffffffffff) (i64.const 0x8000000000000000)) (i32.const 0))
diff --git a/tests/misc_testsuite/winch/if.wast b/tests/misc_testsuite/winch/if.wast
deleted file mode 100644
index 79e054cfc..000000000
--- a/tests/misc_testsuite/winch/if.wast
+++ /dev/null
@@ -1,264 +0,0 @@
-;; Test `if` operator
-
-(module
-  ;; Auxiliary definition
-  (memory 1)
-
-  (func $dummy)
-
-  (func (export "empty") (param i32)
-    (if (local.get 0) (then))
-    (if (local.get 0) (then) (else))
-    (if $l (local.get 0) (then))
-    (if $l (local.get 0) (then) (else))
-  )
-
-  (func (export "singular") (param i32) (result i32)
-    (if (local.get 0) (then (nop)))
-    (if (local.get 0) (then (nop)) (else (nop)))
-    (if (result i32) (local.get 0) (then (i32.const 7)) (else (i32.const 8)))
-  )
-
-  (func (export "nested") (param i32 i32) (result i32)
-    (if (result i32) (local.get 0)
-      (then
-        (if (local.get 1) (then (call $dummy) (block) (nop)))
-        (if (local.get 1) (then) (else (call $dummy) (block) (nop)))
-        (if (result i32) (local.get 1)
-          (then (call $dummy) (i32.const 9))
-          (else (call $dummy) (i32.const 10))
-        )
-      )
-      (else
-        (if (local.get 1) (then (call $dummy) (block) (nop)))
-        (if (local.get 1) (then) (else (call $dummy) (block) (nop)))
-        (if (result i32) (local.get 1)
-          (then (call $dummy) (i32.const 10))
-          (else (call $dummy) (i32.const 11))
-        )
-      )
-    )
-  )
-
-  (func (export "as-loop-first") (param i32) (result i32)
-    (loop (result i32)
-      (if (result i32) (local.get 0)
-        (then (call $dummy) (i32.const 1))
-        (else (call $dummy) (i32.const 0))
-      )
-      (call $dummy) (call $dummy)
-    )
-  )
-  (func (export "as-loop-mid") (param i32) (result i32)
-    (loop (result i32)
-      (call $dummy)
-      (if (result i32) (local.get 0)
-        (then (call $dummy) (i32.const 1))
-        (else (call $dummy) (i32.const 0))
-      )
-      (call $dummy)
-    )
-  )
-  (func (export "as-loop-last") (param i32) (result i32)
-    (loop (result i32)
-      (call $dummy) (call $dummy)
-      (if (result i32) (local.get 0)
-        (then (call $dummy) (i32.const 1))
-        (else (call $dummy) (i32.const 0))
-      )
-    )
-  )
-
-  (func (export "as-if-condition") (param i32) (result i32)
-    (if (result i32)
-      (if (result i32) (local.get 0)
-        (then (i32.const 1)) (else (i32.const 0))
-      )
-      (then (call $dummy) (i32.const 2))
-      (else (call $dummy) (i32.const 3))
-    )
-  )
-
-  (func (export "as-br_if-first") (param i32) (result i32)
-    (block (result i32)
-      (br_if 0
-        (if (result i32) (local.get 0)
-          (then (call $dummy) (i32.const 1))
-          (else (call $dummy) (i32.const 0))
-        )
-        (i32.const 2)
-      )
-      (return (i32.const 3))
-    )
-  )
-  (func (export "as-br_if-last") (param i32) (result i32)
-    (block (result i32)
-      (br_if 0
-        (i32.const 2)
-        (if (result i32) (local.get 0)
-          (then (call $dummy) (i32.const 1))
-          (else (call $dummy) (i32.const 0))
-        )
-      )
-      (return (i32.const 3))
-    )
-  )
-
-  (func $f (param i32) (result i32) (local.get 0))
-
-  (func (export "as-call-value") (param i32) (result i32)
-    (call $f
-      (if (result i32) (local.get 0)
-        (then (i32.const 1))
-        (else (i32.const 0))
-      )
-    )
-  )
-  (func (export "as-return-value") (param i32) (result i32)
-    (if (result i32) (local.get 0)
-      (then (i32.const 1))
-      (else (i32.const 0)))
-    (return)
-  )
-  (func (export "as-br-value") (param i32) (result i32)
-    (block (result i32)
-      (br 0
-        (if (result i32) (local.get 0)
-          (then (i32.const 1))
-          (else (i32.const 0))
-        )
-      )
-    )
-  )
-  (func (export "as-local.set-value") (param i32) (result i32)
-    (local i32)
-    (local.set 0
-      (if (result i32) (local.get 0)
-        (then (i32.const 1))
-        (else (i32.const 0))
-      )
-    )
-    (local.get 0)
-  )
-  (func (export "as-unary-operand") (param i32) (result i32)
-    (i32.ctz
-      (if (result i32) (local.get 0)
-        (then (call $dummy) (i32.const 13))
-        (else (call $dummy) (i32.const -13))
-      )
-    )
-  )
-  (func (export "as-binary-operand") (param i32 i32) (result i32)
-    (i32.mul
-      (if (result i32) (local.get 0)
-        (then (call $dummy) (i32.const 3))
-        (else (call $dummy) (i32.const -3))
-      )
-      (if (result i32) (local.get 1)
-        (then (call $dummy) (i32.const 4))
-        (else (call $dummy) (i32.const -5))
-      )
-    )
-  )
-  (func (export "as-test-operand") (param i32) (result i32)
-    (i32.eqz
-      (if (result i32) (local.get 0)
-        (then (call $dummy) (i32.const 13))
-        (else (call $dummy) (i32.const 0))
-      )
-    )
-  )
-
-  (func (export "break-value") (param i32) (result i32)
-    (if (result i32) (local.get 0)
-      (then (br 0 (i32.const 18)) (i32.const 19))
-      (else (br 0 (i32.const 21)) (i32.const 20))
-    )
-  )
-
-  (func (export "effects") (param i32) (result i32)
-    (local i32)
-    (if
-      (block (result i32) (local.set 1 (i32.const 1)) (local.get 0))
-      (then
-        (local.set 1 (i32.mul (local.get 1) (i32.const 3)))
-        (local.set 1 (i32.sub (local.get 1) (i32.const 5)))
-        (local.set 1 (i32.mul (local.get 1) (i32.const 7)))
-        (br 0)
-        (local.set 1 (i32.mul (local.get 1) (i32.const 100)))
-      )
-      (else
-        (local.set 1 (i32.mul (local.get 1) (i32.const 5)))
-        (local.set 1 (i32.sub (local.get 1) (i32.const 7)))
-        (local.set 1 (i32.mul (local.get 1) (i32.const 3)))
-        (br 0)
-        (local.set 1 (i32.mul (local.get 1) (i32.const 1000)))
-      )
-    )
-    (local.get 1)
-  )
-)
-
-(assert_return (invoke "empty" (i32.const 0)))
-(assert_return (invoke "empty" (i32.const 1)))
-(assert_return (invoke "empty" (i32.const 100)))
-(assert_return (invoke "empty" (i32.const -2)))
-
-(assert_return (invoke "singular" (i32.const 0)) (i32.const 8))
-(assert_return (invoke "singular" (i32.const 1)) (i32.const 7))
-(assert_return (invoke "singular" (i32.const 10)) (i32.const 7))
-(assert_return (invoke "singular" (i32.const -10)) (i32.const 7))
-
-(assert_return (invoke "nested" (i32.const 0) (i32.const 0)) (i32.const 11))
-(assert_return (invoke "nested" (i32.const 1) (i32.const 0)) (i32.const 10))
-(assert_return (invoke "nested" (i32.const 0) (i32.const 1)) (i32.const 10))
-(assert_return (invoke "nested" (i32.const 3) (i32.const 2)) (i32.const 9))
-(assert_return (invoke "nested" (i32.const 0) (i32.const -100)) (i32.const 10))
-(assert_return (invoke "nested" (i32.const 10) (i32.const 10)) (i32.const 9))
-(assert_return (invoke "nested" (i32.const 0) (i32.const -1)) (i32.const 10))
-(assert_return (invoke "nested" (i32.const -111) (i32.const -2)) (i32.const 9))
-
-(assert_return (invoke "as-loop-first" (i32.const 0)) (i32.const 0))
-(assert_return (invoke "as-loop-first" (i32.const 1)) (i32.const 1))
-(assert_return (invoke "as-loop-mid" (i32.const 0)) (i32.const 0))
-(assert_return (invoke "as-loop-mid" (i32.const 1)) (i32.const 1))
-(assert_return (invoke "as-loop-last" (i32.const 0)) (i32.const 0))
-(assert_return (invoke "as-loop-last" (i32.const 1)) (i32.const 1))
-
-(assert_return (invoke "as-if-condition" (i32.const 0)) (i32.const 3))
-(assert_return (invoke "as-if-condition" (i32.const 1)) (i32.const 2))
-
-(assert_return (invoke "as-br_if-first" (i32.const 0)) (i32.const 0))
-(assert_return (invoke "as-br_if-first" (i32.const 1)) (i32.const 1))
-(assert_return (invoke "as-br_if-last" (i32.const 0)) (i32.const 3))
-(assert_return (invoke "as-br_if-last" (i32.const 1)) (i32.const 2))
-
-(assert_return (invoke "as-call-value" (i32.const 0)) (i32.const 0))
-(assert_return (invoke "as-call-value" (i32.const 1)) (i32.const 1))
-
-(assert_return (invoke "as-return-value" (i32.const 0)) (i32.const 0))
-(assert_return (invoke "as-return-value" (i32.const 1)) (i32.const 1))
-
-(assert_return (invoke "as-br-value" (i32.const 0)) (i32.const 0))
-(assert_return (invoke "as-br-value" (i32.const 1)) (i32.const 1))
-
-(assert_return (invoke "as-local.set-value" (i32.const 0)) (i32.const 0))
-(assert_return (invoke "as-local.set-value" (i32.const 1)) (i32.const 1))
-
-(assert_return (invoke "as-unary-operand" (i32.const 0)) (i32.const 0))
-(assert_return (invoke "as-unary-operand" (i32.const 1)) (i32.const 0))
-(assert_return (invoke "as-unary-operand" (i32.const -1)) (i32.const 0))
-
-(assert_return (invoke "as-binary-operand" (i32.const 0) (i32.const 0)) (i32.const 15))
-(assert_return (invoke "as-binary-operand" (i32.const 0) (i32.const 1)) (i32.const -12))
-(assert_return (invoke "as-binary-operand" (i32.const 1) (i32.const 0)) (i32.const -15))
-(assert_return (invoke "as-binary-operand" (i32.const 1) (i32.const 1)) (i32.const 12))
-
-(assert_return (invoke "as-test-operand" (i32.const 0)) (i32.const 1))
-(assert_return (invoke "as-test-operand" (i32.const 1)) (i32.const 0))
-
-(assert_return (invoke "break-value" (i32.const 1)) (i32.const 18))
-(assert_return (invoke "break-value" (i32.const 0)) (i32.const 21))
-
-(assert_return (invoke "effects" (i32.const 1)) (i32.const -14))
-(assert_return (invoke "effects" (i32.const 0)) (i32.const -6))
diff --git a/tests/misc_testsuite/winch/local_tee.wast b/tests/misc_testsuite/winch/local_tee.wast
deleted file mode 100644
index 240d9f481..000000000
--- a/tests/misc_testsuite/winch/local_tee.wast
+++ /dev/null
@@ -1,134 +0,0 @@
-;; Test `local.tee` operator
-
-(module
-  ;; Typing
-
-  (func (export "type-local-i32") (result i32) (local i32) (local.tee 0 (i32.const 0)))
-  (func (export "type-local-i64") (result i64) (local i64) (local.tee 0 (i64.const 0)))
-
-  (func (export "type-param-i32") (param i32) (result i32) (local.tee 0 (i32.const 10)))
-  (func (export "type-param-i64") (param i64) (result i64) (local.tee 0 (i64.const 11)))
-
-  (func $dummy)
-
-  (func (export "as-block-first") (param i32) (result i32)
-    (block (result i32) (local.tee 0 (i32.const 1)) (call $dummy))
-  )
-  (func (export "as-block-mid") (param i32) (result i32)
-    (block (result i32) (call $dummy) (local.tee 0 (i32.const 1)) (call $dummy))
-  )
-  (func (export "as-block-last") (param i32) (result i32)
-    (block (result i32) (call $dummy) (call $dummy) (local.tee 0 (i32.const 1)))
-  )
-
-  (func (export "as-loop-first") (param i32) (result i32)
-    (loop (result i32) (local.tee 0 (i32.const 3)) (call $dummy))
-  )
-  (func (export "as-loop-mid") (param i32) (result i32)
-    (loop (result i32) (call $dummy) (local.tee 0 (i32.const 4)) (call $dummy))
-  )
-  (func (export "as-loop-last") (param i32) (result i32)
-    (loop (result i32) (call $dummy) (call $dummy) (local.tee 0 (i32.const 5)))
-  )
-
-  (func (export "as-br-value") (param i32) (result i32)
-    (block (result i32) (br 0 (local.tee 0 (i32.const 9))))
-  )
-
-  (func (export "as-br_if-cond") (param i32)
-    (block (br_if 0 (local.tee 0 (i32.const 1))))
-  )
-
-  (func (export "as-return-value") (param i32) (result i32)
-    (return (local.tee 0 (i32.const 7)))
-  )
-
-  (func (export "as-if-cond") (param i32) (result i32)
-    (if (result i32) (local.tee 0 (i32.const 2))
-      (then (i32.const 0)) (else (i32.const 1))
-    )
-  )
-  (func (export "as-if-then") (param i32) (result i32)
-    (if (result i32) (local.get 0)
-      (then (local.tee 0 (i32.const 3))) (else (local.get 0))
-    )
-  )
-  (func (export "as-if-else") (param i32) (result i32)
-    (if (result i32) (local.get 0)
-      (then (local.get 0)) (else (local.tee 0 (i32.const 4)))
-    )
-  )
-
-  (func $f (param i32 i32 i32) (result i32) (i32.const -1))
-  (func (export "as-call-first") (param i32) (result i32)
-    (call $f (local.tee 0 (i32.const 12)) (i32.const 2) (i32.const 3))
-  )
-  (func (export "as-call-mid") (param i32) (result i32)
-    (call $f (i32.const 1) (local.tee 0 (i32.const 13)) (i32.const 3))
-  )
-  (func (export "as-call-last") (param i32) (result i32)
-    (call $f (i32.const 1) (i32.const 2) (local.tee 0 (i32.const 14)))
-  )
-
-  (func (export "as-local.set-value") (local i32)
-    (local.set 0 (local.tee 0 (i32.const 1)))
-  )
-  (func (export "as-local.tee-value") (param i32) (result i32)
-    (local.tee 0 (local.tee 0 (i32.const 1)))
-  )
-
-  (func (export "as-binary-left") (param i32) (result i32)
-    (i32.add (local.tee 0 (i32.const 3)) (i32.const 10))
-  )
-  (func (export "as-binary-right") (param i32) (result i32)
-    (i32.sub (i32.const 10) (local.tee 0 (i32.const 4)))
-  )
-
-  (func (export "as-test-operand") (param i32) (result i32)
-    (i32.eqz (local.tee 0 (i32.const 0)))
-  )
-
-  (func (export "as-compare-left") (param i32) (result i32)
-    (i32.le_s (local.tee 0 (i32.const 43)) (i32.const 10))
-  )
-  (func (export "as-compare-right") (param i32) (result i32)
-    (i32.ne (i32.const 10) (local.tee 0 (i32.const 42)))
-  )
-)
-
-(assert_return (invoke "type-local-i32") (i32.const 0))
-(assert_return (invoke "type-local-i64") (i64.const 0))
-
-(assert_return (invoke "type-param-i32" (i32.const 2)) (i32.const 10))
-(assert_return (invoke "type-param-i64" (i64.const 3)) (i64.const 11))
-
-(assert_return (invoke "as-block-first" (i32.const 0)) (i32.const 1))
-(assert_return (invoke "as-block-mid" (i32.const 0)) (i32.const 1))
-(assert_return (invoke "as-block-last" (i32.const 0)) (i32.const 1))
-
-(assert_return (invoke "as-loop-first" (i32.const 0)) (i32.const 3))
-(assert_return (invoke "as-loop-mid" (i32.const 0)) (i32.const 4))
-(assert_return (invoke "as-loop-last" (i32.const 0)) (i32.const 5))
-
-(assert_return (invoke "as-br-value" (i32.const 0)) (i32.const 9))
-
-(assert_return (invoke "as-br_if-cond" (i32.const 0)))
-
-(assert_return (invoke "as-return-value" (i32.const 0)) (i32.const 7))
-
-(assert_return (invoke "as-if-cond" (i32.const 0)) (i32.const 0))
-(assert_return (invoke "as-if-then" (i32.const 1)) (i32.const 3))
-(assert_return (invoke "as-if-else" (i32.const 0)) (i32.const 4))
-
-(assert_return (invoke "as-call-first" (i32.const 0)) (i32.const -1))
-(assert_return (invoke "as-call-mid" (i32.const 0)) (i32.const -1))
-(assert_return (invoke "as-call-last" (i32.const 0)) (i32.const -1))
-
-(assert_return (invoke "as-local.set-value"))
-(assert_return (invoke "as-local.tee-value" (i32.const 0)) (i32.const 1))
-
-(assert_return (invoke "as-binary-left" (i32.const 0)) (i32.const 13))
-(assert_return (invoke "as-binary-right" (i32.const 0)) (i32.const 6))
-(assert_return (invoke "as-test-operand" (i32.const 0)) (i32.const 1))
-(assert_return (invoke "as-compare-left" (i32.const 0)) (i32.const 0))
-(assert_return (invoke "as-compare-right" (i32.const 0)) (i32.const 1))
diff --git a/tests/misc_testsuite/winch/loop.wast b/tests/misc_testsuite/winch/loop.wast
deleted file mode 100644
index 961488ec0..000000000
--- a/tests/misc_testsuite/winch/loop.wast
+++ /dev/null
@@ -1,200 +0,0 @@
-;; Test `loop` opcode
-
-(module
-  (memory 1)
-
-  (func $dummy)
-
-  (func (export "empty")
-    (loop)
-    (loop $l)
-  )
-
-  (func (export "singular") (result i32)
-    (loop (nop))
-    (loop (result i32) (i32.const 7))
-  )
-
-
-  (func (export "nested") (result i32)
-    (loop (result i32)
-      (loop (call $dummy) (block) (nop))
-      (loop (result i32) (call $dummy) (i32.const 9))
-    )
-  )
-
-  (func (export "deep") (result i32)
-    (loop (result i32) (block (result i32)
-      (loop (result i32) (block (result i32)
-        (loop (result i32) (block (result i32)
-          (loop (result i32) (block (result i32)
-            (loop (result i32) (block (result i32)
-              (loop (result i32) (block (result i32)
-                (loop (result i32) (block (result i32)
-                  (loop (result i32) (block (result i32)
-                    (loop (result i32) (block (result i32)
-                      (loop (result i32) (block (result i32)
-                        (loop (result i32) (block (result i32)
-                          (loop (result i32) (block (result i32)
-                            (loop (result i32) (block (result i32)
-                              (loop (result i32) (block (result i32)
-                                (loop (result i32) (block (result i32)
-                                  (loop (result i32) (block (result i32)
-                                    (loop (result i32) (block (result i32)
-                                      (loop (result i32) (block (result i32)
-                                        (loop (result i32) (block (result i32)
-                                          (loop (result i32) (block (result i32)
-                                            (call $dummy) (i32.const 150)
-                                          ))
-                                        ))
-                                      ))
-                                    ))
-                                  ))
-                                ))
-                              ))
-                            ))
-                          ))
-                        ))
-                      ))
-                    ))
-                  ))
-                ))
-              ))
-            ))
-          ))
-        ))
-      ))
-    ))
-  )
-
-  (func (export "as-if-condition")
-    (loop (result i32) (i32.const 1)) (if (then (call $dummy)))
-  )
-  (func (export "as-if-then") (result i32)
-    (if (result i32) (i32.const 1) (then (loop (result i32) (i32.const 1))) (else (i32.const 2)))
-  )
-  (func (export "as-if-else") (result i32)
-    (if (result i32) (i32.const 1) (then (i32.const 2)) (else (loop (result i32) (i32.const 1))))
-  )
-
-  (func (export "as-br_if-first") (result i32)
-    (block (result i32) (br_if 0 (loop (result i32) (i32.const 1)) (i32.const 2)))
-  )
-  (func (export "as-br_if-last") (result i32)
-    (block (result i32) (br_if 0 (i32.const 2) (loop (result i32) (i32.const 1))))
-  )
-
-  (func $f (param i32) (result i32) (local.get 0))
-
-  (func (export "as-call-value") (result i32)
-    (call $f (loop (result i32) (i32.const 1)))
-  )
-  (func (export "as-return-value") (result i32)
-    (loop (result i32) (i32.const 1)) (return)
-  )
-  (func (export "as-br-value") (result i32)
-    (block (result i32) (br 0 (loop (result i32) (i32.const 1))))
-  )
-  (func (export "as-local.set-value") (result i32)
-    (local i32) (local.set 0 (loop (result i32) (i32.const 1))) (local.get 0)
-  )
-
-  (func (export "as-unary-operand") (result i32)
-    (i32.ctz (loop (result i32) (call $dummy) (i32.const 13)))
-  )
-  (func (export "as-binary-operand") (result i32)
-    (i32.mul
-      (loop (result i32) (call $dummy) (i32.const 3))
-      (loop (result i32) (call $dummy) (i32.const 4))
-    )
-  )
-  (func (export "as-test-operand") (result i32)
-    (i32.eqz (loop (result i32) (call $dummy) (i32.const 13)))
-  )
-
-  (func (export "break-inner") (result i32)
-    (local i32)
-    (local.set 0 (i32.const 0))
-    (local.set 0 (i32.add (local.get 0) (block (result i32) (loop (result i32) (block (result i32) (br 2 (i32.const 0x1)))))))
-    (local.set 0 (i32.add (local.get 0) (block (result i32) (loop (result i32) (loop (result i32) (br 2 (i32.const 0x2)))))))
-    (local.set 0 (i32.add (local.get 0) (block (result i32) (loop (result i32) (block (result i32) (loop (result i32) (br 1 (i32.const 0x4))))))))
-    (local.set 0 (i32.add (local.get 0) (block (result i32) (loop (result i32) (i32.ctz (br 1 (i32.const 0x8)))))))
-    (local.set 0 (i32.add (local.get 0) (block (result i32) (loop (result i32) (i32.ctz (loop (result i32) (br 2 (i32.const 0x10))))))))
-    (local.get 0)
-  )
-
-  (func $fx (export "effects") (result i32)
-    (local i32)
-    (block
-      (loop
-        (local.set 0 (i32.const 1))
-        (local.set 0 (i32.mul (local.get 0) (i32.const 3)))
-        (local.set 0 (i32.sub (local.get 0) (i32.const 5)))
-        (local.set 0 (i32.mul (local.get 0) (i32.const 7)))
-        (br 1)
-        (local.set 0 (i32.mul (local.get 0) (i32.const 100)))
-      )
-    )
-    (i32.eq (local.get 0) (i32.const -14))
-  )
-
-  (func (export "while") (param i64) (result i64)
-    (local i64)
-    (local.set 1 (i64.const 1))
-    (block
-      (loop
-        (br_if 1 (i64.eqz (local.get 0)))
-        (local.set 1 (i64.mul (local.get 0) (local.get 1)))
-        (local.set 0 (i64.sub (local.get 0) (i64.const 1)))
-        (br 0)
-      )
-    )
-    (local.get 1)
-  )
-
-  (func (export "for") (param i64) (result i64)
-    (local i64 i64)
-    (local.set 1 (i64.const 1))
-    (local.set 2 (i64.const 2))
-    (block
-      (loop
-        (br_if 1 (i64.gt_u (local.get 2) (local.get 0)))
-        (local.set 1 (i64.mul (local.get 1) (local.get 2)))
-        (local.set 2 (i64.add (local.get 2) (i64.const 1)))
-        (br 0)
-      )
-    )
-    (local.get 1)
-  )
-)
-
-(assert_return (invoke "empty"))
-(assert_return (invoke "singular") (i32.const 7))
-(assert_return (invoke "nested") (i32.const 9))
-(assert_return (invoke "deep") (i32.const 150))
-(assert_return (invoke "as-if-condition"))
-(assert_return (invoke "as-if-then") (i32.const 1))
-(assert_return (invoke "as-if-else") (i32.const 2))
-(assert_return (invoke "as-br_if-first") (i32.const 1))
-(assert_return (invoke "as-br_if-last") (i32.const 2))
-(assert_return (invoke "as-call-value") (i32.const 1))
-(assert_return (invoke "as-return-value") (i32.const 1))
-(assert_return (invoke "as-br-value") (i32.const 1))
-(assert_return (invoke "as-local.set-value") (i32.const 1))
-(assert_return (invoke "as-unary-operand") (i32.const 0))
-(assert_return (invoke "as-binary-operand") (i32.const 12))
-(assert_return (invoke "as-test-operand") (i32.const 0))
-(assert_return (invoke "break-inner") (i32.const 0x1f))
-(assert_return (invoke "effects") (i32.const 1))
-(assert_return (invoke "while" (i64.const 0)) (i64.const 1))
-(assert_return (invoke "while" (i64.const 1)) (i64.const 1))
-(assert_return (invoke "while" (i64.const 2)) (i64.const 2))
-(assert_return (invoke "while" (i64.const 3)) (i64.const 6))
-(assert_return (invoke "while" (i64.const 5)) (i64.const 120))
-(assert_return (invoke "while" (i64.const 20)) (i64.const 2432902008176640000))
-(assert_return (invoke "for" (i64.const 0)) (i64.const 1))
-(assert_return (invoke "for" (i64.const 1)) (i64.const 1))
-(assert_return (invoke "for" (i64.const 2)) (i64.const 2))
-(assert_return (invoke "for" (i64.const 3)) (i64.const 6))
-(assert_return (invoke "for" (i64.const 5)) (i64.const 120))
-(assert_return (invoke "for" (i64.const 20)) (i64.const 2432902008176640000))
diff --git a/winch/codegen/Cargo.toml b/winch/codegen/Cargo.toml
index e9aa457ac..5a9b5e7fd 100644
--- a/winch/codegen/Cargo.toml
+++ b/winch/codegen/Cargo.toml
@@ -4,7 +4,7 @@ name = "winch-codegen"
 description = "Winch code generation library"
 license = "Apache-2.0 WITH LLVM-exception"
 repository = "https://github.com/bytecodealliance/wasmtime"
-version = "0.10.0"
+version = "0.9.0"
 edition.workspace = true
 
 [dependencies]
diff --git a/winch/codegen/src/codegen/context.rs b/winch/codegen/src/codegen/context.rs
index 788f09fd4..311778f51 100644
--- a/winch/codegen/src/codegen/context.rs
+++ b/winch/codegen/src/codegen/context.rs
@@ -1,6 +1,5 @@
-use super::ControlStackFrame;
 use crate::{
-    abi::{ABIResult, ABI},
+    abi::ABIResult,
     frame::Frame,
     masm::{MacroAssembler, OperandSize, RegImm},
     reg::Reg,
@@ -247,40 +246,16 @@ impl<'a> CodeGenContext<'a> {
         self.stack.inner_mut().truncate(truncate);
     }
 
-    /// Pops the stack pointer to ensure that it is correctly placed according to the expectations
-    /// of the destination branch.
-    ///
-    /// This function must be used when performing unconditional jumps, as the machine stack might
-    /// be left unbalanced at the jump site, due to register spills. In this context unbalanced
-    /// refers to possible extra space created at the jump site, which might cause invaid memory
-    /// accesses. Note that in some cases the stack pointer offset might be already less than or
-    /// equal to the original stack pointer offset registered when entering the destination control
-    /// stack frame, which effectively means that when reaching the jump site no extra space was
-    /// allocated similar to what would happen in a fall through in which we assume that the
-    /// program has allocated and deallocated the right amount of stack space.
-    ///
-    /// More generally speaking the current stack pointer will be less than the original stack
-    /// pointer offset in cases in which the top value in the value stack is a memory entry which
-    /// needs to be popped into the return location according to the ABI (a register for single
-    /// value returns and a memory slot for 1+ returns). In short, this could happen given that we
-    /// handle return values preemptively when emitting unconditional branches, and push them back
-    /// to the value stack at control flow joins.
-    pub fn pop_sp_for_branch<M: MacroAssembler>(
+    /// Reset value and stack pointer to the given length
+    /// and stack pointer offset respectively.
+    pub fn reset_stack<M: MacroAssembler>(
         &mut self,
-        destination: &ControlStackFrame,
         masm: &mut M,
+        stack_len: usize,
+        sp_offset: u32,
     ) {
-        let (_, original_sp_offset) = destination.original_stack_len_and_sp_offset();
-        let current_sp_offset = masm.sp_offset();
-
-        assert!(
-            current_sp_offset >= original_sp_offset
-                || (current_sp_offset + <M::ABI as ABI>::word_bytes()) == original_sp_offset
-        );
-
-        if current_sp_offset > original_sp_offset {
-            masm.free_stack(current_sp_offset - original_sp_offset);
-        }
+        masm.reset_stack_pointer(sp_offset);
+        self.drop_last(self.stack.len() - stack_len);
     }
 
     /// Convenience wrapper around [`Self::spill_callback`].
@@ -320,21 +295,6 @@ impl<'a> CodeGenContext<'a> {
         }
     }
 
-    /// Pops the value at the stack top and assigns it to the local at the given
-    /// index, returning the register holding the source value.
-    pub fn set_local<M: MacroAssembler>(&mut self, masm: &mut M, index: u32) -> Reg {
-        let slot = self
-            .frame
-            .get_local(index)
-            .unwrap_or_else(|| panic!("valid local at slot = {}", index));
-        let size: OperandSize = slot.ty.into();
-        let src = self.pop_to_reg(masm, None, size);
-        let addr = masm.local_address(&slot);
-        masm.store(RegImm::reg(src), addr, size);
-
-        src
-    }
-
     /// Spill locals and registers to memory.
     // TODO optimize the spill range;
     //
diff --git a/winch/codegen/src/codegen/control.rs b/winch/codegen/src/codegen/control.rs
index 108a373bb..7dd0bff32 100644
--- a/winch/codegen/src/codegen/control.rs
+++ b/winch/codegen/src/codegen/control.rs
@@ -44,8 +44,6 @@ pub(crate) enum ControlStackFrame {
     If {
         /// The if continuation label.
         cont: MachLabel,
-        /// The exit label of the block.
-        exit: MachLabel,
         /// The return values of the block.
         result: ABIResult,
         /// The size of the value stack at the beginning of the If.
@@ -56,8 +54,8 @@ pub(crate) enum ControlStackFrame {
         reachable: bool,
     },
     Else {
-        /// The exit label of the block.
-        exit: MachLabel,
+        /// The else continuation label.
+        cont: MachLabel,
         /// The return values of the block.
         result: ABIResult,
         /// The size of the value stack at the beginning of the Else.
@@ -105,7 +103,6 @@ impl ControlStackFrame {
         let result = <M::ABI as ABI>::result(&returns, &CallingConvention::Default);
         let mut control = Self::If {
             cont: masm.get_label(),
-            exit: masm.get_label(),
             result,
             reachable: context.reachable,
             original_stack_len: 0,
@@ -231,7 +228,6 @@ impl ControlStackFrame {
             If {
                 result,
                 original_stack_len,
-                exit,
                 ..
             } => {
                 assert!((*original_stack_len + result.len()) == context.stack.len());
@@ -240,9 +236,10 @@ impl ControlStackFrame {
                 context.pop_abi_results(&result, masm);
                 // Before binding the else branch, we emit the jump to the end
                 // label.
-                masm.jmp(*exit);
+                let exit_label = masm.get_label();
+                masm.jmp(exit_label);
                 // Bind the else branch.
-                self.bind_else(masm, context.reachable);
+                self.bind_else(masm, Some(exit_label), context.reachable);
             }
             _ => unreachable!(),
         }
@@ -250,7 +247,12 @@ impl ControlStackFrame {
 
     /// Binds the else branch label and converts `self` to
     /// [`ControlStackFrame::Else`].
-    pub fn bind_else<M: MacroAssembler>(&mut self, masm: &mut M, reachable: bool) {
+    pub fn bind_else<M: MacroAssembler>(
+        &mut self,
+        masm: &mut M,
+        exit: Option<MachLabel>,
+        reachable: bool,
+    ) {
         use ControlStackFrame::*;
         match self {
             If {
@@ -258,15 +260,20 @@ impl ControlStackFrame {
                 result,
                 original_stack_len,
                 original_sp_offset,
-                exit,
                 ..
             } => {
                 // Bind the else branch.
                 masm.bind(*cont);
 
+                let label = if let Some(cont) = exit {
+                    cont
+                } else {
+                    masm.get_label()
+                };
+
                 // Update the stack control frame with an else control frame.
                 *self = ControlStackFrame::Else {
-                    exit: *exit,
+                    cont: label,
                     original_stack_len: *original_stack_len,
                     result: *result,
                     reachable,
@@ -325,15 +332,6 @@ impl ControlStackFrame {
 
     /// Binds the exit label of the control stack frame.
     pub fn bind_exit_label<M: MacroAssembler>(&self, masm: &mut M) {
-        use ControlStackFrame::*;
-        match self {
-            // We use an explicit label to track the exit of an if block. In case there's no
-            // else, we bind the if's continuation block to make sure that any jumps from the if
-            // condition are reachable and we bind the explicit exit label as well to ensure that any
-            // branching instructions are able to correctly reach the block's end.
-            If { cont, .. } => masm.bind(*cont),
-            _ => {}
-        }
         if let Some(label) = self.exit_label() {
             masm.bind(*label);
         }
@@ -344,7 +342,8 @@ impl ControlStackFrame {
         use ControlStackFrame::*;
 
         match self {
-            If { exit, .. } | Else { exit, .. } | Block { exit, .. } => exit,
+            If { cont, .. } | Else { cont, .. } => cont,
+            Block { exit, .. } => exit,
             Loop { head, .. } => head,
         }
     }
@@ -356,7 +355,8 @@ impl ControlStackFrame {
         use ControlStackFrame::*;
 
         match self {
-            If { exit, .. } | Else { exit, .. } | Block { exit, .. } => Some(exit),
+            If { cont, .. } | Else { cont, .. } => Some(cont),
+            Block { exit, .. } => Some(exit),
             Loop { .. } => None,
         }
     }
diff --git a/winch/codegen/src/codegen/env.rs b/winch/codegen/src/codegen/env.rs
index d3676ca65..78ceee2b4 100644
--- a/winch/codegen/src/codegen/env.rs
+++ b/winch/codegen/src/codegen/env.rs
@@ -1,8 +1,7 @@
 use smallvec::{smallvec, SmallVec};
 use wasmparser::BlockType;
 use wasmtime_environ::{
-    FuncIndex, GlobalIndex, ModuleTranslation, PtrSize, TypeConvert, VMOffsets, WasmFuncType,
-    WasmType,
+    FuncIndex, ModuleTranslation, PtrSize, TypeConvert, VMOffsets, WasmFuncType, WasmType,
 };
 
 /// The function environment.
@@ -29,7 +28,9 @@ impl<'a, P: PtrSize> FuncEnv<'a, P> {
     /// Resolves a function [`Callee`] from an index.
     pub fn callee_from_index(&self, idx: FuncIndex) -> Callee {
         let types = &self.translation.get_types();
-        let ty = types[types.function_at(idx.as_u32())].unwrap_func();
+        let ty = types
+            .function_at(idx.as_u32())
+            .unwrap_or_else(|| panic!("function type at index: {}", idx.as_u32()));
         let ty = self.translation.module.convert_func_type(ty);
         let import = self.translation.module.is_imported_function(idx);
 
@@ -49,17 +50,6 @@ impl<'a, P: PtrSize> FuncEnv<'a, P> {
             _ => unimplemented!("multi-value"),
         }
     }
-
-    /// Resolves the type and offset of a global at the given index.
-    pub fn resolve_global_type_and_offset(&self, index: GlobalIndex) -> (WasmType, u32) {
-        let ty = self.translation.module.globals[index].wasm_ty;
-        let offset = match self.translation.module.defined_global_index(index) {
-            Some(defined_index) => self.vmoffsets.vmctx_vmglobal_definition(defined_index),
-            None => self.vmoffsets.vmctx_vmglobal_import_from(index),
-        };
-
-        (ty, offset)
-    }
 }
 
 /// Metadata about a function callee.  Use by the code generation
diff --git a/winch/codegen/src/codegen/mod.rs b/winch/codegen/src/codegen/mod.rs
index a4f69dd9c..10861a343 100644
--- a/winch/codegen/src/codegen/mod.rs
+++ b/winch/codegen/src/codegen/mod.rs
@@ -111,13 +111,9 @@ where
                     // entry, the if-else branch will be reachable.
                     self.context.reachable = true;
                     // Reset the stack to the original length and offset.
-                    Self::reset_stack(
-                        &mut self.context,
-                        self.masm,
-                        *original_stack_len,
-                        *original_sp_offset,
-                    );
-                    frame.bind_else(self.masm, self.context.reachable);
+                    self.context
+                        .reset_stack(self.masm, *original_stack_len, *original_sp_offset);
+                    frame.bind_else(self.masm, None, self.context.reachable);
                 }
             }
             _ => unreachable!(),
@@ -133,7 +129,8 @@ where
 
             let (value_stack_len, sp_offset) = frame.original_stack_len_and_sp_offset();
             // Reset the stack to the original length and offset.
-            Self::reset_stack(&mut self.context, self.masm, value_stack_len, sp_offset);
+            self.context
+                .reset_stack(self.masm, value_stack_len, sp_offset);
             // If the current frame is the outermost frame, which corresponds to the
             // current function's body, only bind the exit label as we don't need to
             // push any more values to the value stack, else perform the entire `bind_end`
@@ -146,14 +143,6 @@ where
         }
     }
 
-    /// Helper function to reset value and stack pointer to the given length and stack pointer
-    /// offset respectively. This function is only used when restoring the code generation's
-    /// reachabiliy state when handling an unreachable `end` or `else`.
-    fn reset_stack(context: &mut CodeGenContext, masm: &mut M, stack_len: usize, sp_offset: u32) {
-        masm.reset_stack_pointer(sp_offset);
-        context.drop_last(context.stack.len() - stack_len);
-    }
-
     fn emit_body(
         &mut self,
         body: &mut BinaryReader<'a>,
diff --git a/winch/codegen/src/visitor.rs b/winch/codegen/src/visitor.rs
index 27bf2028f..d5d7e6caa 100644
--- a/winch/codegen/src/visitor.rs
+++ b/winch/codegen/src/visitor.rs
@@ -4,13 +4,12 @@
 //! which validates and dispatches to the corresponding
 //! machine code emitter.
 
-use crate::abi::ABI;
 use crate::codegen::CodeGen;
 use crate::codegen::ControlStackFrame;
 use crate::masm::{CmpKind, DivKind, MacroAssembler, OperandSize, RegImm, RemKind, ShiftKind};
 use crate::stack::Val;
 use wasmparser::{BlockType, VisitOperator};
-use wasmtime_environ::{FuncIndex, GlobalIndex, WasmType};
+use wasmtime_environ::{FuncIndex, WasmType};
 
 /// A macro to define unsupported WebAssembly operators.
 ///
@@ -106,9 +105,6 @@ macro_rules! def_unsupported {
     (emit BrIf $($rest:tt)*) => {};
     (emit Return $($rest:tt)*) => {};
     (emit Unreachable $($rest:tt)*) => {};
-    (emit LocalTee $($rest:tt)*) => {};
-    (emit GlobalGet $($rest:tt)*) => {};
-    (emit GlobalSet $($rest:tt)*) => {};
 
     (emit $unsupported:tt $($rest:tt)*) => {$($rest)*};
 }
@@ -497,7 +493,15 @@ where
 
     // TODO verify the case where the target local is on the stack.
     fn visit_local_set(&mut self, index: u32) {
-        let src = self.context.set_local(self.masm, index);
+        let context = &mut self.context;
+        let frame = context.frame;
+        let slot = frame
+            .get_local(index)
+            .expect(&format!("vald local at slot = {}", index));
+        let size: OperandSize = slot.ty.into();
+        let src = self.context.pop_to_reg(self.masm, None, size);
+        let addr = self.masm.local_address(&slot);
+        self.masm.store(RegImm::reg(src), addr, size);
         self.context.regalloc.free_gpr(src);
     }
 
@@ -546,7 +550,6 @@ where
     fn visit_br(&mut self, depth: u32) {
         let frame = Self::control_at(&mut self.control_frames, depth);
         self.context.pop_abi_results(frame.result(), self.masm);
-        self.context.pop_sp_for_branch(&frame, self.masm);
         self.masm.jmp(*frame.label());
         frame.set_as_target();
         self.context.reachable = false;
@@ -577,8 +580,6 @@ where
         // know that it should exist at index 0.
         let outermost = &mut self.control_frames[0];
         self.context.pop_abi_results(outermost.result(), self.masm);
-        // Ensure that the stack pointer is correctly balanced.
-        self.context.pop_sp_for_branch(&outermost, self.masm);
         // The outermost should always be a block and therefore,
         // should always have an exit label.
         self.masm.jmp(*outermost.exit_label().unwrap());
@@ -597,33 +598,6 @@ where
         outermost.set_as_target();
     }
 
-    fn visit_local_tee(&mut self, index: u32) {
-        let src = self.context.set_local(self.masm, index);
-        self.context.stack.push(Val::reg(src));
-    }
-
-    fn visit_global_get(&mut self, global_index: u32) {
-        let index = GlobalIndex::from_u32(global_index);
-        let (ty, offset) = self.env.resolve_global_type_and_offset(index);
-        let addr = self
-            .masm
-            .address_at_reg(<M::ABI as ABI>::vmctx_reg(), offset);
-        let dst = self.context.any_gpr(self.masm);
-        self.masm.load(addr, dst, ty.into());
-        self.context.stack.push(Val::reg(dst));
-    }
-
-    fn visit_global_set(&mut self, global_index: u32) {
-        let index = GlobalIndex::from_u32(global_index);
-        let (ty, offset) = self.env.resolve_global_type_and_offset(index);
-        let addr = self
-            .masm
-            .address_at_reg(<M::ABI as ABI>::vmctx_reg(), offset);
-        let reg = self.context.pop_to_reg(self.masm, None, ty.into());
-        self.context.free_gpr(reg);
-        self.masm.store(reg.into(), addr, ty.into());
-    }
-
     wasmparser::for_each_operator!(def_unsupported);
 }
 
diff --git a/winch/filetests/filetests/x64/if/as_br_if_last.wat b/winch/filetests/filetests/x64/if/as_br_if_last.wat
deleted file mode 100644
index d78bb0188..000000000
--- a/winch/filetests/filetests/x64/if/as_br_if_last.wat
+++ /dev/null
@@ -1,48 +0,0 @@
-;;! target = "x86_64"
-(module
-  (func $dummy)
-  (func (export "as-br_if-last") (param i32) (result i32)
-    (block (result i32)
-      (br_if 0
-        (i32.const 2)
-        (if (result i32) (local.get 0)
-          (then (call $dummy) (i32.const 1))
-          (else (call $dummy) (i32.const 0))
-        )
-      )
-      (return (i32.const 3))
-    )
-  )
-)
-;;    0:	 55                   	push	rbp
-;;    1:	 4889e5               	mov	rbp, rsp
-;;    4:	 4883ec08             	sub	rsp, 8
-;;    8:	 4c893424             	mov	qword ptr [rsp], r14
-;;    c:	 4883c408             	add	rsp, 8
-;;   10:	 5d                   	pop	rbp
-;;   11:	 c3                   	ret	
-;;
-;;    0:	 55                   	push	rbp
-;;    1:	 4889e5               	mov	rbp, rsp
-;;    4:	 4883ec10             	sub	rsp, 0x10
-;;    8:	 897c240c             	mov	dword ptr [rsp + 0xc], edi
-;;    c:	 4c89742404           	mov	qword ptr [rsp + 4], r14
-;;   11:	 8b44240c             	mov	eax, dword ptr [rsp + 0xc]
-;;   15:	 85c0                 	test	eax, eax
-;;   17:	 0f8411000000         	je	0x2e
-;;   1d:	 e800000000           	call	0x22
-;;   22:	 48c7c001000000       	mov	rax, 1
-;;   29:	 e90c000000           	jmp	0x3a
-;;   2e:	 e800000000           	call	0x33
-;;   33:	 48c7c000000000       	mov	rax, 0
-;;   3a:	 50                   	push	rax
-;;   3b:	 59                   	pop	rcx
-;;   3c:	 48c7c002000000       	mov	rax, 2
-;;   43:	 85c9                 	test	ecx, ecx
-;;   45:	 0f850c000000         	jne	0x57
-;;   4b:	 50                   	push	rax
-;;   4c:	 48c7c003000000       	mov	rax, 3
-;;   53:	 4883c408             	add	rsp, 8
-;;   57:	 4883c410             	add	rsp, 0x10
-;;   5b:	 5d                   	pop	rbp
-;;   5c:	 c3                   	ret	
diff --git a/winch/filetests/filetests/x64/if/break_value.wat b/winch/filetests/filetests/x64/if/break_value.wat
deleted file mode 100644
index 4c2adc533..000000000
--- a/winch/filetests/filetests/x64/if/break_value.wat
+++ /dev/null
@@ -1,24 +0,0 @@
-;;! target = "x86_64"
-
-(module
-  (func (export "break-value") (param i32) (result i32)
-    (if (result i32) (local.get 0)
-      (then (br 0 (i32.const 18)) (i32.const 19))
-      (else (br 0 (i32.const 21)) (i32.const 20))
-    )
-  )
-)
-;;    0:	 55                   	push	rbp
-;;    1:	 4889e5               	mov	rbp, rsp
-;;    4:	 4883ec10             	sub	rsp, 0x10
-;;    8:	 897c240c             	mov	dword ptr [rsp + 0xc], edi
-;;    c:	 4c89742404           	mov	qword ptr [rsp + 4], r14
-;;   11:	 8b44240c             	mov	eax, dword ptr [rsp + 0xc]
-;;   15:	 85c0                 	test	eax, eax
-;;   17:	 0f840c000000         	je	0x29
-;;   1d:	 48c7c012000000       	mov	rax, 0x12
-;;   24:	 e907000000           	jmp	0x30
-;;   29:	 48c7c015000000       	mov	rax, 0x15
-;;   30:	 4883c410             	add	rsp, 0x10
-;;   34:	 5d                   	pop	rbp
-;;   35:	 c3                   	ret	
diff --git a/winch/filetests/src/lib.rs b/winch/filetests/src/lib.rs
index ab6149dc5..24b32ef8c 100644
--- a/winch/filetests/src/lib.rs
+++ b/winch/filetests/src/lib.rs
@@ -154,7 +154,9 @@ mod test {
         let types = &translation.get_types();
 
         let index = module.func_index(f.0);
-        let sig = types[types.function_at(index.as_u32())].unwrap_func();
+        let sig = types
+            .function_at(index.as_u32())
+            .expect(&format!("function type at index {:?}", index.as_u32()));
         let sig = translation.module.convert_func_type(&sig);
 
         let FunctionBodyData { body, validator } = f.1;
diff --git a/winch/src/compile.rs b/winch/src/compile.rs
index 723f3a6ac..154d53791 100644
--- a/winch/src/compile.rs
+++ b/winch/src/compile.rs
@@ -53,7 +53,9 @@ fn compile(
 ) -> Result<()> {
     let index = translation.module.func_index(f.0);
     let types = &translation.get_types();
-    let sig = types[types.function_at(index.as_u32())].unwrap_func();
+    let sig = types
+        .function_at(index.as_u32())
+        .expect(&format!("function type at index {:?}", index.as_u32()));
     let sig = translation.module.convert_func_type(sig);
     let FunctionBodyData { body, validator } = f.1;
     let mut validator = validator.into_validator(Default::default());
